<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-20T07:03:14.754Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>epoll</title>
    <link href="http://example.com/jsblog/32082a79.html"/>
    <id>http://example.com/jsblog/32082a79.html</id>
    <published>2020-12-20T06:49:37.000Z</published>
    <updated>2020-12-20T07:03:14.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是epoll"><a href="#什么是epoll" class="headerlink" title="什么是epoll"></a>什么是epoll</h2><p>epoll是linux内核的可扩展I/O事件通知机制，在linux2.5首次登场，它的目标是取代既有的posix select与poll系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能，epoll实现的功能与poll类似，都是监听多个文件描述符上的事件。<a id="more"></a>epoll通过使用红黑树搜索被监控的文件描述符。</p><h2 id="为什么会出现epoll"><a href="#为什么会出现epoll" class="headerlink" title="为什么会出现epoll"></a>为什么会出现epoll</h2><p>出现epoll是因为现有的select以及poll不能够满足系统的需求，并且两者的开销在进行大量IO操作的时候都很大。首先看一下select的问题：</p><p>每次调用select都要将fd_set集合从用户态拷贝到内核态，当fd_set集合很大时，开销很大，每次调用select都需要在内核遍历传递来的所有的fd_set，如果fd_set很大，开销会很大，fd_set的大小由限制，系统中通过宏来控制而且不可改变（限制为1024）。Poll机制和select机制差不多，但是poll机制解决了文件描述符数量的限制但是没有解决当文件描述符过多的时候开销过大的问题。epoll是基于事件驱动的IO方式，epoll没有描述符个数限制。</p><h2 id="epoll触发模式"><a href="#epoll触发模式" class="headerlink" title="epoll触发模式"></a>epoll触发模式</h2><p>epoll提供了边缘触发和水平触发模式。在ET（边缘）模式中，epoll检测到有IO事件时，通过epoll_wait调用会得到有事件通知的文件描述符，如果不处理这个文件模式符，那么下次调用epoll_wait的时候就不会再次通知此事件（直到有某些操作将就绪变成未就绪状态，也就是说边缘模式只通知一次）；而LT（水平触发）模式时默认的工作模式，即当epoll_wait检查到文件描述符事件时会立即通知应用程序，如果应用程序不处理，下次调用epoll_wait的时候还会再次通知。</p><h2 id="epoll的系统调用（要包含sys-epoll-h头文件）"><a href="#epoll的系统调用（要包含sys-epoll-h头文件）" class="headerlink" title="epoll的系统调用（要包含sys/epoll.h头文件）"></a>epoll的系统调用（要包含sys/epoll.h头文件）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>\1. epoll_create函数创建一个epoll句柄，参数size表明内核要监听的描述符数量，调用成功返回一个epoll句柄描述符。epoll_create已经被弃用，更多推荐使用epoll_create1函数来代替，</p><p>\2. epoll_ctl函数用来注册要监听的事件类型，参数解释如下：</p><p>epfd ：表示epoll句柄</p><p>op : 表示fd的操作类型，有一下三种</p><ul><li>EPOLL_CTL_ADD 注册新的fd到epfd中</li><li>EPOLL_CTL_MOD 修改已注册的fd的监听事件</li><li>EPOLL_CTL_DEL 从epfd中删除一个fd</li></ul><p>fd: 要监听的描述符</p><p>event 表示要监听的事件。epoll_event的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"> <span class="keyword">void</span> *ptr;</span><br><span class="line"> <span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">uint32_t</span> u32;</span><br><span class="line"> <span class="keyword">uint64_t</span> u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>其中epoll_event中的events成员由以下可用事件类型的零个或多个组合在一起形成的掩码：</p><ul><li>EPOLLIN ： 关联的文件描述符可以读,</li><li>EPOLLOUT : 关联的文件描述符可以写；</li><li>EPOLLPRI : 关联的文件描述符由紧急的数据可以读</li><li>EPOLLERR: 关联的文件描述符发生错误</li><li>EPOLLHUP : 关联的文件描述符被挂断</li><li>EPOLLRDHUP : 流套接字对等关闭连接，或半关闭写</li><li>EPOLLET： 设置为边缘触发模式</li><li>EPOLLONESHOT : 只监听一次事件，如果要继续监听这个事件，那么需要再次把这个fd加入到epoll队列中。</li></ul><p>\3. epoll_wait函数等待事件的就绪，成功时返回就绪事件数目，调用失败时返回-1，等待超时返回0.其中参数含义如下：</p><ul><li>epfd : epoll句柄</li><li>events :表示从内核的多的就绪事件集合</li><li>maxevents : 告诉内核events的大小</li><li>timeout : 表示等待的时间</li></ul><p>它会阻塞到一个文件描述符有事件发生；信号中断处理或者超时。</p><h2 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h2><p>支持一个进程打开大数目的文件描述符，select对于文件描述符的大小由一定的限制，epoll则没有这个限制；IO效率不会随着文件描述符数目的增加而线性下降，select/poll都会随着文件描述符的数量增加而性能降低，因为在有事件发生的时候select和poll都要遍历所有的文件描述符才能确定是哪一个文件描述符由事件，而epoll则只会对活跃的文件描述符进行操作。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符。epoll使用mmap进行内核与用户空间消息传递。</p><h2 id="epoll实例"><a href="#epoll实例" class="headerlink" title="epoll实例"></a>epoll实例</h2><p>下面学习了这些理论的基础，还是要实践一下的。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFF 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 9873</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSockfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_IP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">    bzero(&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(port);</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd,(struct sockaddr*)&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd,<span class="number">1024</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to listen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNoBlockfd</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(sockfd,F_SETFL,fcntl(sockfd,F_GETFD,<span class="number">0</span>) |O_NONBLOCK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to set nonblock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> listen_fd,conn_fd,nfds,epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">inAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> in_len = <span class="keyword">sizeof</span>(inAddr);</span><br><span class="line">    bzero(&amp;inAddr,in_len);</span><br><span class="line">    <span class="comment">//create listen fd</span></span><br><span class="line">    listen_fd = createSockfd(PORT);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to create sockfd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set no block</span></span><br><span class="line">    <span class="keyword">if</span> (setNoBlockfd(listen_fd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//create epollfd</span></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create1(<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to create epollfd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register the listen fd</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd,EPOLL_CTL_ADD,listen_fd,&amp;ev) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to add listen fd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buff[MAX_BUFF];</span><br><span class="line">    bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = epoll_wait(epollfd,events,MAX_EVENTS,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, (struct sockaddr *) &amp;inAddr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                setNoBlockfd(conn_fd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connect form: %s\n&quot;</span>, inet_ntoa(inAddr.sin_addr));</span><br><span class="line">                <span class="comment">//register conn_fd</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> nread = read(events[i].data.fd,buff,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">                <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                    epoll_ctl( epollfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buff);</span><br><span class="line">                <span class="keyword">if</span> (write(events[i].data.fd,buff,nread) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是epoll&quot;&gt;&lt;a href=&quot;#什么是epoll&quot; class=&quot;headerlink&quot; title=&quot;什么是epoll&quot;&gt;&lt;/a&gt;什么是epoll&lt;/h2&gt;&lt;p&gt;epoll是linux内核的可扩展I/O事件通知机制，在linux2.5首次登场，它的目标是取代既有的posix select与poll系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能，epoll实现的功能与poll类似，都是监听多个文件描述符上的事件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG之libavfilter</title>
    <link href="http://example.com/jsblog/17b182ff.html"/>
    <id>http://example.com/jsblog/17b182ff.html</id>
    <published>2020-12-20T06:28:40.000Z</published>
    <updated>2020-12-20T06:49:05.517Z</updated>
    
    <content type="html"><![CDATA[<p>FFMPEG除了具有编解码的能力之外，还包含一个强大的功能组件—滤镜avfilter。<a id="more"></a>avfilter经常用于多媒体的处理与编辑。在使用滤镜处理音视频的特效之前，首先需要了解一下Filter的基本格式。</p><p>FFMPEG中的滤镜参数的排列方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[输入流或者标记名]滤镜参数[临时变量名]；[输入流或者标记名]滤镜参数[临时变量名]...</span><br></pre></td></tr></table></figure><p>在设置一些滤镜的时候经常会使用到根据时间轴进行的操作，也就不可避免的要使用到FFMPEG中的Filter的时间内置变量。接下来看一下Filter内置的时间变量，下表是Filter内置的时间变量：</p><table><thead><tr><th>说明</th><th>变量</th></tr></thead><tbody><tr><td>t</td><td>时间戳以秒表示，如果输入的时间位置，则是NAN</td></tr><tr><td>n</td><td>输入帧的顺序编号，从0开始</td></tr><tr><td>pos</td><td>输入帧的位置，如果未知就是NAN</td></tr><tr><td>w</td><td>视频帧的宽度</td></tr><tr><td>h</td><td>视频帧的高度</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;FFMPEG除了具有编解码的能力之外，还包含一个强大的功能组件—滤镜avfilter。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>Python之tuple</title>
    <link href="http://example.com/jsblog/84150675.html"/>
    <id>http://example.com/jsblog/84150675.html</id>
    <published>2020-12-20T06:06:55.000Z</published>
    <updated>2020-12-20T06:07:44.332Z</updated>
    
    <content type="html"><![CDATA[<p>以前就学过Python,因为许久不用导致Python中的好多知识都忘记了。<a id="more"></a>现在想要重新拿起来。主要就是为了学习Python的爬虫技术以及如何使用Python的django库。同时对于OpenCV也比较感兴趣，而Python又是那么的方便，人生苦短，我用python。</p><p>首先看一下Python的数据结构：</p><p><strong>tuple 元组：元组是一种固定长度、不可变的Python对象序列.</strong></p><p>最简单的创建方法就是使用逗号分隔序列值，通过复杂的表达式来定义元组时，通常需用括号将值包起来。可以使用tuple函数将任意序列或迭代器转换为元组。元组的元素可以通过operator[]操作符来获取，但是不能修改，也就是说元组一旦创建，各个位置上的对象时无法修改的。如果元组中的对象时可变的，如果元组中有列表对象，那么可以对这个列表对象进行操作，但是不能修改元组的对象。</p><p>看一下如何创建元组以及获取元组某索引的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple1 &#x3D; 1,2,3,4,5,6,7,[]</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [])</span><br><span class="line">&gt;&gt;&gt; tuple2 &#x3D; tuple([8,9,5])</span><br><span class="line">&gt;&gt;&gt; tuple2</span><br><span class="line">(8, 9, 5)</span><br><span class="line">&gt;&gt;&gt; tuple1[2]</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; tuple1[7].append(1)</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [1])</span><br></pre></td></tr></table></figure><p><strong>使用 + 号连接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple1 + tuple2</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [1], 8, 9, 5)</span><br></pre></td></tr></table></figure><p>将元组乘以整数，生成含有多份拷贝的元组，对象自身并没有复制，只是指向它们的引用复制了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple2 * 2</span><br><span class="line">(8, 9, 5, 8, 9, 5)</span><br></pre></td></tr></table></figure><p><strong>元组解包：将元组类型的表达式赋值给变量，Python会对等号右边的值进行拆包。也可以嵌套拆包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t3 &#x3D; (&quot;a&quot;,&quot;b&quot;,(12,&quot;d&quot;))</span><br><span class="line">&gt;&gt;&gt; a,b,(c,d) &#x3D; t3</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#39;d&#39;</span><br></pre></td></tr></table></figure><p>交换两个值的变量，在Python中很方便即如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; a,b &#x3D; b,a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;a&#39;</span><br></pre></td></tr></table></figure><p>python有一种更高级的拆包功能，用于帮助从元组的起始位置采集一些元素，特殊语法是 *variable，用于函数调用时获取任意长度的位置参数列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; values &#x3D; 1,2,3,4,5</span><br><span class="line">&gt;&gt;&gt; a,b,*_ &#x3D; values</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; _</span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure><p>用于元组的其他操作：</p><p>tuple.count(val) ：用于计量某个数值在元组中出现的次数</p><p>comp(tuple1,tuple2) : 比较两个元组</p><p>len(tuple) : 计算元组中元素个数</p><p>max(tuple) : 返回元组中最大值</p><p>min(tuple) : 返回元组中最小值</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前就学过Python,因为许久不用导致Python中的好多知识都忘记了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之list</title>
    <link href="http://example.com/jsblog/1cfd35a1.html"/>
    <id>http://example.com/jsblog/1cfd35a1.html</id>
    <published>2020-12-20T06:05:59.000Z</published>
    <updated>2020-12-20T06:07:44.331Z</updated>
    
    <content type="html"><![CDATA[<p>列表的长度是可变的。<a id="more"></a>其元素也是可以修改的、可以使用[]或者list类型函数来定义列表。</p><p>列表定义操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [1,2,3,4,5,8]</span><br><span class="line">list2 &#x3D; list((1,2,3,4,5))</span><br><span class="line">print(list1)</span><br><span class="line">print(list2)</span><br></pre></td></tr></table></figure><p>list函数在数据处理中常用于将迭代器或生成器转化为列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen &#x3D; range(10)</span><br><span class="line">print(list(gen))</span><br><span class="line">print(gen)</span><br></pre></td></tr></table></figure><p>添加或删除元素；</p><p>list.append(): 添加到尾部</p><p>list.insert(pos，val) : 将val添加到指定位置</p><p>list.pop(pos): 将pos位置的元素移除</p><p>list.remove(val) : 将定义第一个符合要求的值移除</p><p>使用 in 或 not in 判断值是否在list中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list3 &#x3D; list(range(10))</span><br><span class="line">list3.append(&quot;foo&quot;)</span><br><span class="line">list3.insert(1,&quot;lll&quot;)</span><br><span class="line">print(list3)</span><br><span class="line">list3.pop(0)</span><br><span class="line">list3.remove(&quot;foo&quot;)</span><br><span class="line">print(list3)</span><br><span class="line">print( 5 in list3)</span><br><span class="line">print( 10 not in list3)</span><br><span class="line">使用 + 号连接两个list，也可以使用extend方法向列表添加多个元素</span><br><span class="line">list4 &#x3D; [&quot;122&quot;,(1,2)]</span><br><span class="line">print(list4 + list3)</span><br><span class="line">list3.extend(list4)</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure><p>如果通过添加内容连接列表是一种相对代价较高的操作，连接过程中需要创建新表，并且要复制对象。使用extend方法扩展列表是比较好的方式。</p><p>使用sort排序，sort的一些选项可能用的上，其中一个是传递一个二级排序key 用于生成排序值的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [10,5,20,33,12,4,7]</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line">b &#x3D; [&quot;small&quot;,&quot;key&quot;,&quot;values&quot;,&quot;who are you&quot;]</span><br><span class="line">b.sort(key&#x3D;len)</span><br><span class="line">print(b)</span><br><span class="line">b.reverse()</span><br><span class="line">print(b)</span><br><span class="line">print(sorted(b,key&#x3D;len))</span><br></pre></td></tr></table></figure><p>二分查找和已排序列表的维护（必须排好序，否则会出错）</p><p>内建的bisect实现了二分搜索和排序列表的维护，bisect.bisect会找到元素应当插入的位置，而bisect.insort将元素插入相应位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line">a &#x3D; [10,5,20,33,12,4,7]</span><br><span class="line">a.sort()</span><br><span class="line">print(bisect.bisect(a,11))</span><br><span class="line">bisect.insort(a,6)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>切片它的基本形式是将start:stop传入到索引符合[]中，由于不包含stop所以其元素数量为stop-start,如果省略start或者stop则表示从默认传入序列的起始位值或者结束位置。负索引可以从序列的尾部进行索引.也可以指定步进值step，需要在第二个冒号后面使用，表示每隔几个值取一个，当需要对列表或者元组进行翻转时，将step设置为-1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq &#x3D; [7,2,3,7,5,6,0,1,4]</span><br><span class="line">seq[3:4] &#x3D; [8,9]</span><br><span class="line">print(seq)</span><br><span class="line">print(seq[:4])</span><br><span class="line">print(seq[5:])</span><br><span class="line">print(seq[-4:])</span><br><span class="line">print(seq[-6:-2])</span><br><span class="line">print(seq)</span><br><span class="line">print(seq[::2])</span><br><span class="line">print(seq[::-1])</span><br></pre></td></tr></table></figure><p>一些内建函数</p><p>enumerate : 返回(I,value)元组的序列，其中value时元素的值，i表示索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str_list &#x3D; [&quot;foo&quot;,&quot;bar&quot;,&quot;et&quot;]</span><br><span class="line">mapping &#x3D; &#123;&#125;</span><br><span class="line">for i,val in enumerate(str_list):</span><br><span class="line"> mapping[val] &#x3D; i</span><br><span class="line">print(mapping)</span><br></pre></td></tr></table></figure><p>sorted函数，返回一个根据任意序列中的新建的已排序列表</p><p>zip ：将列表、元组或其他序列的元素配对，新建一个元组构成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str_list1 &#x3D; [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</span><br><span class="line">str_list2 &#x3D; [&quot;one&quot;,&#39;two&#39;,&#39;three&#39;]</span><br><span class="line">zipped &#x3D; zip(str_list1,str_list2)</span><br><span class="line">print(list(zipped))</span><br><span class="line">l1,l2&#x3D; zip(*zip(str_list1,str_list2))</span><br><span class="line">print(list(l1))</span><br><span class="line">print(list(l2))</span><br></pre></td></tr></table></figure><p>reversed : 将序列的元素带线排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(reversed(range(10))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;列表的长度是可变的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之Dict</title>
    <link href="http://example.com/jsblog/33b9a021.html"/>
    <id>http://example.com/jsblog/33b9a021.html</id>
    <published>2020-12-20T06:05:18.000Z</published>
    <updated>2020-12-20T06:07:44.329Z</updated>
    
    <content type="html"><![CDATA[<p>dict是python内建数据结构中最重要的。<a id="more"></a>又称哈希表或者关联数组。字典是拥有灵活尺寸的键值对。其中键和值都是Python中的对象。字典的创建方式使用大括号来创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#125;</span><br><span class="line">d1 &#x3D; &#123;&#39;a&#39;:&#39;some value&#39;,&#39;b&#39;:[1,2,3,4]&#125;</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><p>访问，插入以及设置元素的值可以使用operator[]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1[&quot;test&quot;] &#x3D; &quot;hello&quot;</span><br><span class="line">print(d1[&#39;b&#39;])</span><br><span class="line">d1[&#39;b&#39;] &#x3D; [5,6,7,8]</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><p>使用 in 或者 not in 判断一个key是否在字典中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;a&#39; in d1)</span><br><span class="line">print(&#39;a&#39; not in dict1)</span><br></pre></td></tr></table></figure><p>使用 del关键字或者pop函数删除元素，pop函数会返回对应的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del d1[&#39;b&#39;]</span><br><span class="line">print(d1.pop(&#39;a&#39;))</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><p>key函数和values函数会获取字典中键和值的迭代器，使用update函数可以将两个字典合并，在合并的时候如果传入给update函数的字典中包含原来字典的中key并且这个key对应的value发生变化，那么原来的字典中的此key对应的value会更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d2 &#x3D; &#123;&#39;a&#39; : &#39;you&#39;,&#39;b&#39;:&#39;him&#39;,&#39;q&#39;:&#39;qq&#39;&#125;</span><br><span class="line">d1.update(d2)</span><br><span class="line">print(list(d1.keys()))</span><br><span class="line">print(list(d1.values()))</span><br></pre></td></tr></table></figure><p>字典中的get函数和pop函数都可以返回一个默认值，如果key不在字典中，那么get函数会返回一个None,而pop方法则会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value &#x3D; dict1.get(&quot;test&quot;)</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><p>字典的setdefault() 函数和 get()函数 类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值。内建的collections 有一个defaultdict类，这个类可以生成符合要求的字典，可以向字典中出入类型或能在各位置生成默认值的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">words &#x3D; [&#39;apple&#39;,&#39;wood&#39;,&#39;world&#39;,&#39;orange&#39;,&#39;atom&#39;]</span><br><span class="line">by_letter &#x3D; defaultdict(list)</span><br><span class="line">for word in words:</span><br><span class="line"> by_letter[word[0]].append(word)</span><br><span class="line">print(by_letter)</span><br></pre></td></tr></table></figure><p>字典的key的类型必须是不可变的对象，整数、浮点数、字符串或者元组且元组内对象是不可变对象。通过hash函数可以检查一个对象是否可以用作字典的key</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;dict是python内建数据结构中最重要的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之Set</title>
    <link href="http://example.com/jsblog/83d8cb01.html"/>
    <id>http://example.com/jsblog/83d8cb01.html</id>
    <published>2020-12-20T06:04:20.000Z</published>
    <updated>2020-12-20T06:07:44.331Z</updated>
    
    <content type="html"><![CDATA[<p>集合是一种无序且元素唯一的容器。<a id="more"></a>通过set函数或者使用字面值集与大括号的语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(set([1,2,2,3,4,5,9,6,2,2,3]))</span><br><span class="line">print(type(&#123;1,2,3,4&#125;))</span><br></pre></td></tr></table></figure><p>对于集合主要是数学上的集合操作，例如联合，交集，差集，对称差集。</p><p>所谓联合就是求并集使用union函数或者 | 运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#123;1,2,3,4,5,6&#125;</span><br><span class="line">b &#x3D; &#123;3,4,5,6,7,8,9&#125;</span><br><span class="line">print(a | b)</span><br><span class="line">c &#x3D; a.union(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>交集使用 intersection函数或者使用 &amp; 运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c &#x3D; a.intersection(b)</span><br><span class="line">print(c)</span><br><span class="line">print(a &amp; b)</span><br></pre></td></tr></table></figure><p>集合的一些其他函数：</p><table><thead><tr><th>函数</th><th>替代操作符</th><th>含义</th></tr></thead><tbody><tr><td>s.add(val)</td><td>N/A</td><td>将val添加到集合s中</td></tr><tr><td>s.clear()</td><td>N/A</td><td>将集合清空，清空所有元素</td></tr><tr><td>s.remove(x)</td><td>N/A</td><td>从集合s中移除x</td></tr><tr><td>s.pop()</td><td>N/A</td><td>移除元素，如果s为空，抛出keyEror</td></tr><tr><td>s.copy()</td><td>N/A</td><td>拷贝一个集合</td></tr><tr><td>s.disjoint()</td><td>N/A</td><td>如果两个集合包含相同元素返回True</td></tr><tr><td>s.union(s1)</td><td>s | s1</td><td>s和s1的并集</td></tr><tr><td>s.update(s1)</td><td>s |= s1</td><td>将s的内容设置为s和s1的并集</td></tr><tr><td>s.intersection(s1)</td><td>s &amp; s1</td><td>所有在s中并且在s1中的元素</td></tr><tr><td>s.interserction_update(s1)</td><td>s &amp;= s1</td><td>将s的内容设置为在s中且在s1的元素</td></tr><tr><td>s.difference(s1)</td><td>s-s1</td><td>所有在s中不在s1中的元素</td></tr><tr><td>s.difference_update(s1)</td><td>s -= s1</td><td>将s的内容设置为在s中，不在s1中的元素</td></tr><tr><td>s.symmetric_difference(s1)</td><td>s^s1</td><td>在s，s1中但不同时在s,s1中的元素</td></tr><tr><td>s.symmertric_difference_update(s1)</td><td>s^=s1</td><td>将s的内容设置为在s，s1中但不同时在s,s1中</td></tr><tr><td>s.issubset(s1)</td><td>N/A</td><td>如果s包含于s1返回True</td></tr><tr><td>s,issuperset(s1)</td><td>N/A</td><td>如果s 包含s1 返回True</td></tr></tbody></table><p>和字典的key类似，集合的元素必须是不可改变的，要想包含列表型的元素必须转换为元组。当集合中的内容完全一样时，两个集合才相等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;集合是一种无序且元素唯一的容器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之列表推导式</title>
    <link href="http://example.com/jsblog/bc0362ad.html"/>
    <id>http://example.com/jsblog/bc0362ad.html</id>
    <published>2020-12-20T06:02:39.000Z</published>
    <updated>2020-12-20T06:07:44.334Z</updated>
    
    <content type="html"><![CDATA[<p>列表推导式是Python语言的特性之一。<a id="more"></a>列表推导式的基本形式如下：</p><p>[expr for val in collection if condition]</p><p>如果过滤条件省略,只保留表达式的形式如下：</p><p>[expr for val in collection]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strs &#x3D; [&#39;a&#39;,&#39;as&#39;,&#39;apple&#39;,&#39;bat&#39;,&#39;car&#39;,&#39;dove&#39;,&#39;cplusplus&#39;]</span><br><span class="line">up_2 &#x3D; [x.upper() for x in strs if len(x) &gt; 2]</span><br><span class="line">print(up_2)</span><br></pre></td></tr></table></figure><p>集合与字典的推导式是列表对导师的自然拓展，其形式如下：</p><p>dict_comp={key-expr: value-expr for value in collection if condition}</p><p>set_comp = {expr for value in collection if condition}</p><p>和列表推导式类似，集合，字典的推导式非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_len &#x3D; &#123;len(s) for s in strs&#125;</span><br><span class="line">loc_mapping &#x3D; &#123;key : index for index,key in enumerate(strs)&#125;</span><br><span class="line">print(loc_mapping)</span><br><span class="line">print(set(map(len,strs)))</span><br><span class="line">print(unique_len)</span><br></pre></td></tr></table></figure><p>列表推导式也是可以嵌套使用的，要牢记for表达式的顺序应当和你写嵌套for循环来代替列表推导式的顺序一致。嵌套列表推导式和列表推导式中的列表推导式不一样。</p><p>嵌套列表推导式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuples &#x3D; [(1,2,3),(4,5,6),(7,8,9)]</span><br><span class="line">flattend &#x3D; [x for tup in tuples for x in tup]</span><br><span class="line">print(flattend)</span><br></pre></td></tr></table></figure><p>列表推导式中的列表推导式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dim2 &#x3D; [[x for x in tup ] for tup in tuples]</span><br><span class="line">print(dim2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;列表推导式是Python语言的特性之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之字符串</title>
    <link href="http://example.com/jsblog/35b35764.html"/>
    <id>http://example.com/jsblog/35b35764.html</id>
    <published>2020-12-20T06:02:02.000Z</published>
    <updated>2020-12-20T06:07:44.335Z</updated>
    
    <content type="html"><![CDATA[<p>字符串是 Python 中最常用的数据类型。<a id="more"></a>我们可以使用引号( ‘ 或 “ 或’’’str’’’)来创建字符串。Python中的注释可以使用#comment</p><p>创建字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 &#x3D; &#39;hello world&#39;</span><br><span class="line">str2 &#x3D; &quot;comment&quot; #hhh</span><br><span class="line">str3 &#x3D;&#39;&#39;&#39;1222333&#39;&#39;&#39;</span><br><span class="line">print(str3)</span><br></pre></td></tr></table></figure><p>切片操作，和list类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(str1[:5])</span><br><span class="line">print(str1[5:])</span><br><span class="line">print(str1[-6:-2])</span><br><span class="line">print(str1[::2])</span><br><span class="line">print(str1[::-1])</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#update str</span><br><span class="line">str4 &#x3D; str1[:6]+&quot;roobu&quot;</span><br><span class="line">print(str4)</span><br></pre></td></tr></table></figure><p>字符串的拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str5 &#x3D; &#39;hello&#39; &quot;world&quot;</span><br><span class="line">print(str4+str5)</span><br><span class="line">print(str5)</span><br></pre></td></tr></table></figure><p>str的一些函数如下：</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td>capitalize()</td><td>将字符串的第一个字符转换为大写</td></tr><tr><td>lower()</td><td>转换字符串中所有大写为小写</td></tr><tr><td>upper()</td><td>转换字符串中所有小写为大写</td></tr><tr><td>casefold()</td><td>转换字符串中所有大写为小写</td></tr><tr><td>swapcase()</td><td>对字符串的大小写字母进行转换</td></tr><tr><td>title()</td><td>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td>strip()</td><td>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td>rstrip()</td><td>删除字符串字符串末尾的空格.</td></tr><tr><td>lstrip()</td><td>截掉字符串左边的空格或指定字符。</td></tr><tr><td>replace(old,new,[,max])</td><td>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td>maketrans(x, y=None, z=None, /)</td><td>此静态方法返回一个可供 str.translate( ) 使用的转换对照表。</td></tr><tr><td>translate(table)</td><td>translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符,要过滤掉的字符放到 deletechars 参数中。</td></tr><tr><td>center(width[, fillchar])</td><td>一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td>ljust(width[, fillchar])</td><td>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td>rjust(width[, fillchar])</td><td>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td>zfill(width)</td><td>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td>count(sub[, start[, end]])</td><td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>encode(encoding=’utf-8’,errors=’strict’)</td><td>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td>endswith(suffix[, start[, end]])</td><td>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td>expandtabs(tabsize=8)</td><td>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8</td></tr><tr><td>splitlines([keepends])</td><td>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符</td></tr><tr><td>split(sep=None, maxsplit=-1)</td><td>指定分隔符对字符串进行切片，如果第二个参数 maxsplit 有指定值，则分割为 maxsplit +1 个子字符串。</td></tr><tr><td>rsplit(sep=None, maxsplit=-1)</td><td>除了从右边开始拆分，rsplit( ) 的其他行为都类似于 split( )</td></tr><tr><td>rpartition(sep)</td><td>方法类似于 partition()方法，只是该方法是从目标字符串的末尾也就是右边开始搜索分割符</td></tr><tr><td>rindex(sub[, start[, end]])</td><td>类似于 index()，不过是从右边开始.</td></tr><tr><td>rfind(sub[, start[, end]])</td><td>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td>partition(sep)</td><td>如果字符串包含指定的分隔符，则返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串</td></tr><tr><td>isupper()</td><td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td>istitle()</td><td>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td>isspace()</td><td>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td>isprintable()</td><td>是否为可打印字符</td></tr><tr><td>isnumeric()</td><td>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td>islower()</td><td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td>isidentifier()</td><td>判断字符串是否是有效的 Python 标识符，即可用此方法来判断变量名是否合法</td></tr><tr><td>isdigit()</td><td>如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td>isdecimal()</td><td>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr><tr><td>isalpha()</td><td>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td>isalnum()</td><td>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td>index(sub[, start[, end]])</td><td>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td>format_map(mapping)</td><td>该方法类似于 str.format(**mapping) 都可以进行字符串格式化，不同之处在于 format( ) 方法是一种所有情况都能使用的格式化方法，而 str.format_map(mapping) 方法仅适用于字符串格式中可变数据参数来源于字典等映射关系数据时。mapping 会被直接使用而不是复制到一个 dict</td></tr><tr><td>format(*args, **kwargs)</td><td>格式化字符串</td></tr><tr><td>join(seq)</td><td>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td>find(sub[, start[, end]])</td><td>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr></tbody></table><p>str的格式化：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ascii码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整数</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号16进制数</td></tr><tr><td>%X</td><td>格式化无符号16进制数大写</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f 和 %e的简写</td></tr><tr><td>%G</td><td>%f和%E的简写</td></tr><tr><td>%p</td><td>用16进制格式化变量的地址</td></tr></tbody></table><p>一些其他的辅助：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>在正数面前显示加号 +</td></tr><tr><td><sp></sp></td><td>在正数面前显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示数字前面填充0而不是空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>f-string 是字面量格式化字符串，新的格式化字符串语法，f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f&#39;&#123;1+2&#125;&#39;)</span><br></pre></td></tr></table></figure><p>当然还有一些的转义字符如下：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>\ （在行尾）</td><td>续行符</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\’’</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\yyy</td><td>八进制，y代表0-7</td></tr><tr><td>\xyy</td><td>16进制以\x开头，y代表字符</td></tr><tr><td>\other</td><td>其他字符以普通格式输出</td></tr></tbody></table><p>还有一些与字符串有有个的函数：</p><p>ord() :它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</p><p>chr():用一个整数作参数，返回一个对应的字符。</p><p>max(str)/min(str) : 返回str中最大或者最小的字母</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;字符串是 Python 中最常用的数据类型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之函数</title>
    <link href="http://example.com/jsblog/a17f435f.html"/>
    <id>http://example.com/jsblog/a17f435f.html</id>
    <published>2020-12-20T06:01:14.000Z</published>
    <updated>2020-12-20T06:07:44.332Z</updated>
    
    <content type="html"><![CDATA[<p>Python中函数使用def定义的函数还有就是lambda 定义的函数。<a id="more"></a></p><p>使用def关键字声明的函数，返回使用return关键字，如果到达函数仍然没有遇到return语句，就会自动返回None.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; None</span><br><span class="line">def bind_var():</span><br><span class="line"> a &#x3D; []</span><br><span class="line"> for i in range(5):</span><br><span class="line"> a.append(i)</span><br><span class="line">print(a)</span><br><span class="line">print(bind_var())</span><br></pre></td></tr></table></figure><p>函数有两种连接变量的方式：全局变量，本地变量。在使用全局变量的时候，在使用关键字global表示这个变量是个全局变量，如果不使用global会被默认为本地变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; None</span><br><span class="line">def bind_vvar():</span><br><span class="line"> global a</span><br><span class="line"> a &#x3D; []</span><br><span class="line">bind_vvar()</span><br></pre></td></tr></table></figure><p>print(a)在python可以返回多个值，也就是相当于一个元组，在C++中有tuple的类型，可供来返回多个值，而在python中我们可以直接返回多个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f():</span><br><span class="line"> a &#x3D; 5</span><br><span class="line"> b &#x3D; 7;c&#x3D;8</span><br><span class="line"> return a,b,c</span><br><span class="line">a,b,c &#x3D; f()</span><br><span class="line">print(a,b,c)</span><br></pre></td></tr></table></figure><p>在Python中每一个函数都是一个对象，可以将函数作为一个参数传递到其他的函数中，相当于一种回调的使用。lambda是一种匿名函数，在c++中也有lambda函数，在Python定义匿名函数可以直接使用lambda关键字。匿名函数没有一个显示的__name__属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exp_val &#x3D; lambda x : x*x</span><br><span class="line">print(exp_val(10))</span><br></pre></td></tr></table></figure><p>了解到一个新的词语，柯里化函数：部分参数应用，它是通过部分参数应用的方式从已有的函数产生新的函数，内建的functools可以使用pratial函数简化处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">def add_numbers(x,y):</span><br><span class="line"> return x+y</span><br><span class="line">add_five &#x3D; partial(add_numbers,5)</span><br><span class="line">print(add_five(10))</span><br></pre></td></tr></table></figure><p>这与C++ 的bind函数很像，可以对函数使用占位符并确定某些位置的参数，形成一个新的函数对象。Python中通过一致的方式遍历序列这也就是迭代器模式。迭代器在Python中是一种用在上下文中向Python解释器生成对象的对象。生成器是构造新的可遍历序列的一种简洁的方式，如果需要创建生成器需要使用yield关键字，即将return换成yield关键字即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def squares(n &#x3D; 10):</span><br><span class="line"> for i in range(1,n+1):</span><br><span class="line"> yield i**2</span><br><span class="line">gen &#x3D; squares()</span><br><span class="line">print(gen)</span><br><span class="line">print(list(gen))</span><br></pre></td></tr></table></figure><p>生成器表达式可以很方便的创建生成器，生成器表达式与列表的推导式很相似，只需要将列表推导式的中括号换成小括号就行。生成器表达式也可以代替列表推导式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gen &#x3D; (x**2 for x in range(1,11))</span><br><span class="line">print(gen)</span><br><span class="line">print(list(gen))</span><br><span class="line">mapping &#x3D; dict((x,x**2) for x in range(1,11))</span><br><span class="line">print(mapping)</span><br></pre></td></tr></table></figure><p>itertools模块是适用于大多数数据集合算法的生成器，可以查看相应的文档来学习</p><p>错误和异常处理使用try/except捕获和处理异常</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python中函数使用def定义的函数还有就是lambda 定义的函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之文件操作</title>
    <link href="http://example.com/jsblog/31f3b408.html"/>
    <id>http://example.com/jsblog/31f3b408.html</id>
    <published>2020-12-20T06:00:34.000Z</published>
    <updated>2020-12-20T06:07:44.335Z</updated>
    
    <content type="html"><![CDATA[<p>打开文件进行读取和写入，需要使用内建函数open和绝对或者相对路径。<a id="more"></a>在默认情况下文件是以制度模式‘r’打开。之后可以像列表一样处理文本文件。当处理完成时一定要使用close函数将文件关闭，也可以使用with语句，文件会在with代码块结束的时候自动关闭。</p><p>首先来看一下python中的文件打开模式：</p><table><thead><tr><th>mode</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>只打开文件,该文件必须存在</td></tr><tr><td>r+</td><td>打开可读可写的文件，该文件必须存在</td></tr><tr><td>w</td><td>若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td></tr><tr><td>w+</td><td>打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td></tr><tr><td>a</td><td>以附加方式打开只写文件，若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾部，原先的内容会被保留</td></tr><tr><td>a+</td><td>以附加方式打开可读可写文件，若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾部，原先的内容会被保留</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果文件存在会报错</td></tr><tr><td>rb</td><td>二进制只读文件，,该文件必须存在</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>wb</td><td>二进制只写文件，若文件不存在，新建一个文件，文件若存在，文件内容清空</td></tr><tr><td>wb+</td><td>二进制可读可写文件，若文件不存在，新建一个文件，文件若存在，文件内容清空</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>t</td><td>文件的文本模式</td></tr></tbody></table><p>示例如下：</p><p>f = open(“dicts.ipynb”)</p><p>for line in f:</p><p>print(line)</p><p>f.close()</p><p>对于可读文件，最常用的时read,seek，tell函数，read返回文件中一定量的字符，read函数通过读取的字节数推进文件句柄的位置，tell函数返回文件句柄的位置，seek函数将文件句柄定位到文件中特定的字符，写入文件可以使用write函数或者writeline函数。readlines([size])函数返回文件的行内容列表。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打开文件进行读取和写入，需要使用内建函数open和绝对或者相对路径。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之面向对象</title>
    <link href="http://example.com/jsblog/1084bb5e.html"/>
    <id>http://example.com/jsblog/1084bb5e.html</id>
    <published>2020-12-20T05:59:38.000Z</published>
    <updated>2020-12-20T06:07:44.336Z</updated>
    
    <content type="html"><![CDATA[<p>涉及到类的时候就要谈到面向对象编程。而面向对象编程是最有效的软件编写方法之一。<a id="more"></a>也是一种编程范式。在面向对象编程中，编写表示现实世界中的事物和情景中的类，并基于这些类来创建对象。在编写类的时候的主要是涉及到抽象的操作，要把对象所共有的属性以及可以做的操作提取出来，然后形成一个类。在使用的时候根据列来创建对象也就是实例化对象。了解了类背后的概念可培养逻辑思维，让你能够通过编写程序来结局遇到的问题。</p><p>在创建类的时候需要用到一个关键词class,接下来使用类模拟一下dog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#模拟小狗</span><br><span class="line">class Dog():</span><br><span class="line"> def __init__(self,name,age):</span><br><span class="line"> #初始化属性</span><br><span class="line"> self.name &#x3D; name</span><br><span class="line"> self.age &#x3D; age</span><br><span class="line"> def sit(self):</span><br><span class="line"> print(self.name.title() + &quot; is now setting&quot;)</span><br><span class="line"> def get_age(self):</span><br><span class="line"> return self.age</span><br><span class="line"> def get_name(self):</span><br><span class="line"> return self.name</span><br><span class="line"> </span><br><span class="line">dog &#x3D; Dog(&quot;Jack&quot;,5)</span><br><span class="line">dog.sit()</span><br></pre></td></tr></table></figure><p>其中 <strong>init</strong>()是一个特殊的函数，成为构造函数。当你使用类创建一个对象时，需要调用<strong>init</strong>()函数用来初始化对象。定义变量的时候都有个self变量，这个self相当于this指针，表示该类中的变量，使用self表示函数属于这个类。对于创建的属性，可以直接使用“.”操作符访问。</p><p>print(dog.name)</p><p>print(dog.age)</p><p>在Python中编写类时，不一定要从空白开始。也就是可以使用继承。原有到的类称为基类，新类称为子类。子类继承了基类的方法和属性，同时还可以定义自己的方法和属性也可以重载父类的函数。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Little_Dog(Dog):</span><br><span class="line"> #定义属性，包含高，name,age</span><br><span class="line"> def __init__(self,name&#x3D;&#39;little&#39;,age&#x3D;2,height&#x3D; 10):</span><br><span class="line"> #使用super初始化基类</span><br><span class="line"> super().__init__(name,age)</span><br><span class="line"> self.h &#x3D; height</span><br><span class="line"> </span><br><span class="line"> def get_height(self):</span><br><span class="line"> return self.h</span><br><span class="line">little &#x3D; Little_Dog()</span><br><span class="line">print(little.get_age())</span><br></pre></td></tr></table></figure><p>其中super()表示调用基类的构造函数。在Python中没有访问控制权限，但是可以使用 “__”双下划线表示该属性或者函数为私有变量或者私有函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;涉及到类的时候就要谈到面向对象编程。而面向对象编程是最有效的软件编写方法之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>自定义直方图</title>
    <link href="http://example.com/jsblog/eaa37956.html"/>
    <id>http://example.com/jsblog/eaa37956.html</id>
    <published>2020-12-20T05:56:57.000Z</published>
    <updated>2020-12-20T05:57:38.492Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的应用场景中，我们可以根据需求 调整计算的直方图区间。<a id="more"></a>针对灰度直方图，我们可以将区间[0,255]分成不同的区间范围，然后分别统计各个区间的灰度分布，进而实现自定义的直方图：</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">&quot;E:/CodeBlocks/data/lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换为灰度图像</span></span><br><span class="line">    cv::Mat grayImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//设置计算直方图的参数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> channles[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> histSize[<span class="number">1</span>] = &#123;<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> range[] = &#123;<span class="number">0</span>,<span class="number">40</span>,<span class="number">80</span>,<span class="number">120</span>,<span class="number">160</span>,<span class="number">200</span>,<span class="number">220</span>,<span class="number">255</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> *ranges[<span class="number">1</span>] = &#123;range&#125;;</span><br><span class="line">    cv::MatND hist;</span><br><span class="line">    cv::calcHist(&amp;grayImage,<span class="number">1</span>,channles,cv::Mat(),hist,<span class="number">1</span>,histSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//求直方图中得最大值</span></span><br><span class="line">    <span class="keyword">double</span> maxVal = <span class="number">0.0</span>;</span><br><span class="line">    cv::minMaxLoc(hist,<span class="number">0</span>,&amp;maxVal,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置直方图绘图参数</span></span><br><span class="line">    <span class="keyword">int</span> Hist_size = hist.rows;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">histImage</span><span class="params">(Hist_size,Hist_size,CV_8U,cv::Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; Hist_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> binVal = hist.at&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="comment">//归一化</span></span><br><span class="line">        <span class="keyword">int</span> intensity = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(binVal * Hist_size / maxVal);</span><br><span class="line">        <span class="comment">//绘制直方图信息</span></span><br><span class="line">        cv::line(histImage,cv::Point(i,Hist_size),cv::Point(i,Hist_size-intensity),cv::Scalar::all(<span class="number">0</span>),<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;gray&quot;</span>,grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;hist&quot;</span>,histImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实际的应用场景中，我们可以根据需求 调整计算的直方图区间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>H-S直方图</title>
    <link href="http://example.com/jsblog/457223e2.html"/>
    <id>http://example.com/jsblog/457223e2.html</id>
    <published>2020-12-20T05:56:16.000Z</published>
    <updated>2020-12-20T05:57:38.485Z</updated>
    
    <content type="html"><![CDATA[<p>为了描述图像的特性，常常需要分析HSV色彩空间下的直方图。<a id="more"></a></p><p>要分析HSV色彩空间下的直方图，首先要将图像转换到HSV色彩空间中，然后将对应的H通道和S通道进行单元划分，最后在二维图像 上生成直方图。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat hsvImage;</span><br><span class="line">    cv::cvtColor(srcImage,hsvImage,cv::COLOR_BGR2HSV);</span><br><span class="line">    <span class="comment">//直方图参数</span></span><br><span class="line">    <span class="keyword">int</span> hbins = <span class="number">30</span>,sbins = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> histSize[] = &#123;hbins,sbins&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> channels[] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> hranges[] = &#123;<span class="number">0</span>,<span class="number">180</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> sranges[] = &#123;<span class="number">0</span>,<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>  *ranges[] = &#123;hranges,sranges&#125;;</span><br><span class="line">    cv::MatND hist;</span><br><span class="line">    cv::calcHist(&amp;hsvImage,<span class="number">1</span>,channels,cv::Mat(),hist,<span class="number">2</span>,histSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//找到直方图中得最大值</span></span><br><span class="line">    <span class="keyword">double</span> maxVal = <span class="number">0.0</span>;</span><br><span class="line">    cv::minMaxLoc(hist,<span class="number">0</span>,&amp;maxVal,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> scale = <span class="number">10</span>;</span><br><span class="line">    cv::Mat histImage = cv::Mat::zeros(sbins*scale,hbins * scale,CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; hbins;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; sbins;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> binValue = hist.at&lt;<span class="keyword">float</span>&gt;(i,j);</span><br><span class="line">            <span class="keyword">int</span> intensity = cvRound(binValue*<span class="number">255</span> / maxVal);</span><br><span class="line">            cv::rectangle(histImage,cv::Point(i*scale,j*scale),</span><br><span class="line">                          cv::Point((i+<span class="number">1</span>)*scale<span class="number">-1</span>,(j+<span class="number">1</span>)*scale<span class="number">-1</span>),cv::Scalar::all(intensity),<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::imshow(<span class="string">&quot;H-S HIst&quot;</span>,histImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了描述图像的特性，常常需要分析HSV色彩空间下的直方图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>双阈值</title>
    <link href="http://example.com/jsblog/fda80a12.html"/>
    <id>http://example.com/jsblog/fda80a12.html</id>
    <published>2020-12-20T05:54:56.000Z</published>
    <updated>2020-12-20T05:57:38.491Z</updated>
    
    <content type="html"><![CDATA[<p>对于图像具有明显的双分界特征，可以使用双阈值法进行二值化操作。<a id="more"></a>根据双阈值化操作方法，对8bit灰度图像使用该方法进行操作时，需要预先设定好阈值量thresh1,thresh2,且thresh1&lt;thresh2,在thresh1到thresh2范围内的像素都被设置为maxval，其他均为0，即下面表达式：</p><p><img src="https://pic2.zhimg.com/80/v2-e75e8b8fdc12a0d6264f843dd4cde009_720w.jpg" alt="img"></p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat gray;</span><br><span class="line">    cv::cvtColor(srcImage,gray,cv::COLOR_BGR2GRAY);</span><br><span class="line">    <span class="keyword">double</span> thresh1 = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">double</span> thresh2 = <span class="number">220</span>;</span><br><span class="line">    <span class="keyword">double</span> maxval = <span class="number">255</span>;</span><br><span class="line">    cv::Mat dstImage,dstImage1,dstImage2;</span><br><span class="line"></span><br><span class="line">    cv::threshold(gray,dstImage1,thresh1,maxval,cv::THRESH_BINARY);</span><br><span class="line">    cv::threshold(gray,dstImage,thresh2,maxval,cv::THRESH_BINARY_INV);</span><br><span class="line"></span><br><span class="line">    cv::bitwise_and(dstImage1,dstImage,dstImage2);</span><br><span class="line">    cv::imshow(<span class="string">&quot;dstImage&quot;</span>,dstImage2);</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于图像具有明显的双分界特征，可以使用双阈值法进行二值化操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Adaptivethreshold</title>
    <link href="http://example.com/jsblog/c499a73.html"/>
    <id>http://example.com/jsblog/c499a73.html</id>
    <published>2020-12-20T05:54:15.000Z</published>
    <updated>2020-12-20T05:57:38.484Z</updated>
    
    <content type="html"><![CDATA[<p>对于阈值的设置我们很难确定，通过固定阈值很难将目标区域和背景区域分隔开来。<a id="more"></a>在实际使用中，通常是使用自适应阈值来完成目标的分隔。自适应阈值对于图像块中明亮变化明显的区域通常设置的会过大或者过小，进而保证图像中各个像素的阈值会随着周围邻域块的变化而变化。</p><p>OpenCV提供了adaptiveThreshold函数，该函数有两种自适应参数代表阈值计算方法，函数接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::adaptiveThreshold</span><span class="params">(InputArray src,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OutputArray dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">double</span> maxValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> adaptiveMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> thresholdType,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> blockSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">double</span> C)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>src : 输入的图像（单通道8位图像）</p><p>dst : 表示输出图像（尺寸和类型和输入图像一样）</p><p>maxval : 表示预设最大值</p><p>adaptiveMethod: 计算阈值的算法有两种ADAPTIVE_THRESH_MEAN_C或者ADAPTIVE_THRESH_GUASSIAN_C</p><p>thresholdType: 阈值类型只有两种THRESH_BINARY 或者THRESH_BINARY_INV</p><p>blockSize: 表示邻域大小</p><p>C: 从均值或加权均值提取的数，可以是负数</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">void</span> *userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    cv::Mat grayImage = *(cv::Mat*)userdata;</span><br><span class="line">    cv::adaptiveThreshold(grayImage,dstImage,<span class="number">255</span>,pos,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;gray&quot;</span>,dstImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot; fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat grayImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::namedWindow(<span class="string">&quot;gray&quot;</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;gray&quot;</span>,grayImage);</span><br><span class="line">    cv::createTrackbar(<span class="string">&quot;threshold&quot;</span>,<span class="string">&quot;gray&quot;</span>,<span class="number">0</span>,<span class="number">1</span>,onChange,(<span class="keyword">void</span>*)&amp;grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于阈值的设置我们很难确定，通过固定阈值很难将目标区域和背景区域分隔开来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>threshold</title>
    <link href="http://example.com/jsblog/eb7a2a96.html"/>
    <id>http://example.com/jsblog/eb7a2a96.html</id>
    <published>2020-12-20T05:53:10.000Z</published>
    <updated>2020-12-20T05:57:38.489Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV中提供了阈值化函数threshold<a id="more"></a>该函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">threshold</span><span class="params">(InputArray src,</span></span></span><br><span class="line"><span class="function"><span class="params">                 OutputArray dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> thresh,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> maxval,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>src ： 表示输入图像</p><p>dst : 表示输出图像（尺寸和类型和输入图像一样）</p><p>thresh : 表示阈值</p><p>maxval : 表示预设最大值</p><p>type : 表示阈值化处理的类型设置（type类型有一下几种）</p><p><img src="https://pic1.zhimg.com/80/v2-660d436908c34ba1b0f3d1cdd1fbf518_720w.jpg" alt="img"></p><p>其枚举值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ThresholdTypes &#123;</span><br><span class="line">    THRESH_BINARY     = <span class="number">0</span>,</span><br><span class="line">    THRESH_BINARY_INV = <span class="number">1</span>, </span><br><span class="line">    THRESH_TRUNC      = <span class="number">2</span>, </span><br><span class="line">    THRESH_TOZERO     = <span class="number">3</span>, </span><br><span class="line">    THRESH_TOZERO_INV = <span class="number">4</span>, </span><br><span class="line">    THRESH_MASK       = <span class="number">7</span>,</span><br><span class="line">    THRESH_OTSU       = <span class="number">8</span>, <span class="comment">//!&lt; flag, use Otsu algorithm to choose the optimal threshold value</span></span><br><span class="line">    THRESH_TRIANGLE   = <span class="number">16</span> <span class="comment">//!&lt; flag, use Triangle algorithm to choose the optimal threshold value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">void</span> *userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    cv::Mat grayImage = *(cv::Mat*)userdata;</span><br><span class="line">    cv::threshold(grayImage,dstImage,<span class="number">130</span>,<span class="number">255</span>,pos);</span><br><span class="line">    cv::imshow(<span class="string">&quot;gray&quot;</span>,dstImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot; fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat grayImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::namedWindow(<span class="string">&quot;gray&quot;</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;gray&quot;</span>,grayImage);</span><br><span class="line">    cv::createTrackbar(<span class="string">&quot;threshold&quot;</span>,<span class="string">&quot;gray&quot;</span>,<span class="number">0</span>,<span class="number">4</span>,onChange,(<span class="keyword">void</span>*)&amp;grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenCV中提供了阈值化函数threshold&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV之阈值化</title>
    <link href="http://example.com/jsblog/16be6c4d.html"/>
    <id>http://example.com/jsblog/16be6c4d.html</id>
    <published>2020-12-20T05:51:50.000Z</published>
    <updated>2020-12-20T05:57:38.486Z</updated>
    
    <content type="html"><![CDATA[<p>图像的与阈值化操作就是利用图像像素点分布规律，设定阈值进行像素点分割，进而得到图像的二值化图像。<a id="more"></a></p><p>在阈值化处理中，最常用的算法就是OTSU，OTSU是一种寻找图像阈值的最大类间方差算法。算法步骤如下：</p><p>（1） 统计灰度级每个像素在整个图像中的数量</p><p>（2） 计算每个像素在整个图像中得概率分布</p><p>（3） 对灰度级进行遍历搜索，计算当前灰度值下前景背景类间概率</p><p>（4） 通过目标函数计算类内与类间下对应的阈值</p><p>从255个灰度级遍历t，使得t为某个值的时候，前景和背景的方差最大， 则 这个 t 值便是我们要求得的阈值。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OTSU</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; inputImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = inputImage.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = inputImage.cols;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计每个像素</span></span><br><span class="line">    <span class="keyword">int</span> nPixels[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> nProdis[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nPixels[i] = <span class="number">0</span>;</span><br><span class="line">        nProdis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            nPixels[(<span class="keyword">int</span>)inputImage.at&lt;uchar&gt;(j,i)] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算概率分布</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nProdis[i] = (<span class="keyword">float</span>) nPixels[i] / (rows * cols);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历灰度级，找出类内类间最大方差</span></span><br><span class="line">    <span class="keyword">float</span> delta_temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> delta_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> w0,w1,u0,u1,u0_temp,u1_temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w0 = <span class="number">0</span>; w1 =<span class="number">0</span>;u0=<span class="number">0</span>;u1=<span class="number">0</span>;u0_temp = <span class="number">0</span>;u1_temp=<span class="number">0</span>;delta_temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  j=<span class="number">0</span>;j &lt; <span class="number">256</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                w0 += nProdis[j];</span><br><span class="line">                u0_temp += j*nProdis[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                w1 += nProdis[j];</span><br><span class="line">                u1_temp += j* nProdis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算平均灰度</span></span><br><span class="line">        u0 = u0_temp / w0;</span><br><span class="line">        u1 = u1_temp / w1;</span><br><span class="line">        delta_temp = (<span class="keyword">float</span>)(w0 * w1*<span class="built_in">pow</span>((u0-u1),<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (delta_temp &gt; delta_max)</span><br><span class="line">        &#123;</span><br><span class="line">            delta_max = delta_temp;</span><br><span class="line">            threshold = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat grayImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    <span class="keyword">int</span> threshold = OTSU(grayImage);</span><br><span class="line">    cv::Mat otsuImage = cv::Mat::zeros(grayImage.size(),CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; grayImage.rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grayImage.cols;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grayImage.at&lt;uchar&gt;(j,i) &gt; threshold)</span><br><span class="line">                otsuImage.at&lt;uchar&gt;(j,i) = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;gray&quot;</span>,grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;otsu&quot;</span>,otsuImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像的与阈值化操作就是利用图像像素点分布规律，设定阈值进行像素点分割，进而得到图像的二值化图像。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>反色处理</title>
    <link href="http://example.com/jsblog/5e53ead5.html"/>
    <id>http://example.com/jsblog/5e53ead5.html</id>
    <published>2020-12-20T05:51:18.000Z</published>
    <updated>2020-12-20T05:57:38.491Z</updated>
    
    <content type="html"><![CDATA[<p>对于3通道彩色图像，在处理二值化图像的时候需要进行反色处理。<a id="more"></a>反色处理主要对每个彩色分量取反例如在RGB三彩色情况下是使用255减去原先的彩色分量。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">abs</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InverseColor</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; srcImage,cv::Mat&amp; dstImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    srcImage : the source picture</span></span><br><span class="line"><span class="comment">    dstImage : the destination picture</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    uchar table[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">        table[i] = <span class="number">255</span> -i;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">lookTable</span><span class="params">(<span class="number">1</span>,<span class="number">256</span>,CV_8U)</span></span>;</span><br><span class="line">    uchar* pdata = lookTable.data;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">        pdata[i] = table[i];</span><br><span class="line"></span><br><span class="line">    cv::LUT(srcImage,lookTable,dstImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    InverseColor(srcImage,dstImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;dstImage&quot;</span>,dstImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于3通道彩色图像，在处理二值化图像的时候需要进行反色处理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>ROI</title>
    <link href="http://example.com/jsblog/e8988932.html"/>
    <id>http://example.com/jsblog/e8988932.html</id>
    <published>2020-12-20T05:50:28.000Z</published>
    <updated>2020-12-20T05:57:38.488Z</updated>
    
    <content type="html"><![CDATA[<p>ROI(region of interest)也就是感兴趣区域。<a id="more"></a>也就是图像的一部分。OpenCV使用rect可以提取出来图像的ROI。当然也可以利用鼠标左右键选择自己感兴趣的区域。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">abs</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line">cv::Point startPoint;</span><br><span class="line">cv::Point endPoint;</span><br><span class="line"><span class="keyword">bool</span> downFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> upFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRoi</span><span class="params">(<span class="keyword">int</span> event,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flags,<span class="keyword">void</span>* userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = *(cv::Mat*)userdata;</span><br><span class="line">    <span class="keyword">if</span> (event == CV_EVENT_LBUTTONDOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        downFlag = <span class="literal">true</span>;</span><br><span class="line">        startPoint.x = x;</span><br><span class="line">        startPoint.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == CV_EVENT_LBUTTONUP)</span><br><span class="line">    &#123;</span><br><span class="line">        upFlag = <span class="literal">true</span>;</span><br><span class="line">        endPoint.x = x;</span><br><span class="line">        endPoint.y = y;</span><br><span class="line">        cv::Mat tempImage = srcImage.clone();</span><br><span class="line">         cv::rectangle(tempImage,startPoint,endPoint,cv::Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>,cv::LINE_8,<span class="number">0</span>);</span><br><span class="line">         cv::imshow(<span class="string">&quot;srcImage&quot;</span>,tempImage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downFlag &amp;&amp; upFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Rect rect;</span><br><span class="line">        rect.width = <span class="built_in">abs</span>(startPoint.x - endPoint.x);</span><br><span class="line">        rect.height = <span class="built_in">abs</span>(startPoint.y - endPoint.y);</span><br><span class="line">        rect.x = min(startPoint.x,endPoint.x);</span><br><span class="line">        rect.y = min(startPoint.y,startPoint.y);</span><br><span class="line"></span><br><span class="line">        <span class="function">cv::Mat <span class="title">roiImage</span><span class="params">(srcImage,rect)</span></span>;</span><br><span class="line"></span><br><span class="line">        cv::imshow(<span class="string">&quot;Roi&quot;</span>,roiImage);</span><br><span class="line">        downFlag = <span class="literal">false</span>;</span><br><span class="line">        upFlag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::namedWindow(<span class="string">&quot;srcImage&quot;</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::setMouseCallback(<span class="string">&quot;srcImage&quot;</span>,SetRoi,(<span class="keyword">void</span>*)&amp;srcImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;ROI(region of interest)也就是感兴趣区域。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>trackbar</title>
    <link href="http://example.com/jsblog/4e6c75d9.html"/>
    <id>http://example.com/jsblog/4e6c75d9.html</id>
    <published>2020-12-20T05:49:32.000Z</published>
    <updated>2020-12-20T05:57:38.490Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV中的滑块事件。<a id="more"></a>创建Trackbar的函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cv::createTrackbar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;  trackbarname,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">string</span>&amp;  winname,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span>            *vale,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span>             count,</span></span></span><br><span class="line"><span class="function"><span class="params">                       TrackbarCallback onChange = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span>             *userdata=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>trackbarname : 滑动条名称</p><p>winname :窗口名称</p><p>value : 可选参数表示滑块创建时滑块所在滑动条的位置</p><p>count : 滑动条的最大位置，最小位置是0</p><p>onChange : 滑块位置变化时所调用的回调参数</p><p>userdata : 传递给回调函数的可选参数</p><p>TrackBarCallBack 回调函数：</p><p>typedef void(* cv::TrackbarCallback) (int pos, void *userdata)</p><p>参数说明：</p><p>pos : 当前滑块的位置</p><p>userdata : 可选的输入参数</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrackBarCallback</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">void</span> *userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat gray = *(cv::Mat *)userdata;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    cv::threshold(gray,dstImage,pos,<span class="number">255</span>,cv::THRESH_BINARY); <span class="comment">//二值化处理</span></span><br><span class="line">    cv::imshow(<span class="string">&quot;threshold&quot;</span>,dstImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat gray;</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::cvtColor(srcImage,gray,cv::COLOR_BGR2GRAY);</span><br><span class="line">   cv::namedWindow(<span class="string">&quot;threshold&quot;</span>);</span><br><span class="line">   cv::imshow(<span class="string">&quot;threshold&quot;</span>,gray);</span><br><span class="line">    cv::createTrackbar(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;threshold&quot;</span>,<span class="number">0</span>,<span class="number">255</span>,TrackBarCallback,(<span class="keyword">void</span>*)&amp;gray); <span class="comment">//创建滑块</span></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenCV中的滑块事件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
