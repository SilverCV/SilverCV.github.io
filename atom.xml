<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林森</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-21T12:33:02.881Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发问题</title>
    <link href="http://example.com/jsblog/84c7d6fb.html"/>
    <id>http://example.com/jsblog/84c7d6fb.html</id>
    <published>2020-12-21T11:38:24.000Z</published>
    <updated>2020-12-21T12:33:02.881Z</updated>
    
    <content type="html"><![CDATA[<p>使用多线程总会伴随 数据的并发访问。<a id="more"></a>多个线程彼此毫无关系地运行几乎是很罕见的。线程可能提供数据给其他线程处理，或是准备好必要的先决条件用以启动其他线程。当多个线程同时运行的时候一定要注意当多个线程并发处理相同的数据而不同步化，那么唯一安全的情况就是所有线程只读取数据而不修改数据。</p><p>所谓相同的数据是使用相同的内存区，如果在不同的内存区那么就不会引发数据竞争的问题，读写也就不会出问题。在C++11中定义的数据竞争是指不同线程中的两个互相冲突的动作，其中至少一个动作不是atomic，而且无一个动作发生在另外一个动作之前。Data race会导致程序不可预期的行为。使用多线程的时候要特别注意平台相关性。</p><p>在什么情况下会出现问题呢？</p><p>1.未同步化的数据访问 ：并行运行的两个线程渡河写同一个数据，不知道哪条语句先执行</p><p>2.写一半的数据：某个线程正在读数据，另一个线程改动它，于是读取数据的线程可能只读一半</p><p>3.重新安装的语句： 语句和操作可能被重新安排次序，也许对每个单一线程正确，但是多线程的组合就破坏了预期的行为。</p><p><strong>Unsynchronized data Access(未同步化的数据访问)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!v.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>如果此段代码被多个线程共享，那么有可能在调用if非空后成功，而其他线程操作之后将v中元素清空，那么此段函数导致不可预期的行为。</p><p>注意：C++标准库提供的函数不支持“写或读”动作与另外一个”写“动作（同一个数据）并发执行。但是并发处理同意容器内的不同元素是可以的（除vector<bool>外）不同的线程可以并发读写同一容器内的元素。并发处理string stream,file stream,或stream buffer会导致不可预期的行为。</bool></p><p><strong>Half-Written Data(写到一半的数据)</strong></p><p>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>某个线程写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>某个线程读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br></pre></td></tr></table></figure><p>程序的输出可能有以下情况：</p><p>x = 0 ： 如果在第一线程执行之前</p><p>x=-1 ： 如果写入线程已完成</p><p>任何其他值： 如果 读取线程在写入线程中进行读取。</p><p><strong>Reordered Statement(重排语句)</strong></p><p>假设有两个变量，一个是bool readyFlag,另外一个是int data。在一个线程中表示提供数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">bool</span> readFlag = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p> 在生成者线程中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">100</span>;</span><br><span class="line">readFlag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>消费者线程中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!readFlag)&#123;&#125;</span><br><span class="line">foo(data);</span><br></pre></td></tr></table></figure><p>一般而言是先执行生成者线程产生数据，然后执行消费者线程处理数据。但是编译器或者硬件可能重排语句指令,从而在生成者为完成数据产生之前调用foo(data)语句，而不是执行while循环，对于单一线程则不会出席这种问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(data);</span><br><span class="line"><span class="keyword">while</span>(!readFlag)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这就有可能造成不可预期的行为。</p><p><strong>如何解决？</strong></p><p>首先要保证代码的原子性（atomicity），即不可分割性，同时也要保证具体指定语句的次序(Order)。</p><p>1.使用future和promise，它们都保证atomicity和order,这就意味着不会同时发生读和写</p><p>2.使用mutex和lock来处理critical section和protected zone。获得锁即保证只有一方可以读或者写。但是如果锁使用的不当，会造成死锁。</p><p>3.可以使用condition_variable，有效的令某线程等待若干“被另外一个线程控制的判断式”为true。有利于处理多线程直接的次序关系。</p><p>4.可以使用atomic data type确保每次对便利或对象的访问操作都是不可分割的。</p><p>5.可以使用atomic data type的底层接口，允许放宽atomic语句的次序或针对内存访问使用manual barrier或fence.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用多线程总会伴随 数据的并发访问。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程</title>
    <link href="http://example.com/jsblog/f4423a86.html"/>
    <id>http://example.com/jsblog/f4423a86.html</id>
    <published>2020-12-20T11:38:33.000Z</published>
    <updated>2020-12-20T13:31:43.015Z</updated>
    
    <content type="html"><![CDATA[<p>进程：计算机中已运行程序的实体，进程是一个动态的概念，同时进程还是计算机中资源分配的最小单位。<a id="more"></a></p><p>线程：线程是cpu调度的基本单位，一个进程可以拥有多个线程。一个线程只属于一个进程。</p><p>在Python中有多个模块可以创建进程，比较常用的有os.fork(),multiprocessing模块和Pool进程池。os.fork()只适用于Unix/linux/MacOs中，在windows不能使用。</p><p>使用multiprocessing模块创建进程需要使用到Process类来生成一个进程对象。Process的构造函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process([group[,target[,name[,args[,kwargs]]]]])</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group : 参数未使用，始终未<span class="literal">None</span></span><br><span class="line">target : 可调用对象，表示要执行的任务</span><br><span class="line">name: 当前进程的别名</span><br><span class="line">args: 表示传递给target的参数</span><br><span class="line">kwargs:表示传递给target函数的参数字典</span><br></pre></td></tr></table></figure><p>Process类常用的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is_alive() : 判断进程实例是否还在执行</span><br><span class="line">join([timeout]) : 是否等待进程实例结束，或等待多少秒</span><br><span class="line">start() : 启动进程(创建子进程)</span><br><span class="line">run()： 如果没有给定target参数，调用start函数时，就执行对象的run函数</span><br><span class="line">terminate(): 立即终止任务，不管任务是否完成</span><br></pre></td></tr></table></figure><p>Process常用属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: 当前进程的别名</span><br><span class="line">pid ：进程实例的ID</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_process</span>(<span class="params">interval</span>):</span></span><br><span class="line">    print(<span class="string">&quot;子进程 %s 开始执行，父进程为 %s&quot;</span>%(os.getpid(),os.getppid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;子进程 %s 执行时间为 %s&quot;</span>%(os.getpid(),(end-start)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p1 = Process(target=child_process,args=(<span class="number">2</span>,))</span><br><span class="line">    p2 = Process(target=child_process,name=<span class="string">&quot;ss&quot;</span>,args=(<span class="number">3</span>,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">&quot;p1 is alive = %s&quot;</span>%p1.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p2 is alive = %s&quot;</span> % p2.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p1 name is %s&quot;</span> % p1.name)</span><br><span class="line">    print(<span class="string">&quot;p1 pid is %s&quot;</span> % p1.pid)</span><br><span class="line">    print(<span class="string">&quot;p2 name is  %s&quot;</span> % p2.name)</span><br><span class="line">    print(<span class="string">&quot;p2 pid is %s&quot;</span> % p2.pid)</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(<span class="string">&quot;父进程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>也可以使用Process子类创建进程，不过要注意的是最好重写一下run函数，可以完成不同的任务，不重写run函数则会调用Process中的默认的run函数。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">rom multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,interval,name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        super(SubProcess,self).__init__() <span class="comment">#不调用父类的构造函数数，process的构造函数会被覆盖出现问题</span></span><br><span class="line">        self.interval = interval</span><br><span class="line">        <span class="keyword">if</span> name:</span><br><span class="line">            self.name = name</span><br><span class="line">    <span class="comment">#override the run function</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;子进程 %s 开始执行，父进程为 %s&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&quot;子进程 %s 执行时间为 %s&quot;</span> % (os.getpid(), (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p1 = SubProcess(<span class="number">2</span>,<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    p2 = SubProcess(<span class="number">3</span>,<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">    <span class="comment">#默认执行run 函数</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">&quot;p1 is alive = %s&quot;</span> % p1.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p2 is alive = %s&quot;</span> % p2.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p1 name is %s&quot;</span> % p1.name)</span><br><span class="line">    print(<span class="string">&quot;p1 pid is %s&quot;</span> % p1.pid)</span><br><span class="line">    print(<span class="string">&quot;p2 name is  %s&quot;</span> % p2.name)</span><br><span class="line">    print(<span class="string">&quot;p2 pid is %s&quot;</span> % p2.pid)</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(<span class="string">&quot;父进程执行结束&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure><p>因为没有指定target参数，所以start函数默认会执行run函数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程：计算机中已运行程序的实体，进程是一个动态的概念，同时进程还是计算机中资源分配的最小单位。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式标志</title>
    <link href="http://example.com/jsblog/cf32e656.html"/>
    <id>http://example.com/jsblog/cf32e656.html</id>
    <published>2020-12-20T11:13:30.000Z</published>
    <updated>2020-12-20T11:14:22.337Z</updated>
    
    <content type="html"><![CDATA[<p>regex flag位于regex_constants内<a id="more"></a>，原则上他们总是可以被传入regex构造函数或regex的各个函数中，作为可有可无的最后一个实参。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> data = <span class="string">&quot;Google@gmail.com,Llll@qq.com,other@sina.com&quot;</span>;</span><br><span class="line">  <span class="comment">//匹配邮箱</span></span><br><span class="line">  <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">&quot;([a-z0-9]*@[a-z]*\\.[a-z]&#123;2,3&#125;)+&quot;</span>,regex_constants::icase)</span></span>;</span><br><span class="line">  <span class="function">sregex_iterator <span class="title">pos</span><span class="params">(data.begin(),data.end(),re)</span></span>;</span><br><span class="line">  sregex_iterator end;</span><br><span class="line">  <span class="keyword">for</span>(; pos != end;++pos)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下表是flag及其含义：</p><table><thead><tr><th>Regex_constants</th><th>意义</th></tr></thead><tbody><tr><td>ECMAScript</td><td>使用ecmascript文法，默认</td></tr><tr><td>basic</td><td>使用posix的basic regular expression 文法</td></tr><tr><td>extended</td><td>使用posix的extended regular expression文法</td></tr><tr><td>awk</td><td>使用unix工具awk的文法</td></tr><tr><td>grep</td><td>使用unix工具grep的文法</td></tr><tr><td>egrep</td><td>使用unix工具egrep的文法</td></tr><tr><td>icase</td><td>忽略大小写</td></tr><tr><td>nosubs</td><td>不将子序列存储于匹配结果内</td></tr><tr><td>optimize</td><td>优化matching速度，然后才考虑regex的创建速度</td></tr><tr><td>collate</td><td>形式[a-b]的字符区间会受locale影响</td></tr><tr><td>match_not_null</td><td>不匹配空序列</td></tr><tr><td>match_not_bol</td><td>第一位置不匹配</td></tr><tr><td>match_not_eol</td><td>最末字符不匹配</td></tr><tr><td>match_not_bow</td><td>第一字符不匹配</td></tr><tr><td>match_not_eow</td><td>最末字符不匹配</td></tr><tr><td>match_continuous</td><td>只试图匹配“从第一字符开始”的子序列</td></tr><tr><td>match_any</td><td>如果多于一个匹配，任何匹配都可以接受</td></tr><tr><td>match_prev_avail</td><td>第一个字符的前一位置是个有效位置</td></tr><tr><td>format_default</td><td>使用默认的ECMAScript替换语法</td></tr><tr><td>format_sed</td><td>使用Unix工具sed的替换语法</td></tr><tr><td>format_first_only</td><td>只替换第一个匹配</td></tr><tr><td>format_no_copy</td><td>对于未获匹配的字符不复制</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;regex flag位于regex_constants内&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式替换</title>
    <link href="http://example.com/jsblog/95d99184.html"/>
    <id>http://example.com/jsblog/95d99184.html</id>
    <published>2020-12-20T11:11:55.000Z</published>
    <updated>2020-12-20T11:14:22.336Z</updated>
    
    <content type="html"><![CDATA[<p>许多文本编辑器都提供了查找和替换功能，同时也支持正则表达式的替换。<a id="more"></a>首先是找到匹配的正则表达式，然后将符合正则表达式的字符序列替换为另一个字符序列。来看一下下面的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> data = <span class="string">&quot;&lt;person&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&lt;first&gt;Nano&lt;/first&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&lt;second&gt;Nike&lt;/second&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&lt;/person&gt;\n&quot;</span>;</span><br><span class="line">  <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; regex_replace(data,re,<span class="string">&quot;&lt;$1 value=\&quot;$2\&quot;/&gt;&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; regex_replace(data,re,<span class="string">&quot;&lt;\\1 value= \&quot;\\2\&quot;/&gt;&quot;</span>,regex_constants::format_sed) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> res2;</span><br><span class="line">  regex_replace(back_inserter(res2),data.begin(),data.end(),re,<span class="string">&quot;&lt;$&#x27; value=\&quot;$2\&quot;/&gt;&quot;</span>,regex_constants::format_no_copy | regex_constants::format_first_only);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配一个XML-tagged value,将其中的值添加到标签中的属性，从而实现替换效果。为了达到替换效果需要指定替换的位置，本例子中使用$1和$2代替替换过程中找的到的tag和value。下表是一个替换的说明：</p><table><thead><tr><th>默认的pattern</th><th>Unix Sed pattern</th><th>意义</th></tr></thead><tbody><tr><td>$&amp;</td><td>&amp;</td><td>Matched pattern</td></tr><tr><td>$n</td><td>\n</td><td>第n个matched capture group</td></tr><tr><td>$`</td><td></td><td>Matched pattern 的前缀</td></tr><tr><td>$’</td><td></td><td>Matched pattern 的后缀</td></tr><tr><td>$$</td><td></td><td>字符$</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;许多文本编辑器都提供了查找和替换功能，同时也支持正则表达式的替换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式词法迭代器</title>
    <link href="http://example.com/jsblog/4f8ac9ef.html"/>
    <id>http://example.com/jsblog/4f8ac9ef.html</id>
    <published>2020-12-20T11:11:05.000Z</published>
    <updated>2020-12-20T11:14:22.338Z</updated>
    
    <content type="html"><![CDATA[<p>regex iterator有助于迭代“匹配合格”之子序列，当你打算将string拆分为一个个语法单元（token）或以某种内容分割string，分隔符甚至可能被指定为一个正则表达式。<a id="more"></a>regex_token_iterator就提供了这样的功能。将它初始化，需要把字符序列的起点和终点，以及一个正则表达式传递给这个迭代器，同时还要指定整数表示语法化过程中的元素：</p><p>-1 ： 表示对分隔符之间的子序列感兴趣</p><p>0 ： 表示你对每一个正则表达式或分隔符感兴趣</p><p>其他表示你对正则表达式中第n个匹配次表达式感兴趣。</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> data = <span class="string">&quot;&lt;person&gt;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;&lt;first&gt;Nano&lt;/first&gt;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;&lt;second&gt;Nike&lt;/second&gt;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;&lt;/person&gt;\n&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">sregex_token_iterator <span class="title">spos</span><span class="params">(data.begin(),data.end(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                        reg,     <span class="comment">// regex</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            &#123;<span class="number">0</span>,<span class="number">2</span>&#125;)</span></span>; <span class="comment">// 0: full match 2:second substring</span></span><br><span class="line">    sregex_token_iterator end;</span><br><span class="line">    <span class="keyword">for</span>(;spos != end;++spos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;match: &quot;</span> &lt;&lt; spos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> names = <span class="string">&quot;nico,jim,helmut,paul,tim,john,paul,rita&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">sep</span><span class="params">(<span class="string">&quot;[ \t\n]*[,;:][ \t\n]*&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">sregex_token_iterator <span class="title">stpos</span><span class="params">(names.begin(),names.end(),sep,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    sregex_token_iterator e;</span><br><span class="line">    <span class="keyword">for</span>(;stpos!=e;++stpos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;names : &quot;</span> &lt;&lt; stpos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;regex iterator有助于迭代“匹配合格”之子序列，当你打算将string拆分为一个个语法单元（token）或以某种内容分割string，分隔符甚至可能被指定为一个正则表达式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式迭代器</title>
    <link href="http://example.com/jsblog/c72502a3.html"/>
    <id>http://example.com/jsblog/c72502a3.html</id>
    <published>2020-12-20T11:10:13.000Z</published>
    <updated>2020-12-20T11:14:22.339Z</updated>
    
    <content type="html"><![CDATA[<p>为了访问正则表达式的匹配结果，使用regex iterator。<a id="more"></a>这些iterator的类型是regex_iterator&lt;&gt;,有针对string和字符序列而预先定义的实例化实现，分别有sregex_iterator,wsregex_iterator,cregex_iterator和wcregex_itreator。如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>  data = <span class="string">&quot;&lt;person&gt;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;first&gt;Nano&lt;/first&gt;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;second&gt;Nike&lt;/second&gt;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;/person&gt;\n&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate over all matches</span></span><br><span class="line">    <span class="function">sregex_iterator <span class="title">pos</span><span class="params">(data.begin(),data.end(),reg)</span></span>;</span><br><span class="line">    sregex_iterator  end;</span><br><span class="line">    <span class="keyword">auto</span> func = [](<span class="keyword">const</span> sregex_iterator&amp; pos)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; match: &quot;</span> &lt;&lt; pos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tag: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;pos != end;++pos)&#123;</span><br><span class="line">        func(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use a regex_iterator to process each matched substring</span></span><br><span class="line">    <span class="function">sregex_iterator <span class="title">beg</span><span class="params">(data.begin(),data.end(),reg)</span></span>;</span><br><span class="line">    for_each(beg,end,[](<span class="keyword">const</span> smatch&amp; pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; match: &quot;</span> &lt;&lt; pos.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tag: &quot;</span> &lt;&lt; pos.str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; pos.str(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了访问正则表达式的匹配结果，使用regex iterator。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式文法</title>
    <link href="http://example.com/jsblog/a1ae3b09.html"/>
    <id>http://example.com/jsblog/a1ae3b09.html</id>
    <published>2020-12-20T11:07:04.000Z</published>
    <updated>2020-12-20T11:14:22.334Z</updated>
    
    <content type="html"><![CDATA[<p>好久之前就想学一下正则表达式，<a id="more"></a>虽然之前有过使用python写爬虫使用正则表达式的经历，但工作中不是使用的python,所以就忘记了好多正则表达式，现在回想起来还是需要看一下的毕竟正则表达式是那么的强大，那么的好用。首先来看一些特殊的表达式以及它们的意义：</p><table><thead><tr><th>表达式</th><th>意义</th></tr></thead><tbody><tr><td>.</td><td>‘\n’以外所有的字符</td></tr><tr><td>[…]</td><td>…字符中任何一个</td></tr><tr><td>[^…]</td><td>非…字符中的任意一个</td></tr><tr><td>[[:charclass:]]</td><td>指定字符类charclass中的一个（见下表）</td></tr><tr><td>\n,\t,\f,\r,\v</td><td>一个newline,tabulator,form feed,carriage return或vertical tab</td></tr><tr><td>\xhh,\uhhh</td><td>一个十六进制字符或Unicode字符</td></tr><tr><td>\d,\D,\s,\S,\w,\W</td><td>某字符类内的一个字符shortcut（见下表）</td></tr><tr><td>*</td><td>前一个字符或者group，任意次数</td></tr><tr><td>?</td><td>前一个字符或者group，可有可无</td></tr><tr><td>+</td><td>前一个字符或者group,至少一次</td></tr><tr><td>{n}</td><td>前一个字符或者group, n次</td></tr><tr><td>{m,n}</td><td>前一个字符或者group,至少m次,最多n次</td></tr><tr><td>…|…</td><td>在 | 之前或者之后的pattern</td></tr><tr><td>(…)</td><td>设定分组</td></tr><tr><td>\1,\2,\3,…</td><td>第n个 group</td></tr><tr><td>\b</td><td>一个正字词的边界</td></tr><tr><td>\B</td><td>一个负字词的边界</td></tr><tr><td>^</td><td>一行的起点</td></tr><tr><td>$</td><td>一行的终点</td></tr></tbody></table><p>下表是正则表达式中的字符类：</p><table><thead><tr><th>字符类</th><th>缩写</th><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>[[:alnum:]]</td><td></td><td></td><td>一个字母或者数字</td></tr><tr><td>[[:alpha:]]</td><td></td><td></td><td>一个字母</td></tr><tr><td>[[:blank:]]</td><td></td><td></td><td>一个space或tab</td></tr><tr><td>[[:cntrl:]]</td><td></td><td></td><td>一个控制字符</td></tr><tr><td>[[:digit:]]</td><td>[[:d:]]</td><td>\d</td><td>一个数字</td></tr><tr><td></td><td></td><td>\D</td><td>一个非数字</td></tr><tr><td>[[:graph:]]</td><td></td><td></td><td>可打印非空白字符</td></tr><tr><td>[[:lower:]]</td><td></td><td></td><td>小写数字</td></tr><tr><td>[[:print:]]</td><td></td><td></td><td>可打印字符包括空白字符</td></tr><tr><td>[[:punct:]]</td><td></td><td></td><td>一个标点符合字符</td></tr><tr><td>[[:space:]]</td><td>[[:s:]]</td><td>\s</td><td>一个空白字符</td></tr><tr><td></td><td></td><td>\S</td><td>一个非空白字符</td></tr><tr><td>[[:upper:]]</td><td></td><td></td><td>一个大写字母</td></tr><tr><td>[[:xdigit:]]</td><td></td><td></td><td>一个十六进制数字</td></tr><tr><td></td><td>[[:w:]]</td><td>\w</td><td>一个字母、数字或者下划线</td></tr><tr><td></td><td></td><td>\W</td><td>非字母、数字或下划线</td></tr></tbody></table><p>使用正则表达式主要用来查找和替换string中的字符。使用正则表达式可以完成以下工作：</p><p>Match : 用输入来对比某个正则表达式</p><p>Search : 查找与patter匹配的正则表达式</p><p>Tokenize : 将语法切分，取得词汇单元</p><p>Replace : 替换第一个或者所有与pattern匹配的。</p><p>现在就看看正则表达式匹配和查找接口。</p><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">bool</span>)&gt; out = [](<span class="keyword">bool</span> b)&#123;<span class="built_in">cout</span> &lt;&lt; (b? <span class="string">&quot;found&quot;</span> : <span class="string">&quot;not found&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="comment">//match</span></span><br><span class="line">    <span class="built_in">string</span> text = <span class="string">&quot;&lt;tag&gt;value&lt;/tag&gt;&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;.*&gt;.*&lt;/.*&gt;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> found = regex_match(text,reg);</span><br><span class="line">    out(found);</span><br><span class="line">    <span class="comment">//match</span></span><br><span class="line">    <span class="function">regex <span class="title">reg1</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>)</span></span>;</span><br><span class="line">    found =  regex_match(text,reg1);</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use grep</span></span><br><span class="line">    <span class="function">regex <span class="title">reg2</span><span class="params">(<span class="string">R&quot;(&lt;\(.*\)&gt;.*&lt;/\1&gt;)&quot;</span>,regex_constants::grep)</span></span>;</span><br><span class="line">    found = regex_match(text,reg2);</span><br><span class="line">    out(found);</span><br><span class="line">    <span class="comment">//use c-style</span></span><br><span class="line">    found = regex_match(<span class="string">&quot;&lt;tag&gt;value&lt;/tag&gt;&quot;</span>,regex(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fail to match but can search</span></span><br><span class="line">    text = <span class="string">&quot;XML tag: &lt;tag&gt;value&lt;/tag&gt;&quot;</span>;</span><br><span class="line">    found = regex_match(text,regex(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    found = regex_match(text,regex(<span class="string">&quot;.*&lt;(.*)&gt;.*&lt;/\\1&gt;.*&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    found = regex_search(text,regex(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    found = regex_search(text,regex(<span class="string">&quot;.*&lt;(.*)&gt;.*&lt;/\\1&gt;.*&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久之前就想学一下正则表达式，&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Numpy之ndarray</title>
    <link href="http://example.com/jsblog/8d30cb7a.html"/>
    <id>http://example.com/jsblog/8d30cb7a.html</id>
    <published>2020-12-20T10:18:00.000Z</published>
    <updated>2020-12-20T11:08:57.668Z</updated>
    
    <content type="html"><![CDATA[<p>ndarray 是多维数组对象，NumPy的核心特征之一就是N-维数组对象–ndarray。<a id="more"></a>ndarray是Python中一个快速、灵活的大型数据容器。允许使用类似标量的操作语法在整块数据上进行科学计算。</p><p>一个ndarray是一个通用的多维同类型数据容器，它包含的每一个元素都是相同的类型。每一个数组都有一个shape属性，用来表征数组每一维度的数量，每一个数组都有一个dtype属性表示数组中的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(data.shape)</span><br><span class="line">print(data.dtype)</span><br></pre></td></tr></table></figure><p>也可以使用list生成一个ndarray不过要使用numpy中的array函数，array函数接收任意的序列型对象，生成一个新的包含传递数据的NumPy数组。如果不显式指定，否则array函数会自动推断数组的数据类型，数据类型被存储在一个特殊的元数据dtype中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r1 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">data2 = np.array(arr1)</span><br><span class="line">print(data2.ndim)</span><br><span class="line">print(data2.shape)</span><br></pre></td></tr></table></figure><p>除了以上的方法用来创建ndarray还有其他函数用来创建数组。zeros函数创建全0的ndarray，ones创建元素值全为1的ndarray。使用empty函数则是创建一个没有初始化数值的数组。如果需要创建高维数组需要为shape传递一个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.zeros(<span class="number">10</span>))</span><br><span class="line">print(np.ones((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>)))</span><br></pre></td></tr></table></figure><p>arange是Python内建函数range的数组版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>下表示用来创建数组的函数，如果没有指明数据类型，则生成元素的默认数据类型为dtype.</p><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>array</td><td>将输入数据转换为ndarray，若不显示指定类型，则自动推断，默认复制所有输入数据</td></tr><tr><td>asarray</td><td>将输入转换为ndarray,但输入时ndarray时则不再复制</td></tr><tr><td>arange</td><td>arange是Python内建函数range的数组版本。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;ndarray 是多维数组对象，NumPy的核心特征之一就是N-维数组对象–ndarray。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程promise</title>
    <link href="http://example.com/jsblog/68f0c029.html"/>
    <id>http://example.com/jsblog/68f0c029.html</id>
    <published>2020-12-20T07:09:10.000Z</published>
    <updated>2020-12-20T11:02:55.255Z</updated>
    
    <content type="html"><![CDATA[<p>如何在线程之间传递参数和处理异常（也就是线程的高级接口如何实现这一技术）。 <a id="more"></a>如果要传递参数给线程，可以把它当做参数来传递，如果想要线程的运行结果可以通过by reference的方式传递参数。</p><p>另外一个用来传递运行结果和异常的机制是使用std::promise,promise对象是future对象配对兄弟，二者都能暂时拥有一个shared state (用来表现一个结果或者异常值)，但是future object允许你取回数据，promise是让你提供数据。其中promise的声明位于头文件<future>中。</future></p><p>在创建promise对象之后，这个对象内部会建立一个shared state用来存放结果值或者异常，并可以被future对象取走并当做线程结果。在传递的时候为了使用by reference，我们可以使用函数std::ref,这样就可以在线程中改变promise对象的shared state。如果promise对象的shared state存有一个结果或者一个异常，其状态还会变成ready。如果想在线程结束时将shared state设置为ready需要用到set_value_at_thread_exit()函数或者set_exception_at_thread_exit()函数，不应使用set_value()或set_exception()函数。</p><p>对于promise函数来说，调用get_future()函数仅仅只能够调用一次，调用多次的话会抛出std::future_error。</p><p>使用promise的实例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doThings</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//read a char</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;read a char : &quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">//if &#x27;x&#x27; throw runtime_error</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot; char &quot;</span>) + c +<span class="string">&quot; read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s= <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot; char &quot;</span>) + c +<span class="string">&quot; processed&quot;</span>;</span><br><span class="line">        p.set_value(<span class="built_in">std</span>::<span class="built_in">move</span>(s));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        p.set_exception(<span class="built_in">std</span>::current_exception()); <span class="comment">//some exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(doThings,<span class="built_in">std</span>::ref(p))</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">        <span class="comment">//get future</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fs = p.get_future();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is : &quot;</span> &lt;&lt;fs.<span class="built_in">get</span>() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is : &quot;</span> &lt;&lt;fs.<span class="built_in">get</span>() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::exception <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Exception : &quot;</span> &lt;&lt;e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Exception &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何在线程之间传递参数和处理异常（也就是线程的高级接口如何实现这一技术）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程packaged_task</title>
    <link href="http://example.com/jsblog/dd61c093.html"/>
    <id>http://example.com/jsblog/dd61c093.html</id>
    <published>2020-12-20T07:08:27.000Z</published>
    <updated>2020-12-20T13:38:41.006Z</updated>
    
    <content type="html"><![CDATA[<p>类模板声明如下：<a id="more"></a></p><p>template <class> class packaged_task;</class></p><p>template&lt;class R,class …Args&gt;</p><p>class packaged_task&lt;R(Args…)&gt;;</p><p>类模板std::package_task 包含所有可调用对象（function,lambda expression,bind expression or another function object，所以它能够异步执行。它返回一个包含处理后的结果或者是异常的状态的std::future对象。std::packaged_task是一个多态，支持分配器的容器，它所包含的可调用目标可能被分配在堆中或者提供的分配器中。</p><p>std::packaged_task构造函数：</p><p><img src="https://pic4.zhimg.com/80/v2-f595c1e6e7373bc48c17f4f03aa9caef_720w.jpg" alt="img"></p><p>构造一个续保的packaged_task对象，其中copy constructor已经被禁用，看一下说明：</p><p>\1. 默认无参构造函数</p><p>\2. 显示构造一个packaged_task对象，其任务由参数f指定。</p><p>\3. 显示构造函数，使用提供的分配器用来保存任务</p><p>\4. copy constructor被禁用</p><p>\5. move constructo</p><p>std::packaged_task 将copy assignment 也给禁用了，只能同过移动语义为将一个packaged_task对象的资源移动给另外一个packaged_task对象。如果直接使用 “=”会编译出错。即如下代码所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">bar</span><span class="params">([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x*<span class="number">10</span>;&#125;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> barx = <span class="built_in">std</span>::move(bar);</span><br></pre></td></tr></table></figure><p>std::packaged_task中的valid函数用来检查对象是否含有可共享的状态。</p><p>std::packaged_task中的swap函数用来交换当前对象与另外一个对象的状态</p><p>std::packaged_task的get_future()返回一个future对象</p><p>**std::packaged_task::operator()(Args… args)**的功能是调用packaged_task对象所包装的可调用对象并将参数args传入到其所包装的可调用对象中。调用成功，返回值保存在packaged_task的共享状态中，调用失败，异常会被保存在共享状态中，但是两者都会是共享状态变为ready. 因此其他等待该共享状态的线程可以获取共享状态的值或者异常并继续执行下去.</p><p><strong>std::packaged_task::make_ready_at_thread_exit(ArgTypes…args);</strong> 的功能是调用packaged_task对象所包装的可调用对象并将参数args传入到其所包装的可调用对象中。与**std::packaged_task::operator()(Args… args)**类似，但是只有在线程退出的时候，才将共享状态设置为ready.</p><p>*<em>std:;packaged_task::reset()**重置 packaged</em>task 的共享状态，但是保留之前的被包装的任务。注意：在使用reset的时候，不能使用get_future两次，会出问题。*</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::microseconds(<span class="built_in">std</span>::<span class="built_in">abs</span>(b-a)));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="string">&quot; sleep for &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b-a) &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(b-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//construct a packaged_task</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">fo</span><span class="params">(foo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if fo is valid and exchange foox with fo</span></span><br><span class="line">  <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; foox;</span><br><span class="line">  <span class="keyword">if</span> (fo.valid())&#123;</span><br><span class="line">    fo.swap(foox);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//get future</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f = foox.get_future();</span><br><span class="line">  <span class="comment">//create a thread</span></span><br><span class="line">  <span class="built_in">std</span>::thread(<span class="built_in">std</span>::move(foox),<span class="number">20</span>,<span class="number">30</span>).detach();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> val = f.get();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//move</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">bar</span><span class="params">([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x*<span class="number">10</span>;&#125;)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> barx = <span class="built_in">std</span>::move(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f2 = barx.get_future();</span><br><span class="line">  barx(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f2.get()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//reset</span></span><br><span class="line">  barx.reset();</span><br><span class="line">  f2 = barx.get_future();</span><br><span class="line">  <span class="built_in">std</span>::thread(<span class="built_in">std</span>::move(barx),<span class="number">10</span>).join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;f2.get()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;类模板声明如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程之std::async</title>
    <link href="http://example.com/jsblog/110f3198.html"/>
    <id>http://example.com/jsblog/110f3198.html</id>
    <published>2020-12-20T07:06:39.000Z</published>
    <updated>2020-12-20T13:39:01.435Z</updated>
    
    <content type="html"><![CDATA[<p>不知道好久之前写过了thread入门这篇文章了，<a id="more"></a>突然发现好多东西都是写了简单的入门并没有怎么深入的去写过了。就连socket编程也只是写到poll模型还没有学到epoll模型。现在又要重新把这些没有学的知识好好的补一下了。现在是继续学习多线程编程，虽然工作中没有用到，但我相信始终会用到的，可能理解的不会很深入吧，但是也还是要好好的学习一下。在那个thread入门那篇文章中，我好像没有说明线程与进程的关系，以及进程的几种状态。当然也没有说明线程的几种模型。当然这些知识可能在网上一搜就都能搜到，如果想要深入的了解学习，我还是比较建议去学习一下有关操作系统的知识。</p><p>不说废话了，还是来看一下c++11中的有关线程的一些操作吧，当然一天一个知识点我就觉得非常不错了。但是每天还是要看看新的知识，不要让自己与外界隔离。这样才能紧跟时代的变化，做一个弄潮儿，虽然我不是。</p><p>现在要学习的是std::async()和std::future()两个接口。首先去<a href="https://link.zhihu.com/?target=http://cppreference.com">http://cppreference.com</a>上看一下这个函数的介绍吧</p><p>std::async 定位于头文件<future>其函数原型如下：</future></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="keyword">result_of_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Function&gt;(<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">async(Function&amp;&amp; f, Args&amp;&amp;... args); <span class="comment">//c++11 和c++17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Function&gt;, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Args&gt;...&gt;&gt;</span><br><span class="line">async(Function&amp;&amp; f, Args&amp;&amp;... args); <span class="comment">//c++17 和c++20</span></span><br></pre></td></tr></table></figure><p>函数模板 <code>async</code> 异步地运行函数 <code>f</code> （潜在地在可能是线程池一部分的分离线程中），并返回最终将保有该函数调用结果的<a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/thread/future">std::future</a>。</p><p>其参数说明：</p><p>f : 要调用的可调用对象，可以使lambda对象</p><p>args…:传递给f的参数</p><p>policy : 发射的策略，是一个枚举，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">launch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  async = <span class="number">1</span>, <span class="comment">//异步求值</span></span><br><span class="line">  deferred = <span class="number">2</span> <span class="comment">//返回的future对象调用get时求值，非异步求值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值为 std::future对象，返回的future有三种状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Status code for futures</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ready,<span class="comment">//异步操作已经完成</span></span><br><span class="line">  timeout,<span class="comment">// 异步操作已经完成</span></span><br><span class="line">  deferred,<span class="comment">//异步操作还没开始</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若运行策略等于 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/thread/launch">std::launch::async</a> 且实现无法开始新线程（该情况下，若运行策略为 async|deferred 或设置了额外位，则它将回退到 deferred 或实现定义的策略），则抛出以 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/error/errc">std::errc::resource_unavailable_try_again</a> 为错误条件的 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/error/system_error">std::system_error</a> ，或者若无法分配内部数据结构所用的内存，则为 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/memory/new/bad_alloc">std::bad_alloc</a> 。</p><p>看过了async,来看一下future</p><p>类模板 std::future 提供访问异步操作结果的机制：</p><p>（通过 std::async 、 std::packaged_task 或 std::promise 创建的）异步操作能提供一个 std::future 对象给该异步操作的创建者。<br>然后，异步操作的创建者能用各种方法查询、等待或从 std::future 提取值。若异步操作仍未提供值，则这些方法可能阻塞。<br>异步操作准备好发送结果给创建者时，它能通过修改链接到创建者的 std::future 的共享状态（例如 std::promise::set_value ）进行。<br>注意， std::future 所引用的共享状态不与另一异步返回对象共享（与 std::shared_future 相反）。</p><p>从官方介绍上复制了一些东西，还是来看一下实际的例子吧，毕竟实践出真知。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoSomethin</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::default_random_engine  <span class="title">dre</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">uid</span><span class="params">(<span class="number">10</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::microseconds(uid(dre)));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DoSomethin(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DoSomethin(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用get或者wait时打印 .</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,func1);</span><br><span class="line">    <span class="comment">//调用get或者wait时打印+号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred,func2);</span><br><span class="line">    <span class="comment">//result2.wait();</span></span><br><span class="line">    <span class="keyword">int</span> res = result1.get() + result2.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道好久之前写过了thread入门这篇文章了，&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>epoll</title>
    <link href="http://example.com/jsblog/32082a79.html"/>
    <id>http://example.com/jsblog/32082a79.html</id>
    <published>2020-12-20T06:49:37.000Z</published>
    <updated>2020-12-20T07:03:49.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是epoll"><a href="#什么是epoll" class="headerlink" title="什么是epoll"></a>什么是epoll</h2><p>epoll是linux内核的可扩展I/O事件通知机制，在linux2.5首次登场，它的目标是取代既有的posix select与poll系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能，epoll实现的功能与poll类似，都是监听多个文件描述符上的事件。<a id="more"></a>epoll通过使用红黑树搜索被监控的文件描述符。</p><h2 id="为什么会出现epoll"><a href="#为什么会出现epoll" class="headerlink" title="为什么会出现epoll"></a>为什么会出现epoll</h2><p>出现epoll是因为现有的select以及poll不能够满足系统的需求，并且两者的开销在进行大量IO操作的时候都很大。首先看一下select的问题：</p><p>每次调用select都要将fd_set集合从用户态拷贝到内核态，当fd_set集合很大时，开销很大，每次调用select都需要在内核遍历传递来的所有的fd_set，如果fd_set很大，开销会很大，fd_set的大小由限制，系统中通过宏来控制而且不可改变（限制为1024）。Poll机制和select机制差不多，但是poll机制解决了文件描述符数量的限制但是没有解决当文件描述符过多的时候开销过大的问题。epoll是基于事件驱动的IO方式，epoll没有描述符个数限制。</p><h2 id="epoll触发模式"><a href="#epoll触发模式" class="headerlink" title="epoll触发模式"></a>epoll触发模式</h2><p>epoll提供了边缘触发和水平触发模式。在ET（边缘）模式中，epoll检测到有IO事件时，通过epoll_wait调用会得到有事件通知的文件描述符，如果不处理这个文件模式符，那么下次调用epoll_wait的时候就不会再次通知此事件（直到有某些操作将就绪变成未就绪状态，也就是说边缘模式只通知一次）；而LT（水平触发）模式时默认的工作模式，即当epoll_wait检查到文件描述符事件时会立即通知应用程序，如果应用程序不处理，下次调用epoll_wait的时候还会再次通知。</p><h2 id="epoll的系统调用（要包含sys-epoll-h头文件）"><a href="#epoll的系统调用（要包含sys-epoll-h头文件）" class="headerlink" title="epoll的系统调用（要包含sys/epoll.h头文件）"></a>epoll的系统调用（要包含sys/epoll.h头文件）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>\1. epoll_create函数创建一个epoll句柄，参数size表明内核要监听的描述符数量，调用成功返回一个epoll句柄描述符。epoll_create已经被弃用，更多推荐使用epoll_create1函数来代替，</p><p>\2. epoll_ctl函数用来注册要监听的事件类型，参数解释如下：</p><p>epfd ：表示epoll句柄</p><p>op : 表示fd的操作类型，有一下三种</p><ul><li>EPOLL_CTL_ADD 注册新的fd到epfd中</li><li>EPOLL_CTL_MOD 修改已注册的fd的监听事件</li><li>EPOLL_CTL_DEL 从epfd中删除一个fd</li></ul><p>fd: 要监听的描述符</p><p>event 表示要监听的事件。epoll_event的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"> <span class="keyword">void</span> *ptr;</span><br><span class="line"> <span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">uint32_t</span> u32;</span><br><span class="line"> <span class="keyword">uint64_t</span> u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>其中epoll_event中的events成员由以下可用事件类型的零个或多个组合在一起形成的掩码：</p><ul><li>EPOLLIN ： 关联的文件描述符可以读,</li><li>EPOLLOUT : 关联的文件描述符可以写；</li><li>EPOLLPRI : 关联的文件描述符由紧急的数据可以读</li><li>EPOLLERR: 关联的文件描述符发生错误</li><li>EPOLLHUP : 关联的文件描述符被挂断</li><li>EPOLLRDHUP : 流套接字对等关闭连接，或半关闭写</li><li>EPOLLET： 设置为边缘触发模式</li><li>EPOLLONESHOT : 只监听一次事件，如果要继续监听这个事件，那么需要再次把这个fd加入到epoll队列中。</li></ul><p>\3. epoll_wait函数等待事件的就绪，成功时返回就绪事件数目，调用失败时返回-1，等待超时返回0.其中参数含义如下：</p><ul><li>epfd : epoll句柄</li><li>events :表示从内核的多的就绪事件集合</li><li>maxevents : 告诉内核events的大小</li><li>timeout : 表示等待的时间</li></ul><p>它会阻塞到一个文件描述符有事件发生；信号中断处理或者超时。</p><h2 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h2><p>支持一个进程打开大数目的文件描述符，select对于文件描述符的大小由一定的限制，epoll则没有这个限制；IO效率不会随着文件描述符数目的增加而线性下降，select/poll都会随着文件描述符的数量增加而性能降低，因为在有事件发生的时候select和poll都要遍历所有的文件描述符才能确定是哪一个文件描述符由事件，而epoll则只会对活跃的文件描述符进行操作。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符。epoll使用mmap进行内核与用户空间消息传递。</p><h2 id="epoll实例"><a href="#epoll实例" class="headerlink" title="epoll实例"></a>epoll实例</h2><p>下面学习了这些理论的基础，还是要实践一下的。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFF 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 9873</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSockfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_IP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">    bzero(&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(port);</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd,(struct sockaddr*)&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd,<span class="number">1024</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to listen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNoBlockfd</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(sockfd,F_SETFL,fcntl(sockfd,F_GETFD,<span class="number">0</span>) |O_NONBLOCK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to set nonblock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> listen_fd,conn_fd,nfds,epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">inAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> in_len = <span class="keyword">sizeof</span>(inAddr);</span><br><span class="line">    bzero(&amp;inAddr,in_len);</span><br><span class="line">    <span class="comment">//create listen fd</span></span><br><span class="line">    listen_fd = createSockfd(PORT);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to create sockfd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set no block</span></span><br><span class="line">    <span class="keyword">if</span> (setNoBlockfd(listen_fd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//create epollfd</span></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create1(<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to create epollfd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register the listen fd</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd,EPOLL_CTL_ADD,listen_fd,&amp;ev) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to add listen fd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buff[MAX_BUFF];</span><br><span class="line">    bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = epoll_wait(epollfd,events,MAX_EVENTS,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, (struct sockaddr *) &amp;inAddr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                setNoBlockfd(conn_fd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connect form: %s\n&quot;</span>, inet_ntoa(inAddr.sin_addr));</span><br><span class="line">                <span class="comment">//register conn_fd</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> nread = read(events[i].data.fd,buff,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">                <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                    epoll_ctl( epollfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buff);</span><br><span class="line">                <span class="keyword">if</span> (write(events[i].data.fd,buff,nread) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是epoll&quot;&gt;&lt;a href=&quot;#什么是epoll&quot; class=&quot;headerlink&quot; title=&quot;什么是epoll&quot;&gt;&lt;/a&gt;什么是epoll&lt;/h2&gt;&lt;p&gt;epoll是linux内核的可扩展I/O事件通知机制，在linux2.5首次登场，它的目标是取代既有的posix select与poll系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能，epoll实现的功能与poll类似，都是监听多个文件描述符上的事件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG之libavfilter</title>
    <link href="http://example.com/jsblog/17b182ff.html"/>
    <id>http://example.com/jsblog/17b182ff.html</id>
    <published>2020-12-20T06:28:40.000Z</published>
    <updated>2020-12-20T06:49:05.517Z</updated>
    
    <content type="html"><![CDATA[<p>FFMPEG除了具有编解码的能力之外，还包含一个强大的功能组件—滤镜avfilter。<a id="more"></a>avfilter经常用于多媒体的处理与编辑。在使用滤镜处理音视频的特效之前，首先需要了解一下Filter的基本格式。</p><p>FFMPEG中的滤镜参数的排列方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[输入流或者标记名]滤镜参数[临时变量名]；[输入流或者标记名]滤镜参数[临时变量名]...</span><br></pre></td></tr></table></figure><p>在设置一些滤镜的时候经常会使用到根据时间轴进行的操作，也就不可避免的要使用到FFMPEG中的Filter的时间内置变量。接下来看一下Filter内置的时间变量，下表是Filter内置的时间变量：</p><table><thead><tr><th>说明</th><th>变量</th></tr></thead><tbody><tr><td>t</td><td>时间戳以秒表示，如果输入的时间位置，则是NAN</td></tr><tr><td>n</td><td>输入帧的顺序编号，从0开始</td></tr><tr><td>pos</td><td>输入帧的位置，如果未知就是NAN</td></tr><tr><td>w</td><td>视频帧的宽度</td></tr><tr><td>h</td><td>视频帧的高度</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;FFMPEG除了具有编解码的能力之外，还包含一个强大的功能组件—滤镜avfilter。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>Python之tuple</title>
    <link href="http://example.com/jsblog/84150675.html"/>
    <id>http://example.com/jsblog/84150675.html</id>
    <published>2020-12-20T06:06:55.000Z</published>
    <updated>2020-12-20T06:07:44.332Z</updated>
    
    <content type="html"><![CDATA[<p>以前就学过Python,因为许久不用导致Python中的好多知识都忘记了。<a id="more"></a>现在想要重新拿起来。主要就是为了学习Python的爬虫技术以及如何使用Python的django库。同时对于OpenCV也比较感兴趣，而Python又是那么的方便，人生苦短，我用python。</p><p>首先看一下Python的数据结构：</p><p><strong>tuple 元组：元组是一种固定长度、不可变的Python对象序列.</strong></p><p>最简单的创建方法就是使用逗号分隔序列值，通过复杂的表达式来定义元组时，通常需用括号将值包起来。可以使用tuple函数将任意序列或迭代器转换为元组。元组的元素可以通过operator[]操作符来获取，但是不能修改，也就是说元组一旦创建，各个位置上的对象时无法修改的。如果元组中的对象时可变的，如果元组中有列表对象，那么可以对这个列表对象进行操作，但是不能修改元组的对象。</p><p>看一下如何创建元组以及获取元组某索引的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple1 &#x3D; 1,2,3,4,5,6,7,[]</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [])</span><br><span class="line">&gt;&gt;&gt; tuple2 &#x3D; tuple([8,9,5])</span><br><span class="line">&gt;&gt;&gt; tuple2</span><br><span class="line">(8, 9, 5)</span><br><span class="line">&gt;&gt;&gt; tuple1[2]</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; tuple1[7].append(1)</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [1])</span><br></pre></td></tr></table></figure><p><strong>使用 + 号连接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple1 + tuple2</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [1], 8, 9, 5)</span><br></pre></td></tr></table></figure><p>将元组乘以整数，生成含有多份拷贝的元组，对象自身并没有复制，只是指向它们的引用复制了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple2 * 2</span><br><span class="line">(8, 9, 5, 8, 9, 5)</span><br></pre></td></tr></table></figure><p><strong>元组解包：将元组类型的表达式赋值给变量，Python会对等号右边的值进行拆包。也可以嵌套拆包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t3 &#x3D; (&quot;a&quot;,&quot;b&quot;,(12,&quot;d&quot;))</span><br><span class="line">&gt;&gt;&gt; a,b,(c,d) &#x3D; t3</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#39;d&#39;</span><br></pre></td></tr></table></figure><p>交换两个值的变量，在Python中很方便即如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; a,b &#x3D; b,a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;a&#39;</span><br></pre></td></tr></table></figure><p>python有一种更高级的拆包功能，用于帮助从元组的起始位置采集一些元素，特殊语法是 *variable，用于函数调用时获取任意长度的位置参数列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; values &#x3D; 1,2,3,4,5</span><br><span class="line">&gt;&gt;&gt; a,b,*_ &#x3D; values</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; _</span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure><p>用于元组的其他操作：</p><p>tuple.count(val) ：用于计量某个数值在元组中出现的次数</p><p>comp(tuple1,tuple2) : 比较两个元组</p><p>len(tuple) : 计算元组中元素个数</p><p>max(tuple) : 返回元组中最大值</p><p>min(tuple) : 返回元组中最小值</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前就学过Python,因为许久不用导致Python中的好多知识都忘记了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之list</title>
    <link href="http://example.com/jsblog/1cfd35a1.html"/>
    <id>http://example.com/jsblog/1cfd35a1.html</id>
    <published>2020-12-20T06:05:59.000Z</published>
    <updated>2020-12-20T06:07:44.331Z</updated>
    
    <content type="html"><![CDATA[<p>列表的长度是可变的。<a id="more"></a>其元素也是可以修改的、可以使用[]或者list类型函数来定义列表。</p><p>列表定义操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [1,2,3,4,5,8]</span><br><span class="line">list2 &#x3D; list((1,2,3,4,5))</span><br><span class="line">print(list1)</span><br><span class="line">print(list2)</span><br></pre></td></tr></table></figure><p>list函数在数据处理中常用于将迭代器或生成器转化为列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen &#x3D; range(10)</span><br><span class="line">print(list(gen))</span><br><span class="line">print(gen)</span><br></pre></td></tr></table></figure><p>添加或删除元素；</p><p>list.append(): 添加到尾部</p><p>list.insert(pos，val) : 将val添加到指定位置</p><p>list.pop(pos): 将pos位置的元素移除</p><p>list.remove(val) : 将定义第一个符合要求的值移除</p><p>使用 in 或 not in 判断值是否在list中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list3 &#x3D; list(range(10))</span><br><span class="line">list3.append(&quot;foo&quot;)</span><br><span class="line">list3.insert(1,&quot;lll&quot;)</span><br><span class="line">print(list3)</span><br><span class="line">list3.pop(0)</span><br><span class="line">list3.remove(&quot;foo&quot;)</span><br><span class="line">print(list3)</span><br><span class="line">print( 5 in list3)</span><br><span class="line">print( 10 not in list3)</span><br><span class="line">使用 + 号连接两个list，也可以使用extend方法向列表添加多个元素</span><br><span class="line">list4 &#x3D; [&quot;122&quot;,(1,2)]</span><br><span class="line">print(list4 + list3)</span><br><span class="line">list3.extend(list4)</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure><p>如果通过添加内容连接列表是一种相对代价较高的操作，连接过程中需要创建新表，并且要复制对象。使用extend方法扩展列表是比较好的方式。</p><p>使用sort排序，sort的一些选项可能用的上，其中一个是传递一个二级排序key 用于生成排序值的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [10,5,20,33,12,4,7]</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line">b &#x3D; [&quot;small&quot;,&quot;key&quot;,&quot;values&quot;,&quot;who are you&quot;]</span><br><span class="line">b.sort(key&#x3D;len)</span><br><span class="line">print(b)</span><br><span class="line">b.reverse()</span><br><span class="line">print(b)</span><br><span class="line">print(sorted(b,key&#x3D;len))</span><br></pre></td></tr></table></figure><p>二分查找和已排序列表的维护（必须排好序，否则会出错）</p><p>内建的bisect实现了二分搜索和排序列表的维护，bisect.bisect会找到元素应当插入的位置，而bisect.insort将元素插入相应位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line">a &#x3D; [10,5,20,33,12,4,7]</span><br><span class="line">a.sort()</span><br><span class="line">print(bisect.bisect(a,11))</span><br><span class="line">bisect.insort(a,6)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>切片它的基本形式是将start:stop传入到索引符合[]中，由于不包含stop所以其元素数量为stop-start,如果省略start或者stop则表示从默认传入序列的起始位值或者结束位置。负索引可以从序列的尾部进行索引.也可以指定步进值step，需要在第二个冒号后面使用，表示每隔几个值取一个，当需要对列表或者元组进行翻转时，将step设置为-1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq &#x3D; [7,2,3,7,5,6,0,1,4]</span><br><span class="line">seq[3:4] &#x3D; [8,9]</span><br><span class="line">print(seq)</span><br><span class="line">print(seq[:4])</span><br><span class="line">print(seq[5:])</span><br><span class="line">print(seq[-4:])</span><br><span class="line">print(seq[-6:-2])</span><br><span class="line">print(seq)</span><br><span class="line">print(seq[::2])</span><br><span class="line">print(seq[::-1])</span><br></pre></td></tr></table></figure><p>一些内建函数</p><p>enumerate : 返回(I,value)元组的序列，其中value时元素的值，i表示索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str_list &#x3D; [&quot;foo&quot;,&quot;bar&quot;,&quot;et&quot;]</span><br><span class="line">mapping &#x3D; &#123;&#125;</span><br><span class="line">for i,val in enumerate(str_list):</span><br><span class="line"> mapping[val] &#x3D; i</span><br><span class="line">print(mapping)</span><br></pre></td></tr></table></figure><p>sorted函数，返回一个根据任意序列中的新建的已排序列表</p><p>zip ：将列表、元组或其他序列的元素配对，新建一个元组构成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str_list1 &#x3D; [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</span><br><span class="line">str_list2 &#x3D; [&quot;one&quot;,&#39;two&#39;,&#39;three&#39;]</span><br><span class="line">zipped &#x3D; zip(str_list1,str_list2)</span><br><span class="line">print(list(zipped))</span><br><span class="line">l1,l2&#x3D; zip(*zip(str_list1,str_list2))</span><br><span class="line">print(list(l1))</span><br><span class="line">print(list(l2))</span><br></pre></td></tr></table></figure><p>reversed : 将序列的元素带线排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(reversed(range(10))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;列表的长度是可变的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之Dict</title>
    <link href="http://example.com/jsblog/33b9a021.html"/>
    <id>http://example.com/jsblog/33b9a021.html</id>
    <published>2020-12-20T06:05:18.000Z</published>
    <updated>2020-12-20T06:07:44.329Z</updated>
    
    <content type="html"><![CDATA[<p>dict是python内建数据结构中最重要的。<a id="more"></a>又称哈希表或者关联数组。字典是拥有灵活尺寸的键值对。其中键和值都是Python中的对象。字典的创建方式使用大括号来创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#125;</span><br><span class="line">d1 &#x3D; &#123;&#39;a&#39;:&#39;some value&#39;,&#39;b&#39;:[1,2,3,4]&#125;</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><p>访问，插入以及设置元素的值可以使用operator[]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1[&quot;test&quot;] &#x3D; &quot;hello&quot;</span><br><span class="line">print(d1[&#39;b&#39;])</span><br><span class="line">d1[&#39;b&#39;] &#x3D; [5,6,7,8]</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><p>使用 in 或者 not in 判断一个key是否在字典中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;a&#39; in d1)</span><br><span class="line">print(&#39;a&#39; not in dict1)</span><br></pre></td></tr></table></figure><p>使用 del关键字或者pop函数删除元素，pop函数会返回对应的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del d1[&#39;b&#39;]</span><br><span class="line">print(d1.pop(&#39;a&#39;))</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><p>key函数和values函数会获取字典中键和值的迭代器，使用update函数可以将两个字典合并，在合并的时候如果传入给update函数的字典中包含原来字典的中key并且这个key对应的value发生变化，那么原来的字典中的此key对应的value会更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d2 &#x3D; &#123;&#39;a&#39; : &#39;you&#39;,&#39;b&#39;:&#39;him&#39;,&#39;q&#39;:&#39;qq&#39;&#125;</span><br><span class="line">d1.update(d2)</span><br><span class="line">print(list(d1.keys()))</span><br><span class="line">print(list(d1.values()))</span><br></pre></td></tr></table></figure><p>字典中的get函数和pop函数都可以返回一个默认值，如果key不在字典中，那么get函数会返回一个None,而pop方法则会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value &#x3D; dict1.get(&quot;test&quot;)</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><p>字典的setdefault() 函数和 get()函数 类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值。内建的collections 有一个defaultdict类，这个类可以生成符合要求的字典，可以向字典中出入类型或能在各位置生成默认值的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">words &#x3D; [&#39;apple&#39;,&#39;wood&#39;,&#39;world&#39;,&#39;orange&#39;,&#39;atom&#39;]</span><br><span class="line">by_letter &#x3D; defaultdict(list)</span><br><span class="line">for word in words:</span><br><span class="line"> by_letter[word[0]].append(word)</span><br><span class="line">print(by_letter)</span><br></pre></td></tr></table></figure><p>字典的key的类型必须是不可变的对象，整数、浮点数、字符串或者元组且元组内对象是不可变对象。通过hash函数可以检查一个对象是否可以用作字典的key</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;dict是python内建数据结构中最重要的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之Set</title>
    <link href="http://example.com/jsblog/83d8cb01.html"/>
    <id>http://example.com/jsblog/83d8cb01.html</id>
    <published>2020-12-20T06:04:20.000Z</published>
    <updated>2020-12-20T06:07:44.331Z</updated>
    
    <content type="html"><![CDATA[<p>集合是一种无序且元素唯一的容器。<a id="more"></a>通过set函数或者使用字面值集与大括号的语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(set([1,2,2,3,4,5,9,6,2,2,3]))</span><br><span class="line">print(type(&#123;1,2,3,4&#125;))</span><br></pre></td></tr></table></figure><p>对于集合主要是数学上的集合操作，例如联合，交集，差集，对称差集。</p><p>所谓联合就是求并集使用union函数或者 | 运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#123;1,2,3,4,5,6&#125;</span><br><span class="line">b &#x3D; &#123;3,4,5,6,7,8,9&#125;</span><br><span class="line">print(a | b)</span><br><span class="line">c &#x3D; a.union(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>交集使用 intersection函数或者使用 &amp; 运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c &#x3D; a.intersection(b)</span><br><span class="line">print(c)</span><br><span class="line">print(a &amp; b)</span><br></pre></td></tr></table></figure><p>集合的一些其他函数：</p><table><thead><tr><th>函数</th><th>替代操作符</th><th>含义</th></tr></thead><tbody><tr><td>s.add(val)</td><td>N/A</td><td>将val添加到集合s中</td></tr><tr><td>s.clear()</td><td>N/A</td><td>将集合清空，清空所有元素</td></tr><tr><td>s.remove(x)</td><td>N/A</td><td>从集合s中移除x</td></tr><tr><td>s.pop()</td><td>N/A</td><td>移除元素，如果s为空，抛出keyEror</td></tr><tr><td>s.copy()</td><td>N/A</td><td>拷贝一个集合</td></tr><tr><td>s.disjoint()</td><td>N/A</td><td>如果两个集合包含相同元素返回True</td></tr><tr><td>s.union(s1)</td><td>s | s1</td><td>s和s1的并集</td></tr><tr><td>s.update(s1)</td><td>s |= s1</td><td>将s的内容设置为s和s1的并集</td></tr><tr><td>s.intersection(s1)</td><td>s &amp; s1</td><td>所有在s中并且在s1中的元素</td></tr><tr><td>s.interserction_update(s1)</td><td>s &amp;= s1</td><td>将s的内容设置为在s中且在s1的元素</td></tr><tr><td>s.difference(s1)</td><td>s-s1</td><td>所有在s中不在s1中的元素</td></tr><tr><td>s.difference_update(s1)</td><td>s -= s1</td><td>将s的内容设置为在s中，不在s1中的元素</td></tr><tr><td>s.symmetric_difference(s1)</td><td>s^s1</td><td>在s，s1中但不同时在s,s1中的元素</td></tr><tr><td>s.symmertric_difference_update(s1)</td><td>s^=s1</td><td>将s的内容设置为在s，s1中但不同时在s,s1中</td></tr><tr><td>s.issubset(s1)</td><td>N/A</td><td>如果s包含于s1返回True</td></tr><tr><td>s,issuperset(s1)</td><td>N/A</td><td>如果s 包含s1 返回True</td></tr></tbody></table><p>和字典的key类似，集合的元素必须是不可改变的，要想包含列表型的元素必须转换为元组。当集合中的内容完全一样时，两个集合才相等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;集合是一种无序且元素唯一的容器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之列表推导式</title>
    <link href="http://example.com/jsblog/bc0362ad.html"/>
    <id>http://example.com/jsblog/bc0362ad.html</id>
    <published>2020-12-20T06:02:39.000Z</published>
    <updated>2020-12-20T06:07:44.334Z</updated>
    
    <content type="html"><![CDATA[<p>列表推导式是Python语言的特性之一。<a id="more"></a>列表推导式的基本形式如下：</p><p>[expr for val in collection if condition]</p><p>如果过滤条件省略,只保留表达式的形式如下：</p><p>[expr for val in collection]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strs &#x3D; [&#39;a&#39;,&#39;as&#39;,&#39;apple&#39;,&#39;bat&#39;,&#39;car&#39;,&#39;dove&#39;,&#39;cplusplus&#39;]</span><br><span class="line">up_2 &#x3D; [x.upper() for x in strs if len(x) &gt; 2]</span><br><span class="line">print(up_2)</span><br></pre></td></tr></table></figure><p>集合与字典的推导式是列表对导师的自然拓展，其形式如下：</p><p>dict_comp={key-expr: value-expr for value in collection if condition}</p><p>set_comp = {expr for value in collection if condition}</p><p>和列表推导式类似，集合，字典的推导式非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_len &#x3D; &#123;len(s) for s in strs&#125;</span><br><span class="line">loc_mapping &#x3D; &#123;key : index for index,key in enumerate(strs)&#125;</span><br><span class="line">print(loc_mapping)</span><br><span class="line">print(set(map(len,strs)))</span><br><span class="line">print(unique_len)</span><br></pre></td></tr></table></figure><p>列表推导式也是可以嵌套使用的，要牢记for表达式的顺序应当和你写嵌套for循环来代替列表推导式的顺序一致。嵌套列表推导式和列表推导式中的列表推导式不一样。</p><p>嵌套列表推导式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuples &#x3D; [(1,2,3),(4,5,6),(7,8,9)]</span><br><span class="line">flattend &#x3D; [x for tup in tuples for x in tup]</span><br><span class="line">print(flattend)</span><br></pre></td></tr></table></figure><p>列表推导式中的列表推导式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dim2 &#x3D; [[x for x in tup ] for tup in tuples]</span><br><span class="line">print(dim2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;列表推导式是Python语言的特性之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之字符串</title>
    <link href="http://example.com/jsblog/35b35764.html"/>
    <id>http://example.com/jsblog/35b35764.html</id>
    <published>2020-12-20T06:02:02.000Z</published>
    <updated>2020-12-20T06:07:44.335Z</updated>
    
    <content type="html"><![CDATA[<p>字符串是 Python 中最常用的数据类型。<a id="more"></a>我们可以使用引号( ‘ 或 “ 或’’’str’’’)来创建字符串。Python中的注释可以使用#comment</p><p>创建字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 &#x3D; &#39;hello world&#39;</span><br><span class="line">str2 &#x3D; &quot;comment&quot; #hhh</span><br><span class="line">str3 &#x3D;&#39;&#39;&#39;1222333&#39;&#39;&#39;</span><br><span class="line">print(str3)</span><br></pre></td></tr></table></figure><p>切片操作，和list类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(str1[:5])</span><br><span class="line">print(str1[5:])</span><br><span class="line">print(str1[-6:-2])</span><br><span class="line">print(str1[::2])</span><br><span class="line">print(str1[::-1])</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#update str</span><br><span class="line">str4 &#x3D; str1[:6]+&quot;roobu&quot;</span><br><span class="line">print(str4)</span><br></pre></td></tr></table></figure><p>字符串的拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str5 &#x3D; &#39;hello&#39; &quot;world&quot;</span><br><span class="line">print(str4+str5)</span><br><span class="line">print(str5)</span><br></pre></td></tr></table></figure><p>str的一些函数如下：</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td>capitalize()</td><td>将字符串的第一个字符转换为大写</td></tr><tr><td>lower()</td><td>转换字符串中所有大写为小写</td></tr><tr><td>upper()</td><td>转换字符串中所有小写为大写</td></tr><tr><td>casefold()</td><td>转换字符串中所有大写为小写</td></tr><tr><td>swapcase()</td><td>对字符串的大小写字母进行转换</td></tr><tr><td>title()</td><td>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td>strip()</td><td>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td>rstrip()</td><td>删除字符串字符串末尾的空格.</td></tr><tr><td>lstrip()</td><td>截掉字符串左边的空格或指定字符。</td></tr><tr><td>replace(old,new,[,max])</td><td>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td>maketrans(x, y=None, z=None, /)</td><td>此静态方法返回一个可供 str.translate( ) 使用的转换对照表。</td></tr><tr><td>translate(table)</td><td>translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符,要过滤掉的字符放到 deletechars 参数中。</td></tr><tr><td>center(width[, fillchar])</td><td>一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td>ljust(width[, fillchar])</td><td>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td>rjust(width[, fillchar])</td><td>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td>zfill(width)</td><td>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td>count(sub[, start[, end]])</td><td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>encode(encoding=’utf-8’,errors=’strict’)</td><td>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td>endswith(suffix[, start[, end]])</td><td>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td>expandtabs(tabsize=8)</td><td>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8</td></tr><tr><td>splitlines([keepends])</td><td>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符</td></tr><tr><td>split(sep=None, maxsplit=-1)</td><td>指定分隔符对字符串进行切片，如果第二个参数 maxsplit 有指定值，则分割为 maxsplit +1 个子字符串。</td></tr><tr><td>rsplit(sep=None, maxsplit=-1)</td><td>除了从右边开始拆分，rsplit( ) 的其他行为都类似于 split( )</td></tr><tr><td>rpartition(sep)</td><td>方法类似于 partition()方法，只是该方法是从目标字符串的末尾也就是右边开始搜索分割符</td></tr><tr><td>rindex(sub[, start[, end]])</td><td>类似于 index()，不过是从右边开始.</td></tr><tr><td>rfind(sub[, start[, end]])</td><td>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td>partition(sep)</td><td>如果字符串包含指定的分隔符，则返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串</td></tr><tr><td>isupper()</td><td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td>istitle()</td><td>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td>isspace()</td><td>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td>isprintable()</td><td>是否为可打印字符</td></tr><tr><td>isnumeric()</td><td>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td>islower()</td><td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td>isidentifier()</td><td>判断字符串是否是有效的 Python 标识符，即可用此方法来判断变量名是否合法</td></tr><tr><td>isdigit()</td><td>如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td>isdecimal()</td><td>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr><tr><td>isalpha()</td><td>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td>isalnum()</td><td>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td>index(sub[, start[, end]])</td><td>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td>format_map(mapping)</td><td>该方法类似于 str.format(**mapping) 都可以进行字符串格式化，不同之处在于 format( ) 方法是一种所有情况都能使用的格式化方法，而 str.format_map(mapping) 方法仅适用于字符串格式中可变数据参数来源于字典等映射关系数据时。mapping 会被直接使用而不是复制到一个 dict</td></tr><tr><td>format(*args, **kwargs)</td><td>格式化字符串</td></tr><tr><td>join(seq)</td><td>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td>find(sub[, start[, end]])</td><td>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr></tbody></table><p>str的格式化：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ascii码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整数</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号16进制数</td></tr><tr><td>%X</td><td>格式化无符号16进制数大写</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f 和 %e的简写</td></tr><tr><td>%G</td><td>%f和%E的简写</td></tr><tr><td>%p</td><td>用16进制格式化变量的地址</td></tr></tbody></table><p>一些其他的辅助：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>在正数面前显示加号 +</td></tr><tr><td><sp></sp></td><td>在正数面前显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示数字前面填充0而不是空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>f-string 是字面量格式化字符串，新的格式化字符串语法，f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f&#39;&#123;1+2&#125;&#39;)</span><br></pre></td></tr></table></figure><p>当然还有一些的转义字符如下：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>\ （在行尾）</td><td>续行符</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\’’</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\yyy</td><td>八进制，y代表0-7</td></tr><tr><td>\xyy</td><td>16进制以\x开头，y代表字符</td></tr><tr><td>\other</td><td>其他字符以普通格式输出</td></tr></tbody></table><p>还有一些与字符串有有个的函数：</p><p>ord() :它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</p><p>chr():用一个整数作参数，返回一个对应的字符。</p><p>max(str)/min(str) : 返回str中最大或者最小的字母</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;字符串是 Python 中最常用的数据类型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之函数</title>
    <link href="http://example.com/jsblog/a17f435f.html"/>
    <id>http://example.com/jsblog/a17f435f.html</id>
    <published>2020-12-20T06:01:14.000Z</published>
    <updated>2020-12-20T06:07:44.332Z</updated>
    
    <content type="html"><![CDATA[<p>Python中函数使用def定义的函数还有就是lambda 定义的函数。<a id="more"></a></p><p>使用def关键字声明的函数，返回使用return关键字，如果到达函数仍然没有遇到return语句，就会自动返回None.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; None</span><br><span class="line">def bind_var():</span><br><span class="line"> a &#x3D; []</span><br><span class="line"> for i in range(5):</span><br><span class="line"> a.append(i)</span><br><span class="line">print(a)</span><br><span class="line">print(bind_var())</span><br></pre></td></tr></table></figure><p>函数有两种连接变量的方式：全局变量，本地变量。在使用全局变量的时候，在使用关键字global表示这个变量是个全局变量，如果不使用global会被默认为本地变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; None</span><br><span class="line">def bind_vvar():</span><br><span class="line"> global a</span><br><span class="line"> a &#x3D; []</span><br><span class="line">bind_vvar()</span><br></pre></td></tr></table></figure><p>print(a)在python可以返回多个值，也就是相当于一个元组，在C++中有tuple的类型，可供来返回多个值，而在python中我们可以直接返回多个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f():</span><br><span class="line"> a &#x3D; 5</span><br><span class="line"> b &#x3D; 7;c&#x3D;8</span><br><span class="line"> return a,b,c</span><br><span class="line">a,b,c &#x3D; f()</span><br><span class="line">print(a,b,c)</span><br></pre></td></tr></table></figure><p>在Python中每一个函数都是一个对象，可以将函数作为一个参数传递到其他的函数中，相当于一种回调的使用。lambda是一种匿名函数，在c++中也有lambda函数，在Python定义匿名函数可以直接使用lambda关键字。匿名函数没有一个显示的__name__属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exp_val &#x3D; lambda x : x*x</span><br><span class="line">print(exp_val(10))</span><br></pre></td></tr></table></figure><p>了解到一个新的词语，柯里化函数：部分参数应用，它是通过部分参数应用的方式从已有的函数产生新的函数，内建的functools可以使用pratial函数简化处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">def add_numbers(x,y):</span><br><span class="line"> return x+y</span><br><span class="line">add_five &#x3D; partial(add_numbers,5)</span><br><span class="line">print(add_five(10))</span><br></pre></td></tr></table></figure><p>这与C++ 的bind函数很像，可以对函数使用占位符并确定某些位置的参数，形成一个新的函数对象。Python中通过一致的方式遍历序列这也就是迭代器模式。迭代器在Python中是一种用在上下文中向Python解释器生成对象的对象。生成器是构造新的可遍历序列的一种简洁的方式，如果需要创建生成器需要使用yield关键字，即将return换成yield关键字即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def squares(n &#x3D; 10):</span><br><span class="line"> for i in range(1,n+1):</span><br><span class="line"> yield i**2</span><br><span class="line">gen &#x3D; squares()</span><br><span class="line">print(gen)</span><br><span class="line">print(list(gen))</span><br></pre></td></tr></table></figure><p>生成器表达式可以很方便的创建生成器，生成器表达式与列表的推导式很相似，只需要将列表推导式的中括号换成小括号就行。生成器表达式也可以代替列表推导式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gen &#x3D; (x**2 for x in range(1,11))</span><br><span class="line">print(gen)</span><br><span class="line">print(list(gen))</span><br><span class="line">mapping &#x3D; dict((x,x**2) for x in range(1,11))</span><br><span class="line">print(mapping)</span><br></pre></td></tr></table></figure><p>itertools模块是适用于大多数数据集合算法的生成器，可以查看相应的文档来学习</p><p>错误和异常处理使用try/except捕获和处理异常</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python中函数使用def定义的函数还有就是lambda 定义的函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
</feed>
