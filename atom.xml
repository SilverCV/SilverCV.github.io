<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林森</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-30T11:51:07.949Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>视图变换基础</title>
    <link href="http://example.com/jsblog/6c65e2d3.html"/>
    <id>http://example.com/jsblog/6c65e2d3.html</id>
    <published>2020-12-30T11:49:35.000Z</published>
    <updated>2020-12-30T11:51:07.949Z</updated>
    
    <content type="html"><![CDATA[<p>只有理解图形的三维处理方法才能掌握计算机图形学的原理。<a id="more"></a>二维图形学只是三维图形学的一个特例。在几何流水线中，需要设定一个场景。首先从设定三维坐标系统这一步开始，进而在三维世界中定义完整的场景。在定义完整的场景之前需要完成模型的建立和变换两项工作。</p><p>对于同一个的物体，我们从不同的方向看，会看到不同的景象。这就是横看成岭侧成峰，远近高低各不同。对于同一个物体，所看到的视图取决于所观察的位置，而这个所观察的位置就是视点。视图也取决于观察的目标点，也就是视图的参考点。对于同一个物体而言，在同一位置观察这个物体的不同点，那么其视图也会不同。而这个被观察的点就是参考点。对于视图而言，不同的视野看到的物体不同的。大场景中看到的物体有可能时全景图，而在窄视野中看到的物体可能只是物体的一部分。所以决定所看到图形的因素有观察点的位置，观察的目标点，观察视图的向上方向，观察的宽度以及视图的高宽比。也就是在计算机图形中，必须指定这些参数才能正确的定义图像。</p><p>一旦确定了视图必须把它转化为可以在二维成像设备上显示的图像。在计算机图形学中，需要精确计算二维屏幕空间中每个点的颜色。把三维场景变换到二维空间需要定义一系列步骤：场景中哪一部分靠前，哪一部分时落在视点看到的范围内，以及场景如何转化到二维视图空间中。视图操作的基本工作时在世界空间中定义一个观察方式，让观察着可以观察到模型空间中允许看到的物体。定义观察方式包括把视点放在三维世界空间中，并且创建眼坐标系统，从而把三维世界空间转换到这个三维眼坐标空空，接着使用投影原理在三维眼坐标空间中定义一个二维平面，用来显示场景，实际上定义了一种映射关系，把那个平面看作为观察平面。</p><p>模型变换，视图变化和投影等机制通过图形API来管理，图形编程的任务就是给这些API提供正确的信息，并且按照正确的顺序调用这些API函数。所谓的视图变换就是通过建立一个从世界坐标系到眼坐标系的基本变换矩阵并把它应用到场景中所有实体来实现的过程。这个变换是把视点放在原点，看向Z轴，同时Y轴是向上方向。它把几何物体从世界坐标系变换到眼坐标系，同时保持模型中的几何关系不变。</p><p>在观看场景的时候需要定义一些因素：</p><ul><li>定义模型的观看方式，包括视点的位置、视图的方向个范围，这些定义了视图变换。</li><li>定义三维空间到二维空间的投影，因为三维空间必须在二维的显示设备上才能被看见。对于不同的投影有不同的实现方式。</li><li>定义观看图像的视图设备区域，称为图形窗口，不应该和屏幕上的窗口混淆。</li><li>定义视图在窗口中的显示位置，着定义了窗口中的视口和窗口到视口的映射，该映射把二维空间变换到平面空间。</li></ul><p>这四个因素分别称为建立视图环境、定义投影、定义窗口和定义视口。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只有理解图形的三维处理方法才能掌握计算机图形学的原理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>ratio</title>
    <link href="http://example.com/jsblog/fc60b87f.html"/>
    <id>http://example.com/jsblog/fc60b87f.html</id>
    <published>2020-12-30T11:49:20.000Z</published>
    <updated>2020-12-30T11:51:07.950Z</updated>
    
    <content type="html"><![CDATA[<p>类模板std::ratio代表一个比例，或者说是比率。<a id="more"></a>类模板 <code>std::ratio</code> 及相关的模板提供编译时有理数算术支持。此模板的每个实例化都准确表示任一确定有理数，只要分子 <code>Num</code> 与分母 <code>Denom</code> 能表示为 std::intmax_t 类型的编译时常量。另外， <code>Denom</code> 不可为零且不可等于最负的值。约分分子和分母到最简。std::ratio的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">intmax_t</span> _Num, <span class="keyword">intmax_t</span> _Den = <span class="number">1</span>&gt;</span><br><span class="line">  struct ratio</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(_Den != <span class="number">0</span>, <span class="string">&quot;denominator cannot be zero&quot;</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(_Num &gt;= -__INTMAX_MAX__ &amp;&amp; _Den &gt;= -__INTMAX_MAX__,</span><br><span class="line">    <span class="string">&quot;out of range&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: sign(N) * abs(N) == N</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">intmax_t</span> num =</span><br><span class="line">      _Num * __static_sign&lt;_Den&gt;::value / __static_gcd&lt;_Num, _Den&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">intmax_t</span> den =</span><br><span class="line">      __static_abs&lt;_Den&gt;::value / __static_gcd&lt;_Num, _Den&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> ratio&lt;num, den&gt; type;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>其中分母为_Dx，其不能为0 也不能小于最小的负值。<code>std::ratio</code> 是不同的类型，即使它们表示同一有理数（在约分后）。能经由其 <code>type</code> 成员约分 <code>ratio</code> 类型到最简分数： <code>std::ratio&lt;3, 6&gt;::type</code> 为 <code>std::ratio&lt;1, 2&gt;</code> 。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintRatio</span><span class="params">(T <span class="keyword">const</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Num : &quot;</span> &lt;&lt; v.num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Den : &quot;</span> &lt;&lt; v.den &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">5</span>&gt; test;</span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">2</span>, <span class="number">10</span>&gt; test2;</span><br><span class="line">PrintRatio(test2);</span><br><span class="line">PrintRatio(test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STL还定义了一些类型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,       <span class="number">1000000000000000000</span>&gt; atto;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,          <span class="number">1000000000000000</span>&gt; femto;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,             <span class="number">1000000000000</span>&gt; pico;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,                <span class="number">1000000000</span>&gt; nano;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,                   <span class="number">1000000</span>&gt; micro;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,                      <span class="number">1000</span>&gt; milli;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,                       <span class="number">100</span>&gt; centi;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>,                        <span class="number">10</span>&gt; deci;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;                       <span class="number">10</span>, <span class="number">1</span>&gt; deca;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;                      <span class="number">100</span>, <span class="number">1</span>&gt; hecto;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;                     <span class="number">1000</span>, <span class="number">1</span>&gt; kilo;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;                  <span class="number">1000000</span>, <span class="number">1</span>&gt; mega;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;               <span class="number">1000000000</span>, <span class="number">1</span>&gt; giga;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;            <span class="number">1000000000000</span>, <span class="number">1</span>&gt; tera;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;         <span class="number">1000000000000000</span>, <span class="number">1</span>&gt; peta;</span><br><span class="line"><span class="keyword">typedef</span> ratio&lt;      <span class="number">1000000000000000000</span>, <span class="number">1</span>&gt; exa;</span><br></pre></td></tr></table></figure><p>还有一些编译期之间的运算：</p><table><thead><tr><th>算术</th><th></th></tr></thead><tbody><tr><td>ratio_add(C++11)</td><td>在编译时相加两个 <code>ratio</code> 对象 (别名模板)</td></tr><tr><td>ratio_subtract(C++11)</td><td>在编译时相减两个 <code>ratio</code> 对象 (别名模板)</td></tr><tr><td>ratio_multiply(C++11)</td><td>在编译时相乘两个 <code>ratio</code> 对象 (别名模板)</td></tr><tr><td>ratio_divide(C++11)</td><td>在编译时相除两个 <code>ratio</code> 对象 (别名模板)</td></tr><tr><td>比较</td><td></td></tr><tr><td>ratio_equal(C++11)</td><td>在编译时比较两个 <code>ratio</code> 对象的相等性 (类模板)</td></tr><tr><td>ratio_not_equal(C++11)</td><td>在编译时比较两个 <code>ratio</code> 对象的不相等性 (类模板)</td></tr><tr><td>ratio_less(C++11)</td><td>在编译时比较两个 <code>ratio</code> 对象的<em>小于</em>关系 (类模板)</td></tr><tr><td>ratio_less_equal(C++11)</td><td>在编译时比较两个 <code>ratio</code> 对象的<em>小于或等于</em>关系 (类模板)</td></tr><tr><td>ratio_greater(C++11)</td><td>在编译时比较两个 <code>ratio</code> 对象的<em>大于</em>关系 (类模板)</td></tr><tr><td>ratio_greater_equa(C++11)</td><td>在编译时比较两个 <code>ratio</code> 对象的<em>大于或等于</em>关系 (类模板)</td></tr></tbody></table><p>示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintRatio</span><span class="params">(T <span class="keyword">const</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Num : &quot;</span> &lt;&lt; v.num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Den : &quot;</span> &lt;&lt; v.den &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">5</span>&gt; test;</span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">2</span>, <span class="number">10</span>&gt; test2;</span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt; r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PrintRatio(test2);</span><br><span class="line">PrintRatio(test);</span><br><span class="line"><span class="built_in">std</span>::ratio_add&lt;<span class="keyword">decltype</span>(test), <span class="keyword">decltype</span>(test2)&gt; sum;</span><br><span class="line">PrintRatio(sum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ratio_divide&lt;<span class="keyword">decltype</span>(r), <span class="keyword">decltype</span>(test2)&gt; result;</span><br><span class="line">PrintRatio(result);</span><br><span class="line"><span class="built_in">std</span>::ratio_multiply&lt;<span class="keyword">decltype</span>(r), <span class="keyword">decltype</span>(test2)&gt; result1;</span><br><span class="line">PrintRatio(result1);</span><br><span class="line"><span class="built_in">std</span>::ratio_subtract&lt;<span class="keyword">decltype</span>(test), <span class="keyword">decltype</span>(test2)&gt; result2;</span><br><span class="line">PrintRatio(result2);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="built_in">std</span>::boolalpha &lt;&lt;<span class="built_in">std</span>::ratio_greater&lt;<span class="keyword">decltype</span>(r), <span class="keyword">decltype</span>(test2)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;类模板std::ratio代表一个比例，或者说是比率。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>无锁的数据结构设计</title>
    <link href="http://example.com/jsblog/c3f2eaef.html"/>
    <id>http://example.com/jsblog/c3f2eaef.html</id>
    <published>2020-12-29T12:16:15.000Z</published>
    <updated>2020-12-30T11:51:07.950Z</updated>
    
    <content type="html"><![CDATA[<p>作为一种无锁数据结构，意味着线程可以并发访问这个数据结构。<a id="more"></a>当一个线程被调度器挂起时，其他线程必须能够完成自己的工作，而无需等待挂起线程。</p><p>无锁数据结构时具有 比较/交换 操作的数据结构。使用 比较/交换操作的原因：当有其他线程同时对指定数据的修改时，代码将尝试恢复数据。当其他线程被挂起时，比较/交换操作执行成功，那么这样的代码就是无锁的。当执行失败时，就需要一个自旋锁，且这个结构就是非阻塞-有锁的结构</p><p>无等待数据结构：首先时无锁数据结构，并且，每个线程都能在有限的步数内完成操作，暂且不管其他线程时怎么工作的，由于会和别的线程产生冲突，所以算法可以进行无数次尝试，因此并不是无等待的。使用无锁数据接哦古的主要原因时将并发最大化。互斥锁削弱了结构的并发性。使用无锁数据结构的原因就是鲁棒性。也就是稳定性和健壮性。当线程在无锁数据结构上执行操作，在执行到一半死亡时，数据结构上的数据没有丢失，其他线程依旧可以正常执行。</p><p>因为没有任何锁，所以不会存在死锁问题。根据定义，无等待的代码不会存在活锁问题，因为其操作执行步骤是由有上限的。所谓活锁就是两个线程同时尝试修改数据，但每个线程所做的修改操作都会让另一个线程重启，所以两个线程就会陷入循环，多次尝试完成自己的操作。不过活锁的存在时间并不久，因为其依赖于线程的调度。</p><p>下面是一个无锁的线程安全链表，在设计的时候要考虑到添加数据以及弹出数据的安全性。</p><p>对于链表而言是添加结点和删除结点。添加结点的时候分为三步：1.创建一个新的结点，2.让新结点的next指针指向head结点，3.让head结点指向当前新结点。如果在一个线程中执行第二步，另外一个线程中执行第三步，则会发生data race。可以使用原子的比较/交换解决。对于删除头结点可以分为五步：1.读取当前head指针的值，2.读取head-&gt;next 3.设置让head为head-&gt;next 4.通过索引node ，返回data数据，5 删除索引结点。在删除的时候要注意内存泄漏以及多线程之间的条件竞争。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_List</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; _data;</span><br><span class="line">        Node* next;</span><br><span class="line">        Node(T <span class="keyword">const</span>&amp; data) : _data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;Node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(T <span class="keyword">const</span>&amp; val)</span></span>&#123;</span><br><span class="line">        Node* <span class="keyword">const</span> new_node = <span class="keyword">new</span> Node(val);</span><br><span class="line">        new_node-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span>(!head.compare_exchange_weak(new_node-&gt;next,head));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* node = head.load();</span><br><span class="line">        <span class="keyword">while</span>(node &amp;&amp; !head.compare_exchange_weak(node,head));</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;_data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一种无锁数据结构，意味着线程可以并发访问这个数据结构。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL示例</title>
    <link href="http://example.com/jsblog/9672e096.html"/>
    <id>http://example.com/jsblog/9672e096.html</id>
    <published>2020-12-28T11:32:53.000Z</published>
    <updated>2020-12-30T11:48:24.779Z</updated>
    
    <content type="html"><![CDATA[<p>对于学习计算机而言，需要实践才能出真知。<a id="more"></a>学习使用GLUT进行计算机图形学。与其他功能强大的API一样，OpenGL十分复杂，提供许多编程方法来解决问题。</p><p>mian函数一般由建立OpenGL系统的操作组成。通常有两种实现方法：1.通过GLUT创建并设置用户显示的系统窗口，第二，通过定义回调函数，建立时间处理系统。回调函数是事件发生时使用的，并初始化模型和显示环境。示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> W = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> H = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POS_X =  <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POS_Y = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//显示回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//改变窗口回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//空闲回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idle</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//键盘回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyFunc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//鼠标回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MouseFunc</span><span class="params">(<span class="keyword">int</span> button,<span class="keyword">int</span> state,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInit(&amp;argc,argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">    glutInitWindowSize(W,H);</span><br><span class="line">    glutInitWindowPosition(POS_X,POS_Y);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;a simple program&quot;</span>);</span><br><span class="line">    <span class="comment">//定义事件回调函数</span></span><br><span class="line">    glutDisplayFunc(display);</span><br><span class="line">    glutReshapeFunc(reshape);</span><br><span class="line">    glutIdleFunc(idle);</span><br><span class="line">    glutKeyboardFunc(keyFunc);</span><br><span class="line">    glutMouseFunc(MouseFunc);</span><br><span class="line">    <span class="comment">//进入事件主循环</span></span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数是相关事件发生时，系统事件处理程序时调用的函数。上面的程序就是OpenGL程序的基本结构，display函数用于在屏幕中展示图像。OpenGL应用程序中的main()函数结有一些关键的操作，设置显示模式，定义用于显示的窗口，以及程序所需的初始化操作。使用glutInitDisplayMode()设置模式。</p><p>在模型空间使用glBegin()……glEnd()来绘制图像。模型变换则是哟个glPushMatrix()/glPopMatrix().而视图变换时使用:</p><p>glutLookAt(ex,ey,ez,lx,ly,lz,ux,uy,uz),</p><p>(ex,ey,ez)视点坐标，(lx,ly,lz)表示视线的方向，（ux,uy,uz）定义向上的矢量方向。投影操作使用:</p><p>glOrthon(left,right,bottom,top,near, far);</p><p>left,right表示正交视域体的左侧面和右侧面的x坐标，bottom和top分别时下底面和上底面的y坐标，near和far分别时前面与背面的z坐标。透视投影使用下面函数定义：</p><p>gluPerspective(fovy,aspect,near,far)</p><p>第一个参数是视场角，第二个参数aspect是高宽比，near和far分别时前面与背面的z坐标。</p><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS 30  <span class="comment">//金属条的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AMBIENT 25.0    <span class="comment">//温度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOT 50      <span class="comment">//热源的温度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLD 0.0    <span class="comment">//冷槽的温度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NHOTS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NCOLDS  5</span></span><br><span class="line">GLfloat  angle = <span class="number">0.0</span>;</span><br><span class="line">GLfloat temps[ROWS][COLS],back[ROWS+<span class="number">2</span>][COLS+<span class="number">2</span>];</span><br><span class="line">GLfloat  theta = <span class="number">0.0</span>,vp = <span class="number">30.0</span>;</span><br><span class="line"><span class="comment">//设置金属长条上固定热点和冷点的位置</span></span><br><span class="line"><span class="keyword">int</span> hotspots[NHOTS][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;ROWS/<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;ROWS/<span class="number">2</span><span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;ROWS/<span class="number">2</span><span class="number">-2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">3</span>*COLS / <span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> coldspots[NCOLDS][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;ROWS<span class="number">-1</span>,COLS / <span class="number">3</span>&#125;,&#123;ROWS<span class="number">-1</span>,<span class="number">1</span>+COLS/<span class="number">3</span>&#125;,&#123;ROWS<span class="number">-1</span>,<span class="number">2</span>+COLS/<span class="number">3</span>&#125;,&#123;ROWS<span class="number">-1</span>,<span class="number">3</span>+COLS/<span class="number">3</span>&#125;,&#123;ROWS<span class="number">-1</span>,<span class="number">4</span>+COLS/<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> myWin;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myinit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line">    glClearColor(<span class="number">0.6</span>,<span class="number">0.6</span>,<span class="number">0.6</span>,<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">//设置初始温度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; ROWS;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            temps[i][j] = AMBIENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//热点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; NHOTS; ++i) &#123;</span><br><span class="line">        temps[hotspots[i][<span class="number">0</span>]][hotspots[i][<span class="number">1</span>]] = HOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冷点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; NCOLDS; ++i) &#123;</span><br><span class="line">        temps[coldspots[i][<span class="number">0</span>]][coldspots[i][<span class="number">1</span>]] = COLD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在模型坐标系的第一个八分象限内传教单位立方体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cube</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> GLfloat point[<span class="number">3</span>];</span><br><span class="line">    point  v[<span class="number">8</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    glBegin(GL_QUAD_STRIP);</span><br><span class="line">    glVertex3fv(v[<span class="number">4</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">5</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">0</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">1</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">2</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">3</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">6</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">7</span>]);</span><br><span class="line">    glEnd();</span><br><span class="line">    glBegin(GL_QUAD_STRIP);</span><br><span class="line">    glVertex3fv(v[<span class="number">1</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">3</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">5</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">7</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">4</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">6</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">0</span>]);</span><br><span class="line">    glVertex3fv(v[<span class="number">2</span>]);</span><br><span class="line">    glEnd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">float</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r,g,b;</span><br><span class="line">    r = (t-COLD) / (HOT - COLD);</span><br><span class="line">    g = <span class="number">0.0</span>;</span><br><span class="line">    b = <span class="number">1.0</span> - r;</span><br><span class="line">    glColor3f(r,g,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE 10.0</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="comment">//定义视图变换</span></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluLookAt(vp,vp/<span class="number">2.</span>,vp/<span class="number">4.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">//场景旋转</span></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glRotatef(angle,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">//画金属条</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;ROWS ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            setColor(temps[i][j]);</span><br><span class="line">            <span class="comment">//显示各项模型变换</span></span><br><span class="line">            glPushMatrix();</span><br><span class="line">            glTranslatef((<span class="keyword">float</span>)i - ROWS / <span class="number">2.0</span>,(<span class="keyword">float</span>)j - COLS / <span class="number">2.0</span>,<span class="number">0.0</span>);</span><br><span class="line">            <span class="comment">//冷，热</span></span><br><span class="line">            glScalef(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.1</span>+<span class="number">3.9</span>*temps[i][j]/HOT);</span><br><span class="line">            cube();</span><br><span class="line">            glPopMatrix();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择操作和变换缓存来结束场景绘制</span></span><br><span class="line">    glPopMatrix();</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义投影变换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluPerspective(<span class="number">60.0</span>,(<span class="keyword">float</span>)w/(<span class="keyword">float</span>)h,<span class="number">1.0</span>,<span class="number">300.0</span>);</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterationStep</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> filter[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0.0</span>,<span class="number">0.125</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0.125</span>,<span class="number">0.5</span>,<span class="number">0.125</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0.125</span>,<span class="number">0.0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//增加材质的温度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROWS; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            back[i+<span class="number">1</span>][j+<span class="number">1</span>] = temps[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//临界值填充边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ROWS+<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        back[i][<span class="number">0</span>] = back[i][<span class="number">1</span>];</span><br><span class="line">        back[i][COLS+<span class="number">1</span>] = back[i][COLS];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS+<span class="number">2</span>; ++j) &#123;</span><br><span class="line">        back[<span class="number">0</span>][j] = back[<span class="number">1</span>][j];</span><br><span class="line">        back[ROWS+<span class="number">1</span>][j] = back[ROWS][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROWS; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            temps[i][j] = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">-1</span>; k &lt;=<span class="number">1</span> ; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">-1</span>; n &lt;= <span class="number">1</span> ; ++n) &#123;</span><br><span class="line">                    temps[i][j] += back[i+<span class="number">1</span>+k][j+<span class="number">1</span>+n] * filter[k+<span class="number">1</span>][<span class="number">1</span>+n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//热点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; NHOTS; ++i) &#123;</span><br><span class="line">        temps[hotspots[i][<span class="number">0</span>]][hotspots[i][<span class="number">1</span>]] = HOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冷点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; NCOLDS; ++i) &#123;</span><br><span class="line">        temps[coldspots[i][<span class="number">0</span>]][coldspots[i][<span class="number">1</span>]] = COLD;</span><br><span class="line">    &#125;</span><br><span class="line">    angle += <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animate</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//改变数据，显示下一幅图像</span></span><br><span class="line">    _sleep(<span class="number">10</span>);</span><br><span class="line">    iterationStep();</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInit(&amp;argc,argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE| GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">    glutInitWindowSize(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">    glutInitWindowPosition(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;a simple program&quot;</span>);</span><br><span class="line">    <span class="comment">//定义事件回调函数</span></span><br><span class="line">    glutDisplayFunc(display);</span><br><span class="line">    glutReshapeFunc(reshape);</span><br><span class="line">    glutIdleFunc(animate);</span><br><span class="line">    <span class="comment">//进入事件主循环</span></span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面所用到的OpenGL函数主要有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">glBegin(xxx):指定由顶点函数定义的几何模型的类型</span><br><span class="line"></span><br><span class="line">glClear(parms) : 清除由参数定义的窗口数据</span><br><span class="line"></span><br><span class="line">glClearColor(r,g,b,a): 将图形窗口的颜色设为背景颜色</span><br><span class="line"></span><br><span class="line">glColor3f(r,g,b): 为后续顶点调用设置RGB值</span><br><span class="line"></span><br><span class="line">glEnable(parm): 激活参数定义的性能</span><br><span class="line"></span><br><span class="line">glEnd() :几何模型定义区域的结束标记和glBegin()配对使用</span><br><span class="line"></span><br><span class="line">glLoadIdentity():将单位矩阵写入由glMatrixMode指定的矩阵中</span><br><span class="line"></span><br><span class="line">glPopMatrix() ： 在glMatrixMode指定的当前矩阵栈中，将栈顶的矩阵被glPopMatrix弹出后，该矩阵的值将恢复为最近调用的glPushMatrix栈顶矩阵值</span><br><span class="line"></span><br><span class="line">glRoteta(angle,x,y,z): 旋转几何模型，旋转轴的参数为（x,y,z），旋转角度为angle</span><br><span class="line"></span><br><span class="line">glScalef(dx,dy,dz): 对几何模型进行缩放</span><br><span class="line"></span><br><span class="line">glTranslatef(tx,ty,tz): 顶点坐标加指定值，平移几何模型</span><br><span class="line"></span><br><span class="line">glVertex3fv(array): 根据三维矩阵设置几何模型顶点</span><br><span class="line"></span><br><span class="line">glViewPort(x,y,width,height):使用整数窗口坐标，指定会在图形的视口尺寸</span><br></pre></td></tr></table></figure><p><strong>GLU函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gluLookAt(ex,ey,ez,vx,vy,vz,ux,uy,uz): 通过定义视点位置，视点观察位置和观测向上放心设置环境参数</span><br><span class="line"></span><br><span class="line">gluPerspective(fieldofView,aspect,near,far): 基于观察环境参数，给定定义是雨天的四个参数以定义透视投影</span><br></pre></td></tr></table></figure><p><strong>GLUT函数</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">glutCreateWindow(title): 创建图形窗口，并给出窗口名</span><br><span class="line"></span><br><span class="line">glutDisplayFunc(function): 为显示事件指定回调函数</span><br><span class="line"></span><br><span class="line">glutIdleFunc(function): 为空闲事件指定回调函数</span><br><span class="line"></span><br><span class="line">glutInit(parms): 根据main函数的部分参数初始化glut系统</span><br><span class="line"></span><br><span class="line">glutInitDisplayMode(parms): 设置系统显示模式</span><br><span class="line"></span><br><span class="line">glutInitWindowPosition(x,y): 设置窗口左上角顶点的屏幕坐标</span><br><span class="line"></span><br><span class="line">glutInitWindowSize(x,y): 在屏幕坐标中设置窗口的宽和高</span><br><span class="line"></span><br><span class="line">glutMainLoop(): glut事件处理循环</span><br><span class="line"></span><br><span class="line">glutPostRedisplay() : 设置重绘事件，触发再次显示事件</span><br><span class="line"></span><br><span class="line">glutReshapeFunct(function): 为改变窗口事件指定回调函数</span><br><span class="line"></span><br><span class="line">glutSwapBuffers() : 后台颜色缓存中的内容交换到前台颜色缓存中用于显示</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GL_COLOR_BUFFER_BIT : 与glClear()一起使用，表明清空颜色缓存</span><br><span class="line"></span><br><span class="line">GL_DEPTH_BUFFER_BIT: 与glClear()一起使用，表明清空深度缓存</span><br><span class="line"></span><br><span class="line">GL_DEPTH_TEST: 指定使用深度测试</span><br><span class="line"></span><br><span class="line">GL_MODEVIEW: 指定使用模视矩阵</span><br><span class="line"></span><br><span class="line">GL_QUAD_STRIP :指定所用顶点是连续有序的四边形条带的顶点</span><br><span class="line"></span><br><span class="line">GLUT_DEPTH: 指定窗口是哦那个的深度缓存</span><br><span class="line"></span><br><span class="line">GLUT_DOUBLE : 指定窗口使用的后台缓存</span><br><span class="line"></span><br><span class="line">GLUT_RGB : 指定窗口使用的RGB颜色模型</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于学习计算机而言，需要实践才能出真知。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>计算机图像学基础概念</title>
    <link href="http://example.com/jsblog/10cae5d4.html"/>
    <id>http://example.com/jsblog/10cae5d4.html</id>
    <published>2020-12-27T11:19:43.000Z</published>
    <updated>2020-12-27T14:00:50.516Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习计算机图像学，作为笔记，记录一下自己的学习过程。<a id="more"></a>首先学习的是计算机图形学中的一些基础知识。首先了解以下观点：</p><ul><li>形状是准备表达观点的有用工具，需要小心使用。</li><li>颜色是创建有效图像的重要因素，比其他因素更为重要是，颜色可以向观众展示图像的重要部分，传达需要表达的确切信息。</li><li>与观众交流信息时，选择自然还是人工的形状和颜色十分重要</li><li>把颜色与运动结合在一起可表达高达五维的信息，但必须仔细考虑如何将不同信息纳入每个维度表现出来。</li><li>为了正确理解图像表达的含义，应向观众提供正确的视图和相关的背景知识</li><li>现代图形API和计算机创建动态图像变得很容易，因此可以利用动作使图像生动丰富</li><li>不仅可以创建动态图形，还可让观众与图像交互，让他们自己探索问题</li><li>运动与交互使表示模型行为的方法，必须将其视为交流的重要组成部分</li><li>在设计图像时必须对观众的文化背景有足够的了解。</li></ul><p>计算机图形基本上是三维的，图形系统必须处理三维几何数据。计算机图形系统通过创建三维几何流水线处理这个问题，三维几何流水线就是将三维点转换成二维点的一系列过程。其中三维点是三维几何的基本组成单元。</p><p>下图是三维几何流水线的步骤与映射：</p><p><img src="/jsblog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%83%8F%E5%AD%A6%E5%9F%BA%E7%A1%80%5Cthreedims.jpg" alt="三维几何流水线的步骤与映射"></p><p>场景与视图是计算机图形学的两个基本概念，场景是在图像中显示的三维空间对象组合，包括空间中所有的几何对象和光。视图是用于创建图像的信息集，是包括场景空间，场景坐标系，坐标系中带观察方向的视点，将空间中可视部分映射到二维可视平面的投影操作。</p><p>为了创建图像，必须定义表示图像各部分的几何数据。创建并定义几何体的过程称为建模，通常情况下，建模过程是先将每个对象在其有意义的坐标系（即三维模型坐标系）中定义好，然后采用一系列模型变换将对象变换到统一空间坐标系（即三维世界坐标系），在该空间中所有的对象均可见。场景包括三维坐标系中的一系列图形对象，所有图形对象都使用该三维坐标系。这个坐标系称为世界坐标系。视图变换时选择好视点的位置与三维世界空间中的所有对象，重新调整坐标是，将视点调整到适当位置，并以该视点为原点，往适当的方向观察，得到的坐标系未三维眼坐标系。</p><p>投影是将三维眼坐标系转化为二维坐标的过程。投影将视域体映射成二维平面上的图形，称为视平面。投影分为平行投影和透视投影。平行投影是指将模型中所有的点通过与Z轴平行的方向投影的X-Y平面，将模型中的所有点从眼空间映射到视平面上。透视投影将光源视为一个点，场景中的每个点沿着这个光源到该带你的视线投影到视平面。同理视域体分为正交视域体和透视视域体，视域体表示的是空间中的可视区域。</p><p>裁剪操作时通过致电给对象在视域体之内和视域体之外部分进行的操作。视域体裁剪是将超出可视空间的部分裁剪掉。</p><p>正交投影适用于以下情况：</p><ul><li>需要确认场景中的物体是否排列整齐或大小是否相同，</li><li>需要测量场景中的物体，</li><li>需要确认线条是否平行。</li></ul><p>透视技影适用于以下情况：</p><ul><li>使图像看起来比较真实，</li><li>能在场景中移动并具有与人眼类似的观察效果</li><li>不需要测量或排列图像中的对象。</li></ul><p>二维眼坐标系中的一个点相当于三维眼空间的一整条线。几何流水线的最后一步是在二维眼坐标空间调整对象的坐标， 使其适合二维显示设备的 坐标系。 显示屏幕是一种数字设备， 因此二维眼空间坐标中的实数需要转化成代表屏幕坐标 的整数。 可对坐标值先作比例映射再取整。 这个操作称为窗口到视口映射， 新的坐标空间称为屏幕坐标， 或显示坐标。注意： 整个流水线将几何体用对象顶点表示， 通过多个不同变换从一个表示形式变为另一个表示形式。 这些变换都保证不同表示形式的场景的几何体顶点的一致性， 同时计算机图形学还假设场景的拓扑保持不变。</p><p>一些外观属，这些外观属性可以外对象看起来更自然，在顶点转换到二维屏幕坐标后，为屏幕上的每个顶点计算颜色：</p><ul><li>顶点深度值， 定义为视点参考方向上视点到该顶点的距离，</li><li>顶点颜色，</li><li>顶点撞向量，</li><li>顶点材质，</li><li>顶点纹理坐标。</li></ul><p>颜色：可以由程序员直接定义，如果场景由关照与材质定义，则颜色也可由光找模型计算得到。</p><p>纹理：纹理映射是为场景添加视觉效果的是最有用的方法之一，纹理映射可以将图像，比如图像中的视觉内容贴到场景对象上。 通过纹理映射，可使对象表面达到照片的效果，或其他可使，图像更有趣更有真实感的效果。</p><p>深度缓存：创建场景时，只要画出与视点最近的对象，这些对象后面的对象会被遮挡，成为不可见。在绘制阶段，只要保存井比较视点与己绘制像素的距离和待绘制像素的距离，就可实现这一目标。 如果待绘制像素到视点距离小于已绘制像素，则用新像素的颜色覆盖原来的颜色；反之，保持原来的像素颜色，这就是深度缓存操作。</p><p>图形系统处理场景直到最后向用户显示过程中所完成的全部几何操作过程。 上图中，若忽略裁剪和窗口到视口映射过程，我们可以看到，从定义基本几何模型开始，应用了模型变化，视图变化，最后在屏幕坐标系应用投影变化。可用组合函数表示：</p><p>projection(viewing(modeling(geometry)))</p><p>或者</p><p>projection*(viewing *(modeling *(geometry))) = (projection * viewing * modeling)(geometry)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始学习计算机图像学，作为笔记，记录一下自己的学习过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>NumPy其他操作</title>
    <link href="http://example.com/jsblog/ae6f7bda.html"/>
    <id>http://example.com/jsblog/ae6f7bda.html</id>
    <published>2020-12-27T08:02:28.000Z</published>
    <updated>2020-12-27T08:37:11.031Z</updated>
    
    <content type="html"><![CDATA[<p>NumPy可以在硬盘中将数据以二进制或者文本的形式进行存入硬盘和在硬盘中读取。<a id="more"></a>主要是使用np.save和np.load对硬盘数据进行高效的存取。也可以使用np.savez将数组作为参数传递给函数，用于在未压缩文件中保存数组，不过对这种文件使用np.load函数得到的将是一个字典型的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">print(arr)</span><br><span class="line">np.save(<span class="string">&quot;test&quot;</span>,arr)</span><br><span class="line">arr1 = np.load(<span class="string">&quot;test.npy&quot;</span>)</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line">np.savez(<span class="string">&quot;test1&quot;</span>,a=arr,b=arr)</span><br><span class="line">arch = np.load(<span class="string">&quot;test1.npz&quot;</span>)</span><br><span class="line">print(arch[<span class="string">&#x27;b&#x27;</span>])</span><br></pre></td></tr></table></figure><p>NumPy的线性代数中所不同的是 * 表示矩阵的逐元素乘积，而不是矩阵的点积。因此numpy的ndarray对象以及numpy模块都提供了一个函数dot，用来计算点积。特殊符号@也可以作为中缀操作符，表示点积，numpy.linalg拥有一个矩阵分解的标准函数集。常用的numpy.linalg函数如下：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>diag</td><td>将一个方阵的对角元素作为一维数组返回</td></tr><tr><td>dot</td><td>矩阵点乘</td></tr><tr><td>trace</td><td>求矩阵的迹</td></tr><tr><td>det</td><td>计算行列式</td></tr><tr><td>eig</td><td>计算特征值和特征向量</td></tr><tr><td>inv</td><td>计算方阵的逆矩阵</td></tr><tr><td>pinv</td><td>计算Moore-Penrose伪逆</td></tr><tr><td>qr</td><td>qr分解</td></tr><tr><td>svd</td><td>奇异值分解</td></tr><tr><td>solve</td><td>求解x的线性系统Ax=b,其中A是方阵</td></tr><tr><td>lstsq</td><td>计算Ax=b的最小二乘解</td></tr></tbody></table><p>NumPy中的random模块弥补了Python内建的random模块的不足，可以高效的生成多种概率分布下的完整样本值数组。你可以通过numpy.random.seed更改NumPy的随机数种子。下表是numpy中的random模块中的部分函数列表:</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>seed</td><td>指定随机种子</td></tr><tr><td>permutation</td><td>返回一个序列的随机排列，或者返回一个乱序的整数范围序列</td></tr><tr><td>shuffle</td><td>随机排列一个序列</td></tr><tr><td>rand</td><td>从均匀分布中抽取样本</td></tr><tr><td>randint</td><td>根据给定的由低到高的范围抽取整数</td></tr><tr><td>randn</td><td>从均值0方差1的正态分布中抽取样本</td></tr><tr><td>binomial</td><td>从二项分布中抽取样本</td></tr><tr><td>normal</td><td>从正态分布中抽取样本</td></tr><tr><td>beta</td><td>从beta分布中抽取样本</td></tr><tr><td>chisquare</td><td>从卡方分布中抽取样本</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;NumPy可以在硬盘中将数据以二进制或者文本的形式进行存入硬盘和在硬盘中读取。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>基于锁的并发程序设计</title>
    <link href="http://example.com/jsblog/b8c16c25.html"/>
    <id>http://example.com/jsblog/b8c16c25.html</id>
    <published>2020-12-27T05:37:15.000Z</published>
    <updated>2020-12-27T07:28:05.469Z</updated>
    
    <content type="html"><![CDATA[<p>基于锁的并发数据结构设计，需要确保访问线程持有锁的时间最短。<a id="more"></a>对于只有一个互斥量的数据结构来说，需要保证数据不被锁之外的操作所访问到，并且还要保证不会在固有结构上产生条件竞争。但是使用多个互斥量可能会导致死锁。</p><p>下面是一个使用锁的的线程安全的数据队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">empty_queue</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;empty queue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe_que</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadSafe_que()&#123;&#125;</span><br><span class="line">    ThreadSafe_que(<span class="keyword">const</span> ThreadSafe_que&amp; rhs)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">ul</span><span class="params">(rhs._m)</span></span>;</span><br><span class="line">        _queu = rhs._queu;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadSafe_que&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadSafe_que&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        _queu.push(<span class="built_in">std</span>::move(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (empty()) <span class="keyword">throw</span> empty_queue();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::move(_queu.front())))</span></span>;</span><br><span class="line">        _queu.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        value = <span class="built_in">std</span>::move(_queu.front());</span><br><span class="line">        _queu.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _queu.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; _queu;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex _m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>互斥量_m能保证基本的线程安全，那就是对每个成员函数进行加锁保护。这就保证在同<br>一时间内，只有一个线程可以访问到数据，所以能够保证，数据结构的“不变量”被破坏时，不会被其他线程看到。在empty()和pop()成员函数之间会存在潜在的竞争，不过代码会在pop()函数上锁时，显式的查询栈是否为空，所以这里的竞争是非恶性的所有成员函数都使用 st::lock_guard&lt;&gt; 来保护数据，所以队列的成员函数能有“线程安全”的表现。</p><p>下面使用条件变量和锁是实现一个线程安全的队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe_que</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadSafe_que()&#123;&#125;</span><br><span class="line">    ThreadSafe_que(<span class="keyword">const</span> ThreadSafe_que&amp; rhs)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">ul</span><span class="params">(rhs._m)</span></span>;</span><br><span class="line">        _queu = rhs._queu;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadSafe_que&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadSafe_que&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        _queu.push(<span class="built_in">std</span>::move(value));</span><br><span class="line">        _cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(_m)</span></span>;</span><br><span class="line">        _cv.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !_queu.empty(); &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::move(_queu.front())))</span></span>;</span><br><span class="line">        _queu.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(_m)</span></span>;</span><br><span class="line">        _cv.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !_queu.empty(); &#125;);</span><br><span class="line">        value = <span class="built_in">std</span>::move(_queu.front());</span><br><span class="line">        _queu.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (_queu.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::move(_queu.front())))</span></span>;</span><br><span class="line">        _queu.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (_queu.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = <span class="built_in">std</span>::move(_queu.front());</span><br><span class="line">        _queu.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _queu.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; _queu;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable _cv;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex _m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于锁的并发数据结构设计，需要确保访问线程持有锁的时间最短。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>内存顺序</title>
    <link href="http://example.com/jsblog/6b9219f6.html"/>
    <id>http://example.com/jsblog/6b9219f6.html</id>
    <published>2020-12-27T01:54:12.000Z</published>
    <updated>2020-12-27T04:20:54.699Z</updated>
    
    <content type="html"><![CDATA[<p>有六个内存序列选项可应用于对原子类型的操作：memory_order_relaxed,memory_order_consume,memory_order_acquire,memory_order_release,memory_order_acq_rel以及memory_order_seq_cst。<a id="more"></a>这六个原子序列主要分为三类：排序一致序列(memory_order_seq_cst),获取-释放序列(memory_order_consume,memory_order_acquire,memory_order_release,memory_order_acq_rel)以及自由序列(memory_order_relaxed)。</p><p>不同的内存序列模型，允许开发人员利用其提升与更细粒度排序相关的操作。看一下不同操作序列和同步相关的结果。</p><p><strong>排序一致序列</strong></p><p>默认的就是排序一致序列，它表示程序中的行为从任意角度去看，序列顺序都保持一致。如果原子类型实例上的所有操作都是序列一致的，那么一个多线程的行为，就以某种特殊的排序执行，好像单线程那样。从同步来看，对于同一变量，排序一致的存储操作同步相关与同步一致的载入操作。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span>&#123;x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_seq_cst);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_seq_cst);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_seq_cst))&#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_seq_cst))&#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    assert(z.load() != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列一致是最简单、直观的序列，但是他也是最昂贵的内存序列，因为它需要对所有线程进行全局同步。在一个多处理系统上，这就需要处理期间进行大量并且费时的信息交换。为了避免这种同步消耗，需要考虑使用其他模型。</p><p><strong>非序列一致内内存模型</strong></p><p>在不同线程中看到的相同操作，不一定有着相同的顺序，还有对于不同线程的操作，都会整齐的，一个接着另一个执行的想法都是需要摒弃的。不仅是要摒弃交错执行操作的想法，你还要放弃使用编译器或处理器重排指令的想法。在没有明确的顺序限制下，唯一的要求就是，所有线程都要统一对每一个独立变量的修改顺序。对不同变量的操作可以体现在不同线程的不同序列上，提供的值要与任意附加顺序限制保持一致。当跳出排序一致模型时，最好的就是使用memory_order_relaxed对所有操作进行约束。</p><p><strong>自由序列</strong></p><p>在原子类型上的操作以自由序列执行，没有任何同步关系。在同一线程中对于同一变量的操作还是服从先发执行的关系，但是不同线程几乎不需要相对的顺序。唯一的要求是在访问同一线程中的单个原子变量不能重排序。当一个给定线程已经看到一个原子变量的特定<br>值，线程随后的读操作就不会去检索变量较早的那个值。如下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_and_y</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_and_y</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">        <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_relaxed))&#123;</span><br><span class="line">            ++z;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(write_x_and_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(read_x_and_y)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    assert(z.load() != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取-释放序列</strong></p><p>对于获取释放序列来说，虽然操作依旧没有统一的顺序，但是在这个序列中引入了同步，在这种模型中，原子加载就是获取操作（memory_order_acquire）,原子存储就是释放操作（memory_order_release)，原子读-改-写操作不是获取就是释放或者两者都有（memory_order_acq_rel）.同步在线程释放和获取间，是成对的。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span>&#123;x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_acquire))&#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_acquire))&#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    assert(z.load() != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有六个内存序列选项可应用于对原子类型的操作：memory_order_relaxed,memory_order_consume,memory_order_acquire,memory_order_release,memory_order_acq_rel以及memory_order_seq_cst。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>同步操作</title>
    <link href="http://example.com/jsblog/ac8be0e6.html"/>
    <id>http://example.com/jsblog/ac8be0e6.html</id>
    <published>2020-12-26T07:56:26.000Z</published>
    <updated>2020-12-26T10:32:50.768Z</updated>
    
    <content type="html"><![CDATA[<p>假设有两个线程，一个用来进行数据的处理，另外一个线程用来将计算好的线程输出。<a id="more"></a>如果没有将数据进行处理，那么就不应该将数据输出。为了实现同步数据，第一个线程设置一个标志，用来表明数据已经处理完成，并且第二个线程在这个标志设置之前不能读取进行数据的处理。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_data;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">readyFlag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessData</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    g_data = x;</span><br><span class="line">    readyFlag.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!readyFlag.load())&#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; g_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把等待数据的低效循环一边，当非原子的读和写对同一数据结构进行无序访问时，将有可能导致未定义的行为发生。强制访问顺序是由atomic的类型的数据readyFlag变量进行操作完成的，这些操作通过“先行发生”和“同步发生”确定必要的顺序。</p><p>所谓同步发生关系是指：只能在原子类型之间进行的操作。同步发生的基本思想：对数据进行适当标记的原子写操作，同步与对数据进行适当标记的原子读操作，读取的是在写之后的数据。如果线程A存储了一个值，并且线程B读取了这个值，线程A的存储操作和线程B的载入才足以呼吁事故同步关系。如上述代码。</p><p>所谓的先行关系是指在一个程序中，基本的操作顺序是：它指定了某个操作去影响另一个操作。如果一个操作排在另外一个操作之后，那么这个操作就是先执行的。如果代码中操作A发生在操作B之前，那么A就先行与B发生。如果A操作在一个线程上，并且操作B线程同步，那么A就线程间先行与B。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;假设有两个线程，一个用来进行数据的处理，另外一个线程用来将计算好的线程输出。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>atomic操作</title>
    <link href="http://example.com/jsblog/3152afc0.html"/>
    <id>http://example.com/jsblog/3152afc0.html</id>
    <published>2020-12-26T04:39:12.000Z</published>
    <updated>2020-12-26T09:35:07.336Z</updated>
    
    <content type="html"><![CDATA[<p>最基本的原子整数类型就是std::atomic<boo>。<a id="more"></a>它比std::atomic_flag拥有更加齐全的布尔标志特性。可以使用一个非原子的bool类型进行构造，也可以使用一个非原子类型的bool值进行赋值。</boo></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">ready</span><span class="params">(ture)</span></span>;</span><br><span class="line">ready = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>在原子类型中，赋值操作通过返回值（返回相关的非原子类型）完成，而非返回引用。std::atomic也支持对值的普通查找，其会将对象隐式转换为一个普通的类型值，或者调用load()函数来获取这个类型值。store()是一个存储操作，load()是一个加载操作即读取操作。exchange()则是一个“读-改-写”操作,当前值与预期值一致时，存储新值的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">ready</span><span class="params">(ture)</span></span>;</span><br><span class="line">ready = <span class="literal">false</span>;</span><br><span class="line">boo x = ready.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">ready.store(<span class="literal">true</span>);</span><br><span class="line">x = ready.exchange(<span class="literal">false</span>,<span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure><p>还有就是比较/交换操作，compare_exchange_weak()和compare_exchange_strong()成员函数，这个操作时原子类型编程的基础：它比较原子变量的当前值和预期值，当两者相等时，存储预期值。当两者不等时，预期值会被更新为原子变量中的值，此操作的结果时一个bool值，为true执行存储操作，为false则更新期望值。但是对于compare_exchange_weak()函数，当原始值与预期值一致时，存储也有可能会失败。</p><p>原子指针类型，可以使用内置类型或自定义类型T,通过特化std::atomic&lt;T*&gt;进行定义，虽然接口和std::atomic<T>的一致，但是它的操作时对于相关类型的指针，在使用load(),store()，exchange(),compare_exchange_weak()和compare_exchange_strong()成员函数时,获取与返回的类型都是指针类型T *。</T></p><p>使用原子类型的一个示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_data</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Set_data</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    g_data.store(x,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = g_data.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread id : &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; stl;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; ptl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        stl.emplace_back(<span class="built_in">std</span>::thread(Set_data,i));</span><br><span class="line">        ptl.emplace_back(<span class="built_in">std</span>::thread(PrintX));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        stl[i].join();</span><br><span class="line">        ptl[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最基本的原子整数类型就是std::atomic&lt;boo&gt;。&lt;/boo&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>atomic_flag</title>
    <link href="http://example.com/jsblog/17f63eb7.html"/>
    <id>http://example.com/jsblog/17f63eb7.html</id>
    <published>2020-12-25T12:40:26.000Z</published>
    <updated>2020-12-25T12:41:07.883Z</updated>
    
    <content type="html"><![CDATA[<p>std::atomic_flag是最简单的标准原子类型，它表示了一个bool标志。<a id="more"></a>这个类型的对象可以在两个状态切换：设置和清除。</p><p>std::atomic_flag类型的对象必须被ATOMIC_FLAG_INIT初始化，初始化标志位是清除状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure><p>这适用于任何对象的声明，并且可以在任意范围内。它是唯一需要以这种方式初始化的原子类型，它是唯一保证无锁的类型。std::atomic_flag在首次使用时，都需要初始化。当std::atomic_flag对象已经初始化，那么对于此对象只能做三件事情：销毁，清除或设置。这些操作对应的函数分别是： clear()成员函数，和test_and_set()成员函数。</p><p>clear()和test_and_set()成员函数可以指定内存顺序。clear()是一个存储操作，所以不能有memory_order_acquire或memory_order_acq_rel语义。但是test_and_set()是一个读-改-写操作，所有可以应用于任何内存顺序标签。每一个原子操作，默认的内存顺序都是memroy_order_seq_cst。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line"><span class="keyword">bool</span> x = f.test_and_set()</span><br></pre></td></tr></table></figure><p>对于std::atomic_flag对象不能进行拷贝构造，也不能将一个对象赋予另一个std::atomic_flag对象。copy constructor和copy assignment 都是不支持的，对于所有的原子类型而言。因为赋值和拷贝构造都会包含操作的原子性。下面使用std::atomic_flag实现一个自选互斥锁。初始化标志是“清除”，并且互斥量处于解锁状态。为了锁上互斥量，循环运行test_and_set()直到旧值为false，就意味着这个线程已经被设置为true了。解锁互斥量是一件很简单的事情，将标志清除即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spinlock_mutex</span>&#123;</span></span><br><span class="line"><span class="built_in">std</span>::atomic_flag _flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Spinlock_mutex() : _flag(ATOMIC_FLAG_INIT)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(_flah.test_and_set(<span class="built_in">std</span>::memory_order_acquire))&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _flag.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用std::atomic_flag的示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic_flag f = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f.test_and_set(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread id is : &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">f.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; tls;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">tls.emplace_back(<span class="built_in">std</span>::thread(ThreadTest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : tls) &#123;</span><br><span class="line">it.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下表是一个内存顺序模型和值：</p><table><thead><tr><th align="center">Memory Order 值</th><th align="center">Memory Order 类型</th></tr></thead><tbody><tr><td align="center">memory_order_relaxed</td><td align="center">Relaxed</td></tr><tr><td align="center">memory_order_consume</td><td align="center">Consume</td></tr><tr><td align="center">memory_order_acquire</td><td align="center">Acquire</td></tr><tr><td align="center">memory_order_release</td><td align="center">Release</td></tr><tr><td align="center">memory_order_acq_rel</td><td align="center">Acquire/Release</td></tr><tr><td align="center">memory_order_seq_cst</td><td align="center">Sequentially consistent</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;std::atomic_flag是最简单的标准原子类型，它表示了一个bool标志。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>NumPy面向数组</title>
    <link href="http://example.com/jsblog/2da432df.html"/>
    <id>http://example.com/jsblog/2da432df.html</id>
    <published>2020-12-24T12:24:42.000Z</published>
    <updated>2020-12-24T13:10:09.620Z</updated>
    
    <content type="html"><![CDATA[<p>使用NumPy数组可以使你利用简单的数组表达式完成多种数据操作任务，而无须写些大量循环。<a id="more"></a>这种利用数组表达式来替代显式循环的方法，称为向量化。通常，向量化的数组操作会比纯Python的等价实现在速度上快一到两个数量级（甚至更多），这对所有种类的数值计算产生了最大的影响。附录A中我解释的广播机制，就是向量化计算的有效方式。<br>作为一个简单的示例，假设我们想要对一些网格数据来计算函数sqrt(x^2 + y^2)的值。np.meshgrid函数接收两个一维数组，并根据两个数组的所有(x, y)对生成一个二维矩阵,并使用matplotlib函数imshow根据函数值生成图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">points = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">xs,ys = np.meshgrid(points,points)</span><br><span class="line">z = np.sqrt(xs**<span class="number">2</span>+ys**<span class="number">2</span>)</span><br><span class="line">plt.imshow(z)</span><br><span class="line">plt.title(<span class="string">&quot;Image plot of $\sqrt&#123;x^2+y^2&#125;$ for a grid value&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/jsblog/meshgrid.jpg" alt="mesh"></p><p>将条件逻辑作为数组操作，numpy的where函数是三元表达式x if condition else y的向量化版本。</p><p>许多关于计算整个数组统计值或关于轴向数据的数学函数，可以作为数组类型的方法被调用。你可以使用聚合函数（通常也叫缩减函数），比如sum、mean和std（标准差），既可以直接调用数组实例的方法，也可以使用顶层的NumPy函数。像means，sum函数可以接收一个可选参数axis,用于计算给定轴上的统计值，形成一个下降一维的数组。下表是基础数组统计方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sum</td><td>沿轴向计算所有元素的累和，0长度的数组累和为0</td></tr><tr><td>mean</td><td>数学平均值，0长度的数组的平均值为NaN</td></tr><tr><td>std,var</td><td>标准差，方差</td></tr><tr><td>min,max</td><td>最小值和最大值</td></tr><tr><td>argmin,argmax</td><td>最小最大值的位置</td></tr><tr><td>cumsum</td><td>从0开始元素累和</td></tr><tr><td>cumrod</td><td>从1开始元素累积</td></tr></tbody></table><p>对于布尔值数组，有两个非常有用的方法any和all。any检查数组中是否至少有一个True，而all检查是否每个值是否都为True</p><p>对于排序而言，NumPy数组可以使用sort函数位排序，也可以对不同的axis进行排序，顶层的np.sort()返回的是已排好序的数组而不是对原数组的位置排序。</p><p>对于一些NumPy的nadarray的基础集合操作如下：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>unique(x)</td><td>计算x的唯一值并排序</td></tr><tr><td>intersect1d(x,y)</td><td>计算x和y的交集，并排序</td></tr><tr><td>union1d(x,y)</td><td>计算x和y的并集，并排序</td></tr><tr><td>in1d(x,y)</td><td>计算x中的元素是否包含在y中，返回一个布尔值数组</td></tr><tr><td>setdiff1d(x,y)</td><td>差集，在x中但不在y中的x的元素</td></tr><tr><td>setxor1d(x,y)</td><td>异或集，在x或y中，当不属于x、y交集的元素</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用NumPy数组可以使你利用简单的数组表达式完成多种数据操作任务，而无须写些大量循环。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>atomic</title>
    <link href="http://example.com/jsblog/3df66479.html"/>
    <id>http://example.com/jsblog/3df66479.html</id>
    <published>2020-12-24T11:53:19.000Z</published>
    <updated>2020-12-24T11:54:34.209Z</updated>
    
    <content type="html"><![CDATA[<p>在了解原子操作之前，首先看一下内存模型。<a id="more"></a></p><p>C++程序中的所有数据都是由对象构成，对象仅仅时对C++数据的一个声明。在声明C++对象的时候需要对这个对象指定分配相应的内存空间。如果使用new在堆上分配内存空间需要调用相应的delete来将这块内存空间归还。就类似于在C语言中使用malloc/free来分配和释放内存空间一样。</p><p>无论对象时怎么样的一个类型，一个对象都会存储在一个或多个内存位置上。每一个内存为位置都是一个标量类型的对象。有四个需要牢记的原则：</p><ol><li>每一个变量都是一个对象，包括作为其成员变量的对象</li><li>每个对象至少有一个内存位置</li><li>基本类型都有确定的内存位置</li><li>相邻位域时相同内存中一部分。</li></ol><p>对于多线程应用而言，所有的数据都在内存中。当两个线程访问不同的内存位置时不会造成任何的问题，但是当程序访问同一个内存，如果只是读取那么也不会出现问题，但是要是写入的话，则有可能会发生data race。为了避免条件竞争，两个线程之间就需要一定的执行顺序。可以使用互斥量确定访问顺序；还有就是使用原子操作同步机制，决定两个线程的访问顺序。当多个线程访问同一个内存地址时，对每个访问都需要定义一个顺序。</p><p>每一个在C++程序中的对象，都有确定好的修改顺序。如果对象不是一个原子类型，必须确保同步操作使得每个线程都遵守不同变量的修改顺序，这样才不会发生data race或这未定义的行为，如果使用原子操作，那么只需交给编译器去负责就好。那么什么是原子操作呢？</p><p>原子操作是一类不可分割的操作，它的状态只能为完成或者未完成，不存在完成一半。标准原子类型可以在头文件<atomic>中找到。所有的这种类型上的操作都是原子的。标准原子类型都有一个is_lock_free()函数，这个函数允许用户决定是否直接对一个给定类型使用原子指令（x.is_lock_free()返回true），或对编译器和运行库使用内部锁（x.is_lock_free()返回false）。只有std::atomic_flag没有提供is_lock_free()成员函数。std::atomic_flag只有test_and_set()函数和clear()成员函数。在明确std::atomic_flag初始化后，做查询和设置，或者清除都很容易。</atomic></p><p>剩下的原子类型都可以通过特化std::atomic&lt;&gt;类型模板来访问，并且拥有更多的功能。下表为标准院子类型与其特化类：</p><table><thead><tr><th>原子类型</th><th>相关特化类</th></tr></thead><tbody><tr><td>atomic_bool</td><td>std::atomic<bool></bool></td></tr><tr><td>atomic_char</td><td>std::atomic<char></char></td></tr><tr><td>atomic_schar</td><td>std::atomic<signed char></signed></td></tr><tr><td>atomic_uchar</td><td>std::atomic<unsigned char></unsigned></td></tr><tr><td>atomic_int</td><td>std::atomic<int></int></td></tr><tr><td>atomic_uint</td><td>std::atomic<uint></uint></td></tr><tr><td>atomic_short</td><td>std::atomic<short></short></td></tr><tr><td>atomic_ushort</td><td>std::atomic<unsigned short></unsigned></td></tr><tr><td>atomic_long</td><td>std::atomic<long></long></td></tr><tr><td>atomic_ulong</td><td>std::atomic<unsigned long></unsigned></td></tr><tr><td>atomic_llong</td><td>std::atomic<long long></long></td></tr><tr><td>atomic_ullong</td><td>std::atomic<unsigned long></unsigned></td></tr><tr><td>atomic_char16_t</td><td>std::atomic<char16_t></char16_t></td></tr><tr><td>atomic_char32_t</td><td>std::atomic<char32_t></char32_t></td></tr><tr><td>atomic_wchar_t</td><td>std::atomic<w_char_t></w_char_t></td></tr></tbody></table><p>通常，标准原子类型不能copy和赋值，他们没有copy constructor和copy assignment函数，但是为了可以隐式转化成对应的内置类型，这些类型依旧支持赋值。可以使用load()和store()成员函数，exchange(),compare_exchange_weak()和compare_exchange_strong()。都支持符合赋值符：+=，-=，*=，/=等等。并且整型和指针还支持++和–。也有对应的成员函数。</p><h3 id="特化成员函数"><a href="#特化成员函数" class="headerlink" title="特化成员函数"></a>特化成员函数</h3><table><thead><tr><th>fetch_add</th><th>原子地将参数加到存储于原子对象的值，并返回先前保有的值   (公开成员函数)</th></tr></thead><tbody><tr><td>fetch_sub</td><td>原子地从存储于原子对象的值减去参数，并获得先前保有的值   (公开成员函数)</td></tr><tr><td>fetch_and</td><td>原子地进行参数和原子对象的值的逐位与，并获得先前保有的值   (公开成员函数)</td></tr><tr><td>fetch_or</td><td>原子地进行参数和原子对象的值的逐位或，并获得先前保有的值    (公开成员函数)</td></tr><tr><td>fetch_xor</td><td>原子地进行参数和原子对象的值的逐位异或，并获得先前保有的值    (公开成员函数)</td></tr></tbody></table><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>(构造函数)</th><th>构造原子对象   (公开成员函数)</th></tr></thead><tbody><tr><td>operator=</td><td>存储值于原子对象   (公开成员函数)</td></tr><tr><td>is_lock_free</td><td>检查原子对象是否免锁   (公开成员函数)</td></tr><tr><td>store</td><td>原子地以非原子对象替换原子对象的值   (公开成员函数)</td></tr><tr><td>load</td><td>原子地获得原子对象的值   (公开成员函数)</td></tr><tr><td>operator T</td><td>从原子对象加载值   (公开成员函数)</td></tr><tr><td>exchange</td><td>原子地替换原子对象的值并获得它先前持有的值   (公开成员函数)</td></tr><tr><td>compare_exchange_weak，ompare_exchange_strong</td><td>原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载   (公开成员函数)</td></tr><tr><td>wait(C++20)</td><td>阻塞线程直至被提醒且原子值更改   (公开成员函数)</td></tr><tr><td>notify_one(C++20)</td><td>提醒至少一个在原子对象上的等待中阻塞的线程   (公开成员函数)</td></tr><tr><td>notify_all(C++20)</td><td>提醒所有在原子对象上的等待中阻塞的线程   (公开成员函数)</td></tr></tbody></table><p>对于用户自定义类型，std::atmoic&lt;&gt;会有所限制：load()和store()(赋值和转换用户自定义类型),exchange(),compare_exchange_weak()和compare_exchange_strong()。每种类型都有一个可选内存排序参数，主要操作为以下三类：</p><p>1.Store操作，可选内存顺序:memory_order_relaxed,memory_order_release,memory_order_seq_cst</p><p>2.Load操作，可选顺序模型：memory_order_relaxed,memory_order_consume,memory_order_acquire,memory_order_seq_cst</p><p>3.Read-modify-write(读改写)操作：memory_order_relaxed,memory_order_consume,memory_order_acquire,memory_order_seq_cst，memory_order_release，memory_order_acq_rel。</p><p>所有的默认顺序为memory_order_seq_cst</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解原子操作之前，首先看一下内存模型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Qt基础</title>
    <link href="http://example.com/jsblog/759084aa.html"/>
    <id>http://example.com/jsblog/759084aa.html</id>
    <published>2020-12-23T13:35:48.000Z</published>
    <updated>2020-12-24T13:13:36.004Z</updated>
    
    <content type="html"><![CDATA[<p>Qt是一个跨平台的C++图形用户界面程序框架。<a id="more"></a>它为应用程序开发者提供建立艺术级图形用户界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p><p>在Qt程序开发过程中，除可以通过手写代码实现软件开发功能外，还可以通过Qt的GUI界面设计器进行界面的绘制与布局，该工具提供了Qt的基本可绘制窗口组件。在设计器中直接拖拽窗口部件，能够高效、快速地实现GUI界面的是设计，所见即所得。</p><p>虽然Qt库起初只是一个C++图形库，但是经过多年的演化，它已经成为一个功能丰富的通用C++类库。它集成了数据库、OpenGL、多媒体、脚本、XML、正则表达式、WebKit等模块等，其内核部分也加入了进程间通信、多线程等模块。<br>作为一个成熟的GUI框架，它定义了多种功能丰富的控件，实现了事件处理机制，可以实现普通菜单、上下文相关菜单、拖曳、可停靠工具栏等功能。Qt发明了“信号与槽”机制，各控件利用这一机制发送、处理消息，大幅降低了各控件的耦合度。其他GUI框架常常使用回调函数来实现控件之间的通信，相比之下，信号与槽机制更加安全。Qt库提供的Graphics/View框架以及Model/View框架可令程序员编写少量的代码，即可显示、编辑应用程序所要处理的数据。<br>整个Qt库支持Unicode编码，因而一个Qt应用程序可以轻易地同时显示英文、中文、日文、俄文等多种Unicode编码所支持的语言。Qt软件包还提供了诸如Qt Linguist这样的工具，便于程序员开发国际化软件产品。<br>Qt库的数据库模块内含以下数据库管理系统的驱动软件：Oracle，Microsoft SQL Server，Sybase Adaptive Server，IBM DB2，PostgreSQL，MySQL，Borland Interbase，SQLite，以及其他支持ODBC（Open Database Connectivity）接口的数据库管理系统。这意味着可以使用Qt访问各种平台上的多种数据库管理系统。除了使用SQL语句直接访问数据库外，Qt还提供了一些与数据库密切相关的控件，以简化数据的访问过程。<br>Qt库的XML模块包含了能够读取、解析、处理XML文档的类。该模块支持SAX（Simple API for XML）接口以及DOM（Document Object Model）规范。该模块易用、强大、功能完备。Qt库还允许应用程序使用正则表达式搜索、解析文档，或者在一个数据集中筛选符合某种条件的数据项。<br>Qt库集成了浏览器引擎WebKit，该引擎能够从服务器下载、解析、渲染、显示网页。由于该引擎执行速度快、运行稳定，已被用于Safari、Google Chrome等浏览器中。利用这个引擎，Qt应用程序可以在其界面中显示服务器网页。不但如此，Qt令WebKit引擎将网页的结构以及其中一些对象的细节呈现给Qt应用程序，使得程序中的其他控件可以直接和这些对象进行交互。这意味着Qt应用程序在显示网页时可以将一些Qt控件嵌入到网页中，也可以使用“信号与槽”机制，使得网页中某些对象的状态发生变化时，能够触发本地程序中某些控件的槽函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Qt是一个跨平台的C++图形用户界面程序框架。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>直方图匹配</title>
    <link href="http://example.com/jsblog/3afb3874.html"/>
    <id>http://example.com/jsblog/3afb3874.html</id>
    <published>2020-12-23T12:56:25.000Z</published>
    <updated>2020-12-23T12:58:40.409Z</updated>
    
    <content type="html"><![CDATA[<p>直方图匹配又称直方图规定化。<a id="more"></a>按照给定的直方图形状调整原先图像的直方图信息。直方图匹配使用到了直方图变换以及均衡化的思想，通过建立映射关系，使期望图像的直方图达到一种特定的形态。</p><p>直方图匹配的步骤如下:</p><ol><li><p>分别计算原图像与目标图像的累计概率分布</p></li><li><p>分别对源图像和目标图像进行直方图均衡化操作</p></li><li><p>利用映射关系使源图像直方图按照规定进行变换</p></li></ol><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\lena.jpg)&quot;</span>);</span><br><span class="line">    cv::Mat dstImage = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\starry_night.jpg)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data || ! dstImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::resize(dstImage,dstImage,srcImage.size(),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;testImage&quot;</span>,dstImage);</span><br><span class="line">    <span class="comment">//统计直方图参数</span></span><br><span class="line">    <span class="keyword">float</span> srcCdf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">float</span> dstCdf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> srcAddTemp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> dstAddTemp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> histMatchMap[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srcCdf[i] = <span class="number">0</span>;</span><br><span class="line">        dstCdf[i] = <span class="number">0</span>;</span><br><span class="line">        srcAddTemp[i] = <span class="number">0</span>;</span><br><span class="line">        dstAddTemp[i] = <span class="number">0</span>;</span><br><span class="line">        histMatchMap[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> srcSumTemp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> dstSumTemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcNPixel = srcImage.rows * srcImage.cols;</span><br><span class="line">    <span class="keyword">int</span> dstNPixel = dstImage.rows * dstImage.cols;</span><br><span class="line">    <span class="keyword">int</span> matchFlag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计像素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; srcImage.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; srcImage.cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            srcAddTemp[(<span class="keyword">int</span>)srcImage.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">            dstAddTemp[(<span class="keyword">int</span>)dstImage.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算累计概率分布</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srcSumTemp += srcAddTemp[i];</span><br><span class="line">        srcCdf[i] = srcSumTemp/ srcNPixel;</span><br><span class="line">        dstSumTemp += dstAddTemp[i];</span><br><span class="line">        dstCdf[i] = dstSumTemp/ dstNPixel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直方图匹配实现</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> minMatchPara = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (minMatchPara &gt; cv::<span class="built_in">abs</span>(srcCdf[i] - dstCdf[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                minMatchPara = cv::<span class="built_in">abs</span>(srcCdf[i] - dstCdf[j]);</span><br><span class="line">                matchFlag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        histMatchMap[i] = matchFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化匹配图像</span></span><br><span class="line">    cv::Mat HistMatchImage = cv::Mat::zeros(srcImage.size(),CV_8UC3);</span><br><span class="line">    cv::cvtColor(srcImage,HistMatchImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//映射</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HistMatchImage.rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;HistMatchImage.cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            HistMatchImage.at&lt;uchar&gt;(i,j) = histMatchMap[(<span class="keyword">int</span>)HistMatchImage.at&lt;uchar&gt;(i,j) ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     cv::imshow(<span class="string">&quot;ResultImage&quot;</span>,HistMatchImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic4.zhimg.com/80/v2-3750c19228235a3c8127e32015241493_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-dcffa77bfd687064c66ed2c19aacbd56_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1daaf40e2e58d68c25cb92bb4c935d66_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直方图匹配又称直方图规定化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>直方图比较</title>
    <link href="http://example.com/jsblog/b29ec0e5.html"/>
    <id>http://example.com/jsblog/b29ec0e5.html</id>
    <published>2020-12-23T12:55:30.000Z</published>
    <updated>2020-12-23T12:58:40.411Z</updated>
    
    <content type="html"><![CDATA[<p>直方图对比用来计算图像的直方图的相似程度。<a id="more"></a>要表示直方图的相似程度，需要使用一定的衡量对比标准。OpenCV中compareHist函数计算两个直方图的相似程度。以下为几种标准：</p><ol><li>相关系数 （method=CV_COMP_CORREL）</li></ol><p><img src="https://pic2.zhimg.com/80/v2-7c973b0a5d85de77799195974422b511_720w.jpg" alt="img"></p><p>其中</p><p><img src="https://pic2.zhimg.com/80/v2-dbafa72fb03a3099f5a1a1687034c7ad_720w.png" alt="img"></p><p>N表示bins数量</p><ol start="2"><li>卡方系数（CV_COMP_CHISQR）</li></ol><p><img src="https://pic4.zhimg.com/80/v2-f001d343d00c7e7959f8a83b456a7973_720w.jpg" alt="img"></p><ol start="3"><li>相交系数 （CV_COMP_INTERSECT）</li></ol><p><img src="https://pic4.zhimg.com/80/v2-f615c6e77b3a146f87991099b6116c9b_720w.png" alt="img"></p><ol start="4"><li>巴式系数 （CV_COMP_BHATTACHARYYA,CV_COMP_HELLINGER）</li></ol><p><img src="https://pic3.zhimg.com/80/v2-851b770a936df2fc70f655997d69201e_720w.jpg" alt="img"></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算两幅图像的直方图相似度</span></span><br><span class="line">    cv::Mat srcImage1 = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\aero1.jpg)&quot;</span>);</span><br><span class="line">    cv::Mat srcImage2 = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\aero3.jpg)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage1.data || !srcImage2.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将图像转换到hsv色彩空间</span></span><br><span class="line">    cv::Mat hsv_image1,hsv_image2;</span><br><span class="line">    cv::cvtColor(srcImage1,hsv_image1,cv::COLOR_BGR2HSV);</span><br><span class="line">    cv::cvtColor(srcImage2,hsv_image2,cv::COLOR_BGR2HSV);</span><br><span class="line">    <span class="comment">//计算每幅图像的直方图</span></span><br><span class="line">    <span class="keyword">int</span> h_bins = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> s_bins = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> HistSize[] = &#123;h_bins,s_bins&#125;;</span><br><span class="line">    <span class="keyword">float</span> h_ranges[] = &#123;<span class="number">0</span>,<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> s_ranges[] = &#123;<span class="number">0</span>,<span class="number">180</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> *ranges[] = &#123;h_ranges,s_ranges&#125;;</span><br><span class="line">    <span class="keyword">int</span> channels[] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cv::MatND hist1,hist2;</span><br><span class="line">    cv::calcHist(&amp;hsv_image1,<span class="number">1</span>,channels,cv::Mat(),hist1,<span class="number">2</span>,HistSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::normalize(hist1,hist1,<span class="number">0</span>,<span class="number">1</span>,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line">    cv::calcHist(&amp;hsv_image2,<span class="number">1</span>,channels,cv::Mat(),hist2,<span class="number">2</span>,HistSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::normalize(hist2,hist2,<span class="number">0</span>,<span class="number">1</span>,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不同的直方图比较算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> method = i;</span><br><span class="line">        <span class="keyword">double</span> coefficient = cv::compareHist(hist1,hist2,method);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;method &quot;</span> &lt;&lt;i &lt;&lt; <span class="string">&quot; the coefficient is &quot;</span> &lt;&lt; coefficient &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage1&quot;</span>,srcImage1);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage2&quot;</span>,srcImage2);</span><br><span class="line">    cv::waitKey();</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic4.zhimg.com/80/v2-94da51fb0aeb49516bc6165434fd2e87_720w.jpg" alt="img"></p><p>图片显示：</p><p><img src="https://pic3.zhimg.com/80/v2-ab94d457dc8500c7ef4129b459a2b5fe_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-bebff0cde4b9f4f8f6ae23e90eb74305_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直方图对比用来计算图像的直方图的相似程度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>直方图均衡化</title>
    <link href="http://example.com/jsblog/ed8ed8eb.html"/>
    <id>http://example.com/jsblog/ed8ed8eb.html</id>
    <published>2020-12-23T12:54:52.000Z</published>
    <updated>2020-12-23T12:58:40.410Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们很难观察一幅非常亮或暗的图像的细节信息，因此对于差异较大的图像，我们可以尝试改变其图像灰度分布来使图像灰度阶分布尽量均匀，进而增强图像细节信息。<a id="more"></a>直方图均衡是拉伸各个像素分布来实现图像增强的，以累计分布函数变换基础，通过特定映射转换成一种更宽的分布，其核心就是把灰度分布映射成均匀分布</p><p>直方图均衡的目的是利用动态范围内的所有灰度阶，因此对于映射函数y=f(x),要求x在（0,1）的灰度是连续的，每一个元素都能得到相应的元素一一对应可得到下式：</p><p>p(x)dx = p(y)dy</p><p>对于均衡化的输出图像p(y) = 1，则同时积分得</p><p><img src="https://pic4.zhimg.com/80/v2-a36ecb40e3de909fde4e7712ec4ead73_720w.png" alt="img"></p><p>即映射函数为：</p><p>y = f(x) = p(x) – p(0)</p><p>直方图均衡化算法的步骤如下：</p><p>（1） 获取输入图像的直方图</p><p>（2） 求累计分布直方图，构建查找表</p><p>（3） 通过图像映射，计算新的图像像素分布</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">&quot;E:/CodeBlocks/data/lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat grayImage,histImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::equalizeHist(grayImage,histImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;grayImage&quot;</span>,grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;histImage&quot;</span>,histImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://pic4.zhimg.com/80/v2-5acdaf808bdf585165830acd1c26d817_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-679d3c40ab103551f5956c279b43029d_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常我们很难观察一幅非常亮或暗的图像的细节信息，因此对于差异较大的图像，我们可以尝试改变其图像灰度分布来使图像灰度阶分布尽量均匀，进而增强图像细节信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>C++之RAII</title>
    <link href="http://example.com/jsblog/44da37.html"/>
    <id>http://example.com/jsblog/44da37.html</id>
    <published>2020-12-23T12:52:56.000Z</published>
    <updated>2020-12-23T12:58:40.385Z</updated>
    
    <content type="html"><![CDATA[<p>以前总是听过学习C++ 不知道RAII那就是不合格的c++程序员，那什么是RAII呢？<a id="more"></a>所谓RAII机制就是（Resource Acquisition Is Initialization，资源获取即初始化），在类的构造里申请资源，然后使用资源，最后在析构函数中释放资源。在计算机中有很多种资源，内存是我们经常使用的资源，此外还有文件描述符，socket以及数据库连接等，在程序中申请这些资源后利用完必须归还，否则会造成未定义的行为。如果对象在栈上创建，那么RAII会正常工作，在离开作用域的时候释放资源。如果是使用new操作符在堆上创建对象，那么就需要程序员手动delete对象，如果程序因为某些错误而无法delete对象，则有可能对系统造成未定义的行为，内存等部分资源就会永久丢失。</p><p>未使用RAII的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.lock();                    <span class="comment">// 请求互斥体</span></span><br><span class="line">    f();                         <span class="comment">// 若 f() 抛异常，则互斥体永远不被释放</span></span><br><span class="line">    <span class="keyword">if</span>(!everything_ok()) <span class="keyword">return</span>; <span class="comment">// 提早返回，互斥体永远不被释放</span></span><br><span class="line">    m.unlock();                  <span class="comment">// 若 bad() 抵达此语句，互斥才被释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>无论那一步操作失败都需要自己释放资源，如果使用了RAII则不需要自己关闭文件，在离开函数的时候，会自动释放文件描述符。</p><p>使用RAII机制的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// RAII类：互斥体的请求即是初始化</span></span><br><span class="line">    f();                               <span class="comment">// 若 f() 抛异常，则释放互斥体</span></span><br><span class="line">    <span class="keyword">if</span>(!everything_ok()) <span class="keyword">return</span>;       <span class="comment">// 提早返回，互斥体被释放</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>RAII的总结如下（cppreference）：</p><ul><li>将每个资源封装入一个类，其中</li></ul><p>· 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</p><p>· 析构函数释放资源并决不抛出异常；</p><ul><li>始终经由 RAII 类的实例使用满足要求的资源，该资源</li></ul><p>· 自身拥有自动存储期或临时生存期，或</p><p>· 具有与自动或临时对象的生存期绑定的生存期</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前总是听过学习C++ 不知道RAII那就是不合格的c++程序员，那什么是RAII呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>宏参数#和##</title>
    <link href="http://example.com/jsblog/b039a98a.html"/>
    <id>http://example.com/jsblog/b039a98a.html</id>
    <published>2020-12-23T12:52:10.000Z</published>
    <updated>2020-12-23T12:58:40.403Z</updated>
    
    <content type="html"><![CDATA[<p>作用：</p><p>使用#把宏参数变成一个字符串，使用##则是把两个红参数连接在一起 <a id="more"></a></p><p>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Str(var) #var</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Str(var) _Str(var)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _StringCat(str1) 123##str1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StringCat(str1) _StringCat(str1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,Str(<span class="number">123456</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,StringCat(<span class="number">123</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:当宏参数是另一个宏的时候，需要注意的是宏定义例有用“#”或“##”的地方宏参数是不会再展开。即只有当前的宏生效，参数里的宏不会生效。解决的办法就是增加新的宏定义做一个转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作用：&lt;/p&gt;
&lt;p&gt;使用#把宏参数变成一个字符串，使用##则是把两个红参数连接在一起&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>printf格式化输出</title>
    <link href="http://example.com/jsblog/67b33fcc.html"/>
    <id>http://example.com/jsblog/67b33fcc.html</id>
    <published>2020-12-23T12:51:26.000Z</published>
    <updated>2020-12-23T12:58:40.407Z</updated>
    
    <content type="html"><![CDATA[<p>学着学着好像忘记了好多知识， 回想一哈，原来不是自己忘记了而是自己从来没有认真的看过，用过。<a id="more"></a>只有等到用的时候才去百度一下。有时候用到去百度又会太浪费时间，所以现在纪录一下，方便自己的使用。</p><p>printf函数原型如下：</p><p>int printf(const char* format,…);</p><p>其中format表示两部分内容：</p><ol><li><ol><li>正常字符，直接输出</li><li>格式化字符以 “%”开始，用来表示输出内容格式。</li></ol></li></ol><p>格式化字符串的模板是：%[输出标志][输出最小宽度][.小数点位数][长度]类型</p><p>其中输出标志：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>“-”</td><td>左对齐</td></tr><tr><td>“+”</td><td>右对齐</td></tr><tr><td>“ ”</td><td>空格，符号为正显示空格，为负显示负号“-”</td></tr><tr><td>“#”</td><td>对c,s,d,u无影响，对o类输出前加缀为o,对x类，在输出前缀加0x，对e,g,f当结果有小数时给出小数点</td></tr></tbody></table><p>最小宽度 m：实际长度大于m时按照实际输出，实际长度小于m时，无标志则左边填充空格。若为“%-md”则右边填充到m长度为止。</p><p>小数点：</p><p>“%m.nf”：　　输出浮点数，m为宽度，n为小数点右边数位</p><p>“%m.ns”：　　输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n</p><p>长度：h为短整型，l为长整型</p><p>类型：</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%a,%A</td><td>浮点数、十六进制数字和p-计数法</td></tr><tr><td>%c</td><td>一个字符</td></tr><tr><td>%C</td><td>一个ISO宽字符</td></tr><tr><td>%d</td><td>有符号十进制整数（int）(%ld ，%Ld为：长整型数据，%hd：短整型数)</td></tr><tr><td>%e,%E</td><td>浮点数，e-计数法，E-计数法</td></tr><tr><td>%f</td><td>单精度浮点数</td></tr><tr><td>%g，%G</td><td>根据数值不同自动选择%f或%e</td></tr><tr><td>%i</td><td>有符号十进制数（与%d相同）</td></tr><tr><td>%o</td><td>无符号八进制整数</td></tr><tr><td>%p</td><td>指针</td></tr><tr><td>%s</td><td>对应字符串char*（%s = %hs = %hS 输出 窄字符）</td></tr><tr><td>%S</td><td>对应宽字符串WCAHR*（%ws = %S 输出宽字符串</td></tr><tr><td>%u</td><td>无符号十进制整数(unsigned int)</td></tr><tr><td>%x,%X</td><td>使用十六进制数字0xf的无符号十六进制整</td></tr><tr><td>%%</td><td>打印一个%号</td></tr><tr><td>%I64d</td><td>用于int64 或者 long long</td></tr><tr><td>%I64u</td><td>用于uint64 或者unsigned long long</td></tr><tr><td>%I64x</td><td>用于64 位16进制数字</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;学着学着好像忘记了好多知识， 回想一哈，原来不是自己忘记了而是自己从来没有认真的看过，用过。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
</feed>
