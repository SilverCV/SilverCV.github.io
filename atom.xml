<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-20T04:20:59.402Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>av_seek_frame</title>
    <link href="http://example.com/jsblog/681275ed.html"/>
    <id>http://example.com/jsblog/681275ed.html</id>
    <published>2020-12-20T04:20:15.000Z</published>
    <updated>2020-12-20T04:20:59.402Z</updated>
    
    <content type="html"><![CDATA[<p>使用av_seek_frame截取视频，<a id="more"></a>首先看一下av_seek_frame()的函数原型,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_seek_frame</span><span class="params">(AVFormatContext *s, <span class="keyword">int</span> stream_index, <span class="keyword">int64_t</span> timestamp,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>s: AVFormatContext类型的多媒体文件句柄</p><p>stream_index : int类型表示要进行操作的流索引</p><p>timestamp: int64_t类型的时间戳，表示要跳转到的时间位置</p><p>flags : 跳转方法，主要有一下几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_BACKWARD 1 <span class="comment">///&lt; seek backward seek到timestamp之前的最近关键帧</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_BYTE 2 <span class="comment">///&lt; seeking based on position in bytes 基于字节位置的跳转</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_ANY 4 <span class="comment">///&lt; seek to any frame, even non-keyframes 跳转到任意帧，不一定是关键帧</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_FRAME 8 <span class="comment">///&lt; seeking based on frame number 基于帧数量的跳转</span></span></span><br></pre></td></tr></table></figure><p>函数执行成功 返回值&gt;=0</p><p>在执行跳转之前使用AV_TIME_BASE进行一个时间戳的转换。</p><p>在代码中使用到了boost::program_options对命令行参数进行操作，如果要编译成功需要使用boost::program_options,如果不想使用可以直接将那部分代码删除，然后编译连接的时候要链接到ffmpeg lib即可。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">namespace</span> opt = boost::program_options;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;av_register_all();av_log_set_level(AV_LOG_INFO);&#125;</span><br><span class="line"><span class="comment">//parse command line</span></span><br><span class="line"><span class="function">opt::variables_map <span class="title">getvm</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="comment">//find the media info in input file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_streaminfo</span><span class="params">(AVFormatContext* *s,<span class="keyword">const</span> <span class="keyword">char</span> *input)</span></span>;</span><br><span class="line"><span class="comment">//process the input time</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">getStartTime</span><span class="params">(<span class="keyword">const</span> AVStream *in,<span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="comment">//set output format context and return out stream</span></span><br><span class="line"><span class="function">AVStream* <span class="title">set_output_format_context</span><span class="params">(<span class="keyword">const</span> AVStream* in,AVFormatContext **s,<span class="keyword">const</span> <span class="keyword">char</span> *output)</span></span>;</span><br><span class="line"><span class="comment">// seek start time and save it to output file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekToAndSave</span><span class="params">(AVFormatContext *ifmt_ctx,AVStream *in_stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                   AVFormatContext *ofmt_ctx,AVStream *out_stream,<span class="keyword">int</span> index,<span class="keyword">int64_t</span> starttime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    opt::variables_map vm = getvm(argc,argv);</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input = vm[<span class="string">&quot;input&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;().c_str();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output = vm[<span class="string">&quot;output&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;().c_str();</span><br><span class="line">    AVFormatContext *ifmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="comment">//find stream info</span></span><br><span class="line">    find_streaminfo(&amp;ifmt_ctx,input);</span><br><span class="line">    <span class="comment">//find video stream index</span></span><br><span class="line">    <span class="keyword">int</span> video_stream_index = <span class="number">-1</span>;</span><br><span class="line">    video_stream_index = av_find_best_stream(ifmt_ctx,AVMEDIA_TYPE_VIDEO,<span class="number">-1</span>,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (video_stream_index)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find video stream&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVStream *in_strem = ifmt_ctx-&gt;streams[video_stream_index];</span><br><span class="line">    <span class="comment">//find the seek time</span></span><br><span class="line">    <span class="keyword">int</span> seconds = vm.count(<span class="string">&quot;time&quot;</span>) ? vm[<span class="string">&quot;time&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> startTime = getStartTime(in_strem,seconds);</span><br><span class="line">    <span class="comment">//the start time must less than the total length</span></span><br><span class="line">    <span class="keyword">if</span> (startTime &gt; in_strem-&gt;duration)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;start time must less than the total time&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set output avformatcontext</span></span><br><span class="line">    AVFormatContext *ofmt_ctx = avformat_alloc_context();</span><br><span class="line">    AVStream *out_stream = set_output_format_context(in_strem,&amp;ofmt_ctx,output);</span><br><span class="line">    <span class="keyword">if</span> (avio_open(&amp;ofmt_ctx-&gt;pb,output,AVIO_FLAG_WRITE) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to open output file : %s&quot;</span>,output);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//seek and  save</span></span><br><span class="line">    seekToAndSave(ifmt_ctx,in_strem,ofmt_ctx,out_stream,video_stream_index,startTime);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    avio_close(ofmt_ctx-&gt;pb);</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVStream* <span class="title">set_output_format_context</span><span class="params">(<span class="keyword">const</span> AVStream* in,AVFormatContext **s,<span class="keyword">const</span> <span class="keyword">char</span> *output)</span></span>&#123;</span><br><span class="line">    assert(in != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *s = avformat_alloc_context();</span><br><span class="line">    &#125;</span><br><span class="line">    AVOutputFormat *oformat = av_guess_format(<span class="literal">NULL</span>,output,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (oformat == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find the oformat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (*s)-&gt;oformat = oformat;</span><br><span class="line">    <span class="keyword">if</span> (avformat_alloc_output_context2(s,oformat,oformat-&gt;name,output) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to alloc output context&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(in-&gt;codecpar-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find codec &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AVStream *out_stream = avformat_new_stream(*s,pCodec);</span><br><span class="line">    <span class="keyword">if</span> (out_stream == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to create out stream&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avcodec_parameters_copy(out_stream-&gt;codecpar,in-&gt;codecpar) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to copy codec info&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    out_stream-&gt;codec-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)&#123;</span><br><span class="line">        out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dump info</span></span><br><span class="line">    av_dump_format(*s,<span class="number">0</span>,output,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> out_stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">getStartTime</span><span class="params">(<span class="keyword">const</span> AVStream *in,<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> startTime = seconds * AV_TIME_BASE;</span><br><span class="line">    <span class="keyword">int64_t</span> target_time = av_rescale_q(startTime,AV_TIME_BASE_Q,in-&gt;time_base);</span><br><span class="line">    <span class="keyword">return</span> target_time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_streaminfo</span><span class="params">(AVFormatContext* *s,<span class="keyword">const</span> <span class="keyword">char</span> *input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(s,input,<span class="literal">NULL</span>,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to open %s&quot;</span>,input);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(*s,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find stream info&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dump the information to console</span></span><br><span class="line">    av_dump_format(*s,<span class="number">0</span>,input,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">opt::variables_map <span class="title">getvm</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">   <span class="comment">//step 1 create a description</span></span><br><span class="line">   <span class="function">opt::options_description <span class="title">descr</span><span class="params">(<span class="string">&quot;All options&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//step 2 add options</span></span><br><span class="line">   descr.add_options()</span><br><span class="line">   (<span class="string">&quot;time,t&quot;</span>,opt::value&lt;<span class="keyword">int</span>&gt;(),<span class="string">&quot;start time&quot;</span>)</span><br><span class="line">   (<span class="string">&quot;input,i&quot;</span>,opt::value&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(),<span class="string">&quot;input file&quot;</span>)</span><br><span class="line">   (<span class="string">&quot;output,o&quot;</span>,opt::value&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(),<span class="string">&quot;output file&quot;</span>)</span><br><span class="line">   (<span class="string">&quot;help,h&quot;</span>,<span class="string">&quot;use guide&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; descr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//step 3 create variables_map</span></span><br><span class="line">   opt::variables_map vm;</span><br><span class="line">   opt::store(opt::parse_command_line(argc,argv,descr),vm);</span><br><span class="line">   opt::notify(vm);</span><br><span class="line">   <span class="keyword">if</span> (!vm.count(<span class="string">&quot;input&quot;</span>) || !vm.count(<span class="string">&quot;output&quot;</span>))&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; miss input file or output file&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (vm.count(<span class="string">&quot;help&quot;</span>))&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; descr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekToAndSave</span><span class="params">(AVFormatContext *ifmt_ctx,AVStream *in_stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                   AVFormatContext *ofmt_ctx,AVStream *out_stream,<span class="keyword">int</span> index,<span class="keyword">int64_t</span> starttime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     assert(ifmt_ctx != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_stream != <span class="literal">NULL</span>);</span><br><span class="line">     assert(ofmt_ctx != <span class="literal">NULL</span>);</span><br><span class="line">     assert(out_stream != <span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span>(avformat_write_header(ofmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to write header&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (av_seek_frame(ifmt_ctx,index,starttime,AVSEEK_FLAG_BACKWARD) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to seek time&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     AVFrame *pframe = av_frame_alloc();</span><br><span class="line">     AVPacket *pkt = av_packet_alloc();</span><br><span class="line">     av_init_packet(pkt);</span><br><span class="line">     <span class="keyword">while</span>(av_read_frame(ifmt_ctx,pkt) &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == index)&#123;</span><br><span class="line">            pkt-&gt;pts = av_rescale_q_rnd(pkt-&gt;pts,in_stream-&gt;time_base,out_stream-&gt;time_base,<span class="keyword">static_cast</span>&lt;AVRounding&gt;(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt-&gt;dts = av_rescale_q_rnd(pkt-&gt;dts,in_stream-&gt;time_base,out_stream-&gt;time_base,<span class="keyword">static_cast</span>&lt;AVRounding&gt;(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt-&gt;duration = av_rescale_q(pkt-&gt;duration,in_stream-&gt;time_base,out_stream-&gt;time_base);</span><br><span class="line">            pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (av_interleaved_write_frame(ofmt_ctx,pkt) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to write frame&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            av_packet_unref(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(av_write_trailer(ofmt_ctx) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to write trailer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      av_frame_free(&amp;pframe);</span><br><span class="line">      av_packet_free(&amp;pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用av_seek_frame截取视频，&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>FFmpegPCM播转AAC</title>
    <link href="http://example.com/jsblog/1c43d3bb.html"/>
    <id>http://example.com/jsblog/1c43d3bb.html</id>
    <published>2020-12-20T04:18:46.000Z</published>
    <updated>2020-12-20T04:20:59.400Z</updated>
    
    <content type="html"><![CDATA[<p>要将PCM数据编码为AAC的格式，<a id="more"></a>首先了解一下什么是PCM数据，所谓PCM数据就是未被压缩的音频原始数据，而aac,mp3等都是被有损压缩后的数据。未被压缩的pcm数据所占用的储存空间比较大，而被压缩后的PCM数据所占用的空间会比较小，下面我们看一下所需要设置的压缩参数。</p><p>\1. sample_rate : 采样率，也就是每秒采集多少次声音样本</p><p>\2. channels : 声道的数目，有单通道和双通道</p><p>\3. sample_fmt : 采样的格式</p><p>\4. channel_layout: 声道布局</p><p>5.bit_rate : 比特率</p><p>需要将这些数据为AVCodecContext设置。</p><p>主要流程如下：</p><p>1.初始化输出环境：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *ofmt_ctx = avformat_alloc_context();</span><br><span class="line">  AVOutputFormat *oformat = av_guess_format(<span class="literal">NULL</span>,output,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (oformat==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find the output format\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avformat_alloc_output_context2(&amp;ofmt_ctx,oformat,oformat-&gt;name,output) &lt;<span class="number">0</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to alloc output context\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVStream *out_stream = avformat_new_stream(ofmt_ctx,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (out_stream == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to create new stream\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2.设置AAC编码格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *pCodecCtx = out_stream-&gt;codec;</span><br><span class="line"> pCodecCtx-&gt;codec_id = oformat-&gt;audio_codec;</span><br><span class="line"> pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_AUDIO;</span><br><span class="line"> pCodecCtx-&gt;sample_fmt = AV_SAMPLE_FMT_FLTP; <span class="comment">//其他会出错</span></span><br><span class="line"> pCodecCtx-&gt;channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"> pCodecCtx-&gt;channels = av_get_channel_layout_nb_channels(pCodecCtx-&gt;channel_layout);</span><br><span class="line"> pCodecCtx-&gt;sample_rate = <span class="number">44100</span>;</span><br><span class="line"> pCodecCtx-&gt;bit_rate = <span class="number">128000</span>;</span><br></pre></td></tr></table></figure><p>3.打开编码器并向输出文件中写入文件头信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *pCodec = avcodec_find_encoder(pCodecCtx-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line">  av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find codec\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (avcodec_open2(pCodecCtx,pCodec,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to open codec\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">av_dump_format(ofmt_ctx,<span class="number">0</span>,output,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (avio_open(&amp;ofmt_ctx-&gt;pb,output,AVIO_FLAG_WRITE) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to open output\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (avformat_write_header(ofmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to write header&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.设置一些参数，需要将pcm raw data压缩为aac格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AVFrame *pframe = av_frame_alloc();</span><br><span class="line"> pframe-&gt;channels = pCodecCtx-&gt;channels;</span><br><span class="line"> pframe-&gt;format = pCodecCtx-&gt;sample_fmt;</span><br><span class="line"> pframe-&gt;nb_samples = pCodecCtx-&gt;frame_size;</span><br><span class="line"> <span class="comment">//从文件中读取原始数据，缓冲区</span></span><br><span class="line"> <span class="keyword">int</span> size = av_samples_get_buffer_size(<span class="literal">NULL</span>,pCodecCtx-&gt;channels,pCodecCtx-&gt;frame_size,pCodecCtx-&gt;sample_fmt,<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span>*)av_malloc(size);</span><br><span class="line"> avcodec_fill_audio_frame(pframe,pCodecCtx-&gt;channels,pCodecCtx-&gt;sample_fmt,(<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)out_buffer,size,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//新版本需要使用到转换参数，将读取的数据转换成输出的编码格式</span></span><br><span class="line"> <span class="keyword">uint8_t</span>  **data = (<span class="keyword">uint8_t</span>**)av_calloc( pCodecCtx-&gt;channels,<span class="keyword">sizeof</span>(*data) );</span><br><span class="line"> av_samples_alloc(data,<span class="literal">NULL</span>,pCodecCtx-&gt;channels,pCodecCtx-&gt;frame_size,pCodecCtx-&gt;sample_fmt,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> SwrContext *pSwrCtx  = swr_alloc();</span><br><span class="line"> swr_alloc_set_opts(pSwrCtx,pCodecCtx-&gt;channel_layout,pCodecCtx-&gt;sample_fmt,pCodecCtx-&gt;sample_rate,</span><br><span class="line">     pCodecCtx-&gt;channel_layout,AV_SAMPLE_FMT_S16,<span class="number">44100</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"> swr_init(pSwrCtx);</span><br><span class="line"> <span class="comment">//需要使用AVPacket进行压缩储存</span></span><br><span class="line"> AVPacket *pkt = av_packet_alloc();</span><br><span class="line"> av_new_packet(pkt,size);</span><br><span class="line"> pkt-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line"> pkt-&gt;size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>5.读取pcm raw data并压缩为aac格式的数据写入输出文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//读取的长度要 和原始数据的采样率，采样格式以及通道有关 如果size设置的不对，会导致音频错误</span></span><br><span class="line">    size = pframe-&gt;nb_samples * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16) * pframe-&gt;channels;</span><br><span class="line">    <span class="keyword">if</span> (fread(out_buffer,<span class="number">1</span>,size,fp) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;fail to read raw data\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (feof(fp))&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swr_convert(pSwrCtx,data,pCodecCtx-&gt;frame_size,pframe-&gt;data,pframe-&gt;nb_samples);</span><br><span class="line">    <span class="comment">//转换后的数据大小与采样率和采样格式有关</span></span><br><span class="line">    size = pCodecCtx-&gt;frame_size * av_get_bytes_per_sample(pCodecCtx-&gt;sample_fmt);</span><br><span class="line">    <span class="built_in">memcpy</span>(pframe-&gt;data[<span class="number">0</span>],data[<span class="number">0</span>],size);</span><br><span class="line">    <span class="built_in">memcpy</span>(pframe-&gt;data[<span class="number">1</span>],data[<span class="number">1</span>],size);</span><br><span class="line">    pframe-&gt;pts = count * <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//编码写入</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_send_frame(pCodecCtx,pframe) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;fail to send frame\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取编码好的数据</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_receive_packet(pCodecCtx,pkt)  &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      pkt-&gt;stream_index = out_stream-&gt;index;</span><br><span class="line">      av_log(<span class="literal">NULL</span>,AV_LOG_INFO,<span class="string">&quot;write %d frame\n&quot;</span>,count);</span><br><span class="line">      av_write_frame(ofmt_ctx,pkt);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    av_packet_unref(pkt);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>\6. 刷新编码器，将编码器中的数据写入到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flush_encoder</span><span class="params">(AVFormatContext *ofmt_ctx,<span class="keyword">int</span> stream_index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(ofmt_ctx-&gt;streams[stream_index]-&gt;codec-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DELAY))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> got_fame = <span class="number">0</span>;</span><br><span class="line">  AVPacket *pkt = av_packet_alloc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    pkt-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    pkt-&gt;size = <span class="number">0</span>;</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    <span class="keyword">int</span> ret = avcodec_encode_audio2(ofmt_ctx-&gt;streams[stream_index]-&gt;codec,pkt,<span class="literal">NULL</span>,&amp;got_fame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (got_fame == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mux the frame data</span></span><br><span class="line">    ret = av_write_frame(ofmt_ctx,pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  av_packet_free(&amp;pkt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.写入文件尾部信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_write_trailer(ofmt_ctx);</span><br></pre></td></tr></table></figure><p>8.释放所有申请的资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">av_packet_free(&amp;pkt);</span><br><span class="line">swr_free(&amp;pSwrCtx);</span><br><span class="line">av_free(out_buffer);</span><br><span class="line">av_frame_free(&amp;pframe);</span><br><span class="line"></span><br><span class="line">avio_close(ofmt_ctx-&gt;pb);</span><br><span class="line">avformat_free_context(ofmt_ctx);</span><br></pre></td></tr></table></figure><p>完整代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flush_encoder</span><span class="params">(AVFormatContext *ofmt_ctx,<span class="keyword">int</span> stream_index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(ofmt_ctx-&gt;streams[stream_index]-&gt;codec-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DELAY))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> got_fame = <span class="number">0</span>;</span><br><span class="line">  AVPacket *pkt = av_packet_alloc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    pkt-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    pkt-&gt;size = <span class="number">0</span>;</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    <span class="keyword">int</span> ret = avcodec_encode_audio2(ofmt_ctx-&gt;streams[stream_index]-&gt;codec,pkt,<span class="literal">NULL</span>,&amp;got_fame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (got_fame == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = av_write_frame(ofmt_ctx,pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  av_packet_free(&amp;pkt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage : Encode &lt;input pcm data&gt; &lt;output aac&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *input = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *output = argv[<span class="number">2</span>];</span><br><span class="line">  av_register_all();</span><br><span class="line">  AVFormatContext *ofmt_ctx = avformat_alloc_context();</span><br><span class="line">  AVOutputFormat *oformat = av_guess_format(<span class="literal">NULL</span>,output,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (oformat==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find the output format\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avformat_alloc_output_context2(&amp;ofmt_ctx,oformat,oformat-&gt;name,output) &lt;<span class="number">0</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to alloc output context\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVStream *out_stream = avformat_new_stream(ofmt_ctx,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (out_stream == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to create new stream\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVCodecContext *pCodecCtx = out_stream-&gt;codec;</span><br><span class="line">  pCodecCtx-&gt;codec_id = oformat-&gt;audio_codec;</span><br><span class="line">  pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_AUDIO;</span><br><span class="line">  pCodecCtx-&gt;sample_fmt = AV_SAMPLE_FMT_FLTP; <span class="comment">//其他会出错</span></span><br><span class="line">  pCodecCtx-&gt;channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">  pCodecCtx-&gt;channels = av_get_channel_layout_nb_channels(pCodecCtx-&gt;channel_layout);</span><br><span class="line">  pCodecCtx-&gt;sample_rate = <span class="number">44100</span>;</span><br><span class="line">  pCodecCtx-&gt;bit_rate = <span class="number">128000</span>;</span><br><span class="line"></span><br><span class="line">  AVCodec *pCodec = avcodec_find_encoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">  <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to find codec\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avcodec_open2(pCodecCtx,pCodec,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to open codec\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  av_dump_format(ofmt_ctx,<span class="number">0</span>,output,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (avio_open(&amp;ofmt_ctx-&gt;pb,output,AVIO_FLAG_WRITE) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to open output\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avformat_write_header(ofmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>,AV_LOG_ERROR,<span class="string">&quot;fail to write header&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FILE *fp = fopen(input,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fail to open file\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVFrame *pframe = av_frame_alloc();</span><br><span class="line">  pframe-&gt;channels = pCodecCtx-&gt;channels;</span><br><span class="line">  pframe-&gt;format = pCodecCtx-&gt;sample_fmt;</span><br><span class="line">  pframe-&gt;nb_samples = pCodecCtx-&gt;frame_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size = av_samples_get_buffer_size(<span class="literal">NULL</span>,pCodecCtx-&gt;channels,pCodecCtx-&gt;frame_size,pCodecCtx-&gt;sample_fmt,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span>*)av_malloc(size);</span><br><span class="line">  avcodec_fill_audio_frame(pframe,pCodecCtx-&gt;channels,pCodecCtx-&gt;sample_fmt,(<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)out_buffer,size,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//新版本需要使用到转换参数，将读取的数据转换成输出的编码格式</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  **data = (<span class="keyword">uint8_t</span>**)av_calloc( pCodecCtx-&gt;channels,<span class="keyword">sizeof</span>(*data) );</span><br><span class="line">  av_samples_alloc(data,<span class="literal">NULL</span>,pCodecCtx-&gt;channels,pCodecCtx-&gt;frame_size,pCodecCtx-&gt;sample_fmt,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  SwrContext *pSwrCtx  = swr_alloc();</span><br><span class="line">  swr_alloc_set_opts(pSwrCtx,pCodecCtx-&gt;channel_layout,pCodecCtx-&gt;sample_fmt,pCodecCtx-&gt;sample_rate,</span><br><span class="line">      pCodecCtx-&gt;channel_layout,AV_SAMPLE_FMT_S16,<span class="number">44100</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">  swr_init(pSwrCtx);</span><br><span class="line">  AVPacket *pkt = av_packet_alloc();</span><br><span class="line">  av_new_packet(pkt,size);</span><br><span class="line">  pkt-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">  pkt-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//读取的长度要 和原始数据的采样率，采样格式以及通道有关 如果size设置的不对，会导致音频错误</span></span><br><span class="line">    size = pframe-&gt;nb_samples * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16) * pframe-&gt;channels;</span><br><span class="line">    <span class="keyword">if</span> (fread(out_buffer,<span class="number">1</span>,size,fp) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;fail to read raw data\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (feof(fp))&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    swr_convert(pSwrCtx,data,pCodecCtx-&gt;frame_size,pframe-&gt;data,pframe-&gt;nb_samples);</span><br><span class="line">    <span class="comment">//转换后的数据大小与采样率和采样格式有关</span></span><br><span class="line">    size = pCodecCtx-&gt;frame_size * av_get_bytes_per_sample(pCodecCtx-&gt;sample_fmt);</span><br><span class="line">    <span class="built_in">memcpy</span>(pframe-&gt;data[<span class="number">0</span>],data[<span class="number">0</span>],size);</span><br><span class="line">    <span class="built_in">memcpy</span>(pframe-&gt;data[<span class="number">1</span>],data[<span class="number">1</span>],size);</span><br><span class="line">    pframe-&gt;pts = count * <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//编码写入</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_send_frame(pCodecCtx,pframe) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;fail to send frame\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取编码好的数据</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_receive_packet(pCodecCtx,pkt)  &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      pkt-&gt;stream_index = out_stream-&gt;index;</span><br><span class="line">      av_log(<span class="literal">NULL</span>,AV_LOG_INFO,<span class="string">&quot;write %d frame\n&quot;</span>,count);</span><br><span class="line">      av_write_frame(ofmt_ctx,pkt);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    av_packet_unref(pkt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//刷新编码器的缓冲区</span></span><br><span class="line">  flush_encoder(ofmt_ctx,out_stream-&gt;index);</span><br><span class="line"></span><br><span class="line">  av_packet_free(&amp;pkt);</span><br><span class="line">  swr_free(&amp;pSwrCtx);</span><br><span class="line">  av_free(out_buffer);</span><br><span class="line">  av_frame_free(&amp;pframe);</span><br><span class="line">  av_write_trailer(ofmt_ctx);</span><br><span class="line">  avio_close(ofmt_ctx-&gt;pb);</span><br><span class="line">  avformat_free_context(ofmt_ctx);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我使用此代码将pcm转换到mp3的时候会出错，可能是我自己编译的ffmpeg有问题，不支持mp3格式的压缩。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要将PCM数据编码为AAC的格式，&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg+SDL2播放视频</title>
    <link href="http://example.com/jsblog/e661981a.html"/>
    <id>http://example.com/jsblog/e661981a.html</id>
    <published>2020-12-20T04:17:42.000Z</published>
    <updated>2020-12-20T04:20:59.399Z</updated>
    
    <content type="html"><![CDATA[<p>从开始学习到现在自己制作使用SDL2播放视频，好像经历了一个月的时间，<a id="more"></a>终于可以不用去看别人的代码，从而自己实现一个使用FFMPEG解码，使用SDL2播放视频的程序了，一切付出都是有收获的，当然主要还是参考了雷神的博客，以前自己看了几遍也写过一遍，但是对流程代码的理解很浅，仅仅属于ctrl+c,ctrl+v的操作，现在不需要ctrl+c,ctrl+v,可以自己从头写出来一个简单的播放器了。(这里设置播放的数据为RGB)</p><p>流程图如下：</p><p>解码视频流程图：</p><p><img src="https://pic4.zhimg.com/80/v2-3d4d38fea7d8977ae199df2c3247cf4b_720w.jpg" alt="img"></p><p>播放视频流程图：</p><p><img src="https://pic3.zhimg.com/80/v2-6beb880c4025c2121a75dfe45beddd6e_720w.jpg" alt="img"></p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fresh</span><span class="params">(<span class="keyword">void</span> *data)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = SDL_DISPLAYEVENT;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">    SDL_Delay(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Usage : player &lt;input&gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *input = argv[<span class="number">1</span>];</span><br><span class="line">  AVFormatContext *ifmt_ctx = avformat_alloc_context();</span><br><span class="line">  <span class="keyword">if</span> (avformat_open_input(&amp;ifmt_ctx, input, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to open input &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avformat_find_stream_info(ifmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find stream info&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将音视频信息输出到控制台</span></span><br><span class="line">  av_dump_format(ifmt_ctx, <span class="number">0</span>, input, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//找到视频流</span></span><br><span class="line">  <span class="keyword">int</span> video_stream_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ifmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">      video_stream_index = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (video_stream_index == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find video stream&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVCodecContext *pCodecCtx = ifmt_ctx-&gt;streams[video_stream_index]-&gt;codec;</span><br><span class="line">  AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">  <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find the codec&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; fail to open codec &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//初始化转换参数</span></span><br><span class="line">  AVFrame *pframe = av_frame_alloc();</span><br><span class="line">  AVFrame *pframeRGB = av_frame_alloc();</span><br><span class="line">  <span class="keyword">uint8_t</span> *out_buff = (<span class="keyword">uint8_t</span> *)av_malloc(av_image_get_buffer_size(</span><br><span class="line">      AV_PIX_FMT_RGB24, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="number">1</span>));</span><br><span class="line">  av_image_fill_arrays(pframeRGB-&gt;data, pframeRGB-&gt;linesize, out_buff,</span><br><span class="line">                       AV_PIX_FMT_RGB24, pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">                       <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  SwsContext *pSwsCtx = sws_alloc_context();</span><br><span class="line">  pSwsCtx = sws_getContext(</span><br><span class="line">      pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,</span><br><span class="line">      pCodecCtx-&gt;height, AV_PIX_FMT_RGB24, SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//初始化SDL</span></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_EVERYTHING))&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to init sdl&quot;</span> &lt;&lt; SDL_GetError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_Window *p_window = SDL_CreateWindow(<span class="string">&quot;Player&quot;</span>,SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,pCodecCtx-&gt;width,pCodecCtx-&gt;height,SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span> (p_window  == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to create SDL window &quot;</span> &lt;&lt;SDL_GetError()  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_Renderer *p_renderer  = SDL_CreateRenderer(p_window,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p_renderer  == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to create SDL render &quot;</span> &lt;&lt; SDL_GetError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line"></span><br><span class="line">    rect.x = <span class="number">0</span>;</span><br><span class="line">    rect.y = <span class="number">0</span>;</span><br><span class="line">    rect.w = pCodecCtx-&gt;width;</span><br><span class="line">    rect.h = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">    SDL_Texture *p_texture = SDL_CreateTexture(p_renderer,SDL_PIXELFORMAT_RGB24,SDL_TEXTUREACCESS_STREAMING,pCodecCtx-&gt;width,pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pCodecCtx-&gt;width &lt;&lt; pCodecCtx-&gt;height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  AVPacket *pkt = av_packet_alloc();</span><br><span class="line">  av_init_packet(pkt);</span><br><span class="line">  <span class="keyword">int</span> got_frame = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//SDL 线程播放</span></span><br><span class="line">  SDL_Thread *p_thread = SDL_CreateThread(fresh,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    SDL_WaitEvent(&amp;event);</span><br><span class="line">    <span class="keyword">if</span> (event.type == SDL_DISPLAYEVENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (av_read_frame(ifmt_ctx, pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == video_stream_index) &#123;</span><br><span class="line">          <span class="keyword">int</span> ret = avcodec_decode_video2(pCodecCtx, pframe, &amp;got_frame, pkt);</span><br><span class="line">          <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sws_scale(pSwsCtx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="keyword">const</span> *)pframe-&gt;data,</span><br><span class="line">                      pframe-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, pframeRGB-&gt;data,</span><br><span class="line">                      pframeRGB-&gt;linesize);</span><br><span class="line"></span><br><span class="line">            SDL_UpdateTexture(p_texture, &amp;rect, pframeRGB-&gt;data[<span class="number">0</span>],</span><br><span class="line">                              pframeRGB-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            SDL_RenderClear(p_renderer);</span><br><span class="line">            SDL_RenderCopy(p_renderer, p_texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">            SDL_RenderPresent(p_renderer);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          av_packet_unref(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (event.type == SDL_QUIT)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SDL_DestroyTexture(p_texture);</span><br><span class="line">  SDL_DestroyWindow(p_window);</span><br><span class="line">  SDL_DestroyRenderer(p_renderer);</span><br><span class="line">  SDL_Quit();</span><br><span class="line">  av_packet_free(&amp;pkt);</span><br><span class="line">  sws_freeContext(pSwsCtx);</span><br><span class="line">  av_frame_free(&amp;pframe);</span><br><span class="line">  av_frame_free(&amp;pframeRGB);</span><br><span class="line">  avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;从开始学习到现在自己制作使用SDL2播放视频，好像经历了一个月的时间，&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>Qt+FFmpeg播放视频</title>
    <link href="http://example.com/jsblog/ca5cce0b.html"/>
    <id>http://example.com/jsblog/ca5cce0b.html</id>
    <published>2020-12-20T04:16:30.000Z</published>
    <updated>2020-12-20T04:20:59.401Z</updated>
    
    <content type="html"><![CDATA[<p>实践出真知。通过实践才能发现更多的问题。<a id="more"></a>在学习新的技术的时候也是这样。今天通过学习FFmpeg解码视频，实现一个Qt 和ffmpeg播放视频的小栗子。当然刚开始学习难免会到网上查询一下资料，然后结合自己的理解重新实现一下。具体参考哪一篇文章，我似乎也不记得了，但我记得还是好多东西都是参考雷神的博客才一步一步实践出来的。如果要学习音视频开发一定要去看雷神的博客。</p><p>说了太多废话，看一下如何配置环境。由于是在Qt中开发的，所以需要安装Qt,而IDE自然是使用QtCreator，如果你要使用visual studio，那么我也不能强求你。接下来是下载FFmpeg的库文件，可以直接去官网ffmpeg的官网下载，那里有着丰富的介绍，可惜的是我没有找到过中文版的文档。它会给你指出两个windows下可以使用的别人编译好的ffmpeg的库文件。</p><p>首先使用QtCreator创建一个项目，我把它命名为videoplayer，虽然能播放视频，但没有声音，而且播放速度还很快。在Qt项目管理配置pro文件中,添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH +&#x3D; D:&#x2F;ffmpeg&#x2F;include</span><br><span class="line">LIBS +&#x3D; -LD:&#x2F;ffmpeg&#x2F;lib&#x2F; -lavutil -lavformat -lavcodec -lavdevice -lavfilter -lswresample -lswscale -lpostproc</span><br></pre></td></tr></table></figure><p>以上两行，目的是为了添加ffmpeg的头文件，在链接的时候链接到ffmpeg的库文件。</p><p>首先是界面设计 如下（很简单）：</p><p><img src="https://pic4.zhimg.com/80/v2-08fa9ce8802e394726fd51bebc936cf7_720w.jpg" alt="img"></p><p>打开文件，就是让你选择一个文件，播放就是播放视频，而TextLabel则是为了显示解码出的一帧帧图像。</p><p>流程图如下：</p><p><img src="https://pic3.zhimg.com/80/v2-1891686cf230056632759f3b52388c9a_720w.jpg" alt="img"></p><p>部分代码讲解如下：</p><p>打开解码视频文件并绑定AVFormatContext,并找到其中流信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">   <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx,input_file.c_str(),<span class="literal">nullptr</span>,<span class="literal">nullptr</span>) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       qDebug() &lt;&lt; <span class="string">&quot;fail to find the stream\n&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       qDebug() &lt;&lt; <span class="string">&quot;fail to find the stream info\n&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// av_dump_format(pFormatCtx,0,input_file.c_str(),0);</span></span><br></pre></td></tr></table></figure><p>打开解码器，设置转换解码参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[video_stream_index]-&gt;codec;</span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to find the decoder\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx,pCodec,<span class="literal">nullptr</span>) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to open the decodec\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示图像</span></span><br><span class="line">    AVFrame *pFrame = av_frame_alloc();</span><br><span class="line">    AVFrame *pframeRGB = av_frame_alloc();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *out_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB32,pCodecCtx-&gt;width,pCodecCtx-&gt;height,<span class="number">1</span>));</span><br><span class="line">    av_image_fill_arrays(pframeRGB-&gt;data,pframeRGB-&gt;linesize,out_buffer,AV_PIX_FMT_RGB32,pCodecCtx-&gt;width,pCodecCtx-&gt;height,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AVPacket *pkt = av_packet_alloc();</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    SwsContext *pSwsCtx = sws_alloc_context();</span><br><span class="line">    pSwsCtx = sws_getContext(pCodecCtx-&gt;width,pCodecCtx-&gt;height,pCodecCtx-&gt;pix_fmt,</span><br><span class="line">                             pCodecCtx-&gt;width,pCodecCtx-&gt;height,AV_PIX_FMT_RGB32,</span><br><span class="line">                             SWS_BICUBIC,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>读取每一帧并播放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,pkt) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == video_stream_index)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = avcodec_decode_video2(pCodecCtx,pFrame,&amp;got_frame,pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug() &lt;&lt; <span class="string">&quot;fail to decode video\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sws_scale(pSwsCtx,(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="keyword">const</span>*)pFrame-&gt;data,pFrame-&gt;linesize,<span class="number">0</span>,pCodecCtx-&gt;height,pframeRGB-&gt;data,pframeRGB-&gt;linesize);</span><br><span class="line">                QImage image = QImage((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pframeRGB-&gt;data[<span class="number">0</span>],pCodecCtx-&gt;width,pCodecCtx-&gt;height,QImage::Format_RGB32,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line">                ui-&gt;Canvas-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">                Delay(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><p>widget.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">Widget::Widget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">    , ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    connect(ui-&gt;OpenFile,SIGNAL(clicked()),<span class="keyword">this</span>,SLOT(OpenFile()));</span><br><span class="line">    connect(ui-&gt;Play,SIGNAL(clicked()),<span class="keyword">this</span>,SLOT(Play()));</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::OpenFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString filter = tr(<span class="string">&quot;mp4 file(*.mp4);;rmvb file(*.rmvb);;avi file(*.avi)&quot;</span>);</span><br><span class="line">    filePath_ = QFileDialog::getOpenFileName(<span class="keyword">this</span>,tr(<span class="string">&quot;打开文件&quot;</span>),QString(),filter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::Play</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filePath_.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::warning(<span class="literal">nullptr</span>,tr(<span class="string">&quot;warn&quot;</span>),tr(<span class="string">&quot;未选择文件&quot;</span>),QMessageBox::Ok);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> input_file=filePath_.toStdString();</span><br><span class="line">    <span class="comment">//注册编解码器</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx,input_file.c_str(),<span class="literal">nullptr</span>,<span class="literal">nullptr</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to find the stream\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to find the stream info\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// av_dump_format(pFormatCtx,0,input_file.c_str(),0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> video_stream_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i =<span class="number">0</span>;i &lt; pFormatCtx-&gt;nb_streams ;++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">        &#123;</span><br><span class="line">            video_stream_index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (video_stream_index == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to find the video stream&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[video_stream_index]-&gt;codec;</span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to find the decoder\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx,pCodec,<span class="literal">nullptr</span>) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;fail to open the decodec\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示图像</span></span><br><span class="line">    AVFrame *pFrame = av_frame_alloc();</span><br><span class="line">    AVFrame *pframeRGB = av_frame_alloc();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *out_buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB32,pCodecCtx-&gt;width,pCodecCtx-&gt;height,<span class="number">1</span>));</span><br><span class="line">    av_image_fill_arrays(pframeRGB-&gt;data,pframeRGB-&gt;linesize,out_buffer,AV_PIX_FMT_RGB32,pCodecCtx-&gt;width,pCodecCtx-&gt;height,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AVPacket *pkt = av_packet_alloc();</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    SwsContext *pSwsCtx = sws_alloc_context();</span><br><span class="line">    pSwsCtx = sws_getContext(pCodecCtx-&gt;width,pCodecCtx-&gt;height,pCodecCtx-&gt;pix_fmt,</span><br><span class="line">                             pCodecCtx-&gt;width,pCodecCtx-&gt;height,AV_PIX_FMT_RGB32,</span><br><span class="line">                             SWS_BICUBIC,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,pkt) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == video_stream_index)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = avcodec_decode_video2(pCodecCtx,pFrame,&amp;got_frame,pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug() &lt;&lt; <span class="string">&quot;fail to decode video\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sws_scale(pSwsCtx,(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="keyword">const</span>*)pFrame-&gt;data,pFrame-&gt;linesize,<span class="number">0</span>,pCodecCtx-&gt;height,pframeRGB-&gt;data,pframeRGB-&gt;linesize);</span><br><span class="line">                QImage image = QImage((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pframeRGB-&gt;data[<span class="number">0</span>],pCodecCtx-&gt;width,pCodecCtx-&gt;height,QImage::Format_RGB32,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line">                ui-&gt;Canvas-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">                Delay(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sws_freeContext(pSwsCtx);</span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::Delay</span><span class="params">(<span class="keyword">int</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTime deadTime = QTime::currentTime().addMSecs(delay);</span><br><span class="line">    <span class="keyword">if</span> (QTime::currentTime() &lt; deadTime)</span><br><span class="line">        QCoreApplication::processEvents(QEventLoop::AllEvents,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>widget.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span> &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~Widget();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">int</span> delay)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OpenFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QString filePath_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;实践出真知。通过实践才能发现更多的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>提取RGB数据</title>
    <link href="http://example.com/jsblog/ba4deb51.html"/>
    <id>http://example.com/jsblog/ba4deb51.html</id>
    <published>2020-12-20T04:15:32.000Z</published>
    <updated>2020-12-20T04:20:59.406Z</updated>
    
    <content type="html"><![CDATA[<p>学习需要一步一步来，前几天在网上找了一个demo学习了如何在Qt中使用FFMPEG将视频数据解码出来并播放，<a id="more"></a>但是当时有好多细节不是很明白，于是便深入的学习一下如何将一个mv中的原始的数据读取出来，仅仅是读取视频数据的每一帧而不是音频数据，利用FFmpeg可以从mv中导出音频数据，有命令可以使用，当然也可以编码实现。</p><p>现在主要是来讲一下如何使用FFMPEG将音频中的原始数据读出并使用sws_scale将其转换为RGB数据，并写入到文件中。</p><p>流程图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-662b3d2e4d44fc2f8181c582417cc18d_720w.jpg" alt="img"></p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavfilter/avfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavdevice/avdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Usage : convert &lt;input&gt; &lt;output&gt;&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * input_video = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output_rgb = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//注册解码器</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    avformat_network_init();</span><br><span class="line">    <span class="comment">//创建avformatcontext</span></span><br><span class="line">    AVFormatContext *ifmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span>(avformat_open_input(&amp;ifmt_ctx,input_video,<span class="literal">NULL</span>,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to open the stream\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到文件中的流信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(ifmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to find the stream\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将输入文件的编码信息输出</span></span><br><span class="line">    av_dump_format(ifmt_ctx,<span class="number">0</span>,input_video,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//找到视频流</span></span><br><span class="line">    <span class="keyword">int</span> video_stream_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ifmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">            video_stream_index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (video_stream_index == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to find video stream\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到相应的编解码器</span></span><br><span class="line">    AVCodecContext *pCodecCtx = ifmt_ctx-&gt;streams[video_stream_index]-&gt;codec;</span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to find codec\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx,pCodec,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to open codec\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出文件</span></span><br><span class="line">    FILE *fp = fopen(output_rgb,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AVFrame *pframe = av_frame_alloc();</span><br><span class="line">    AVFrame *pframeRGB = av_frame_alloc();</span><br><span class="line">    <span class="comment">//设置输出缓冲区</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  *outBuffer = (<span class="keyword">uint8_t</span>*)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB24,pCodecCtx-&gt;width,pCodecCtx-&gt;height,<span class="number">1</span>));</span><br><span class="line">    av_image_fill_arrays(pframeRGB-&gt;data,pframeRGB-&gt;linesize,outBuffer,AV_PIX_FMT_RGB24,pCodecCtx-&gt;width,pCodecCtx-&gt;height,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//需要使用sws_scale进行转换</span></span><br><span class="line">    SwsContext *pSwsCtx = sws_alloc_context();</span><br><span class="line">    <span class="comment">//转换的参数设置</span></span><br><span class="line">    pSwsCtx = sws_getContext(pCodecCtx-&gt;width,pCodecCtx-&gt;height,pCodecCtx-&gt;pix_fmt,</span><br><span class="line">            pCodecCtx-&gt;width,pCodecCtx-&gt;height,AV_PIX_FMT_RGB24,SWS_BICUBIC,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    AVPacket *pkt = av_packet_alloc();</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(ifmt_ctx,pkt) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == video_stream_index)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="keyword">int</span> ret = avcodec_decode_video2(pCodecCtx,pframe,&amp;got_frame,pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sws_scale(pSwsCtx,(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span>*)pframe-&gt;data,pframe-&gt;linesize,<span class="number">0</span>,pframe-&gt;height,pframeRGB-&gt;data,pframeRGB-&gt;linesize);</span><br><span class="line">                <span class="comment">//将数据以二进制的形式写入文件中</span></span><br><span class="line">                fwrite(pframeRGB-&gt;data[<span class="number">0</span>],pCodecCtx-&gt;height * pCodecCtx-&gt;width*<span class="number">3</span>,<span class="number">1</span>,fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放所有申请的资源，并关闭打开的资源</span></span><br><span class="line">    sws_freeContext(pSwsCtx);</span><br><span class="line">    av_frame_free(&amp;pframe);</span><br><span class="line">    av_frame_free(&amp;pframeRGB);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习需要一步一步来，前几天在网上找了一个demo学习了如何在Qt中使用FFMPEG将视频数据解码出来并播放，&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>格式转换</title>
    <link href="http://example.com/jsblog/380b57e8.html"/>
    <id>http://example.com/jsblog/380b57e8.html</id>
    <published>2020-12-20T04:14:46.000Z</published>
    <updated>2020-12-20T04:20:59.407Z</updated>
    
    <content type="html"><![CDATA[<p>学习了一部分ffmpeg的知识，但是没有目标的学习似乎好像学不到什么东西。<a id="more"></a>尤其是编程方面。想找一些例子来做，看着别人的博客却提不起兴趣来做。当自己有了一个目标的时候才会充满动力，在了解了一些音视频的知识之后，才知道原来各种音视频的格式不是靠改个后缀名就能改变其编码格式的。于是便想实现一个格式转换的程序，来完成格式的转换。当然我也是只是测试了视频的转换，并没有测试音频的转换。</p><p>对于格式的转换其实就是对于要转换的文件首先进行解封装，然后再通过要转换的格式的编解码器进行封装，最后将数据写入目标文件。</p><p>其流程图如下：</p><p><img src="https://pic3.zhimg.com/80/v2-cd2a84df9b838ca6c09257a86ece98be_720w.jpg" alt="img"></p><p>格式转换代码流程图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-30ef33fecc28bf594da9b36ed28b3c2f_720w.jpg" alt="img"></p><p><strong>实现部分</strong></p><p>先从输入文件中读取数据以及数据的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">av_register_all();</span><br><span class="line">AVFormatContext *ifmt_ctx = avformat_alloc_context();</span><br><span class="line"><span class="keyword">if</span> (avformat_open_input(&amp;ifmt_ctx,input_file,<span class="literal">NULL</span>,<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to open the input file &quot;</span> &lt;&lt; input_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (avformat_find_stream_info(ifmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find the stream information &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示解码信息</span></span><br><span class="line">av_dump_format(ifmt_ctx,<span class="number">0</span>,input_file,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>根据输出文件的格式，得到输出文件的解码格式，如果输出文件没有扩展名，则会出错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AVOutputFormat *out_fmt = av_guess_format(<span class="literal">NULL</span>,output_file,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (out_fmt == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find the format&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AVFormatContext *ofmt_ctx = avformat_alloc_context();</span><br><span class="line">  <span class="keyword">if</span> (avformat_alloc_output_context2(&amp;ofmt_ctx,out_fmt,out_fmt-&gt;name,output_file) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to alloc the output context&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将各种流的编解码参数设置到输出Context中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; ifmt_ctx-&gt;nb_streams;i++)&#123;</span><br><span class="line">        <span class="comment">//找到解码器</span></span><br><span class="line">        AVStream *input_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVCodec *pCodec = avcodec_find_decoder(input_stream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">        <span class="comment">//定义输出参数</span></span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx,pCodec);</span><br><span class="line">        <span class="keyword">if</span> (out_stream == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to create the out stream &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制解码参数</span></span><br><span class="line">        <span class="keyword">if</span> (avcodec_parameters_copy(out_stream-&gt;codecpar,input_stream-&gt;codecpar) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to copy parameters &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">            out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出信息</span></span><br><span class="line">    av_dump_format(ofmt_ctx,<span class="number">0</span>,output_file,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>打开输出文件，并写入数据，写写入头信息，最后写入尾部信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(out_fmt-&gt;flags &amp;AVFMT_NOFILE)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (avio_open(&amp;ofmt_ctx-&gt;pb, output_file, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to open the avio context&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//写入信息头</span></span><br><span class="line">   <span class="keyword">if</span> (avformat_write_header(ofmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to write header&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   AVPacket *pkt = av_packet_alloc();</span><br><span class="line">   av_init_packet(pkt);</span><br><span class="line">   <span class="keyword">int</span> frame_index = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//转换avi需要使用bsf，如果不使用这个会转换失败</span></span><br><span class="line">   AVBitStreamFilterContext *bsf = av_bitstream_filter_init(<span class="string">&quot;h264_mp4toannexb&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(av_read_frame(ifmt_ctx,pkt) &gt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       AVStream *in_steam,*out_stream;</span><br><span class="line">       in_steam = ifmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">       out_stream = ofmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">       pkt-&gt;pts = av_rescale_q_rnd(pkt-&gt;pts,in_steam-&gt;time_base,out_stream-&gt;time_base,(AVRounding)(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">       pkt-&gt;dts = av_rescale_q_rnd(pkt-&gt;dts,in_steam-&gt;time_base,out_stream-&gt;time_base,(AVRounding)(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">       pkt-&gt;duration = av_rescale_q(pkt-&gt;duration,in_steam-&gt;time_base,out_stream-&gt;time_base);</span><br><span class="line">       pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">if</span> (pkt-&gt;stream_index == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           AVPacket *fpkt = av_packet_alloc();</span><br><span class="line">           <span class="keyword">int</span> test = av_bitstream_filter_filter(bsf,in_steam-&gt;codec,<span class="literal">NULL</span>,&amp;fpkt-&gt;data,&amp;fpkt-&gt;size,</span><br><span class="line">                   pkt-&gt;data,pkt-&gt;size,pkt-&gt;flags | AV_PKT_FLAG_KEY);</span><br><span class="line">           pkt-&gt;data = fpkt-&gt;data;</span><br><span class="line">           pkt-&gt;size = fpkt-&gt;size;</span><br><span class="line">           av_packet_free(&amp;fpkt);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (av_interleaved_write_frame(ofmt_ctx,pkt) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to write&quot;</span> &lt;&lt; frame_index &lt;&lt;<span class="string">&quot; frame&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       av_packet_unref(pkt);</span><br><span class="line">       frame_index ++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//写入文件尾部信息</span></span><br><span class="line">   <span class="keyword">if</span> (av_write_trailer(ofmt_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to write trailer &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>释放所有申请的资源，关闭打开的环境：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">av_bitstream_filter_close(bsf);</span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(out_fmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">        avio_close(ofmt_ctx-&gt;pb);</span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    avformat_free_context(ifmt_ctx);</span><br></pre></td></tr></table></figure><p>所有代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavfilter/avfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;usage :convert &lt;input&gt; &lt;output&gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* input_file = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* output_file = argv[<span class="number">2</span>];</span><br><span class="line">    av_register_all();</span><br><span class="line">    AVFormatContext *ifmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;ifmt_ctx,input_file,<span class="literal">NULL</span>,<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to open the input file &quot;</span> &lt;&lt; input_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(ifmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find the stream information &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示解码信息</span></span><br><span class="line">    av_dump_format(ifmt_ctx,<span class="number">0</span>,input_file,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输出设置</span></span><br><span class="line">    AVOutputFormat *out_fmt = av_guess_format(<span class="literal">NULL</span>,output_file,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (out_fmt == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to find the format&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVFormatContext *ofmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span> (avformat_alloc_output_context2(&amp;ofmt_ctx,out_fmt,out_fmt-&gt;name,output_file) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to alloc the output context&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; ifmt_ctx-&gt;nb_streams;i++)&#123;</span><br><span class="line">        <span class="comment">//找到解码器</span></span><br><span class="line">        AVStream *input_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVCodec *pCodec = avcodec_find_decoder(input_stream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">        <span class="comment">//定义输出参数</span></span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx,pCodec);</span><br><span class="line">        <span class="keyword">if</span> (out_stream == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to create the out stream &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制解码参数</span></span><br><span class="line">        <span class="keyword">if</span> (avcodec_parameters_copy(out_stream-&gt;codecpar,input_stream-&gt;codecpar) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to copy parameters &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">            out_stream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出信息</span></span><br><span class="line">    av_dump_format(ofmt_ctx,<span class="number">0</span>,output_file,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(out_fmt-&gt;flags &amp;AVFMT_NOFILE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (avio_open(&amp;ofmt_ctx-&gt;pb, output_file, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to open the avio context&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入信息头</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_write_header(ofmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to write header&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVPacket *pkt = av_packet_alloc();</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    <span class="keyword">int</span> frame_index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//转换avi需要使用bsf</span></span><br><span class="line">    AVBitStreamFilterContext *bsf = av_bitstream_filter_init(<span class="string">&quot;h264_mp4toannexb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(ifmt_ctx,pkt) &gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        AVStream *in_steam,*out_stream;</span><br><span class="line">        in_steam = ifmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        pkt-&gt;pts = av_rescale_q_rnd(pkt-&gt;pts,in_steam-&gt;time_base,out_stream-&gt;time_base,(AVRounding)(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt-&gt;dts = av_rescale_q_rnd(pkt-&gt;dts,in_steam-&gt;time_base,out_stream-&gt;time_base,(AVRounding)(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt-&gt;duration = av_rescale_q(pkt-&gt;duration,in_steam-&gt;time_base,out_stream-&gt;time_base);</span><br><span class="line">        pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVPacket *fpkt = av_packet_alloc();</span><br><span class="line">            <span class="keyword">int</span> test = av_bitstream_filter_filter(bsf,in_steam-&gt;codec,<span class="literal">NULL</span>,&amp;fpkt-&gt;data,&amp;fpkt-&gt;size,</span><br><span class="line">                    pkt-&gt;data,pkt-&gt;size,pkt-&gt;flags | AV_PKT_FLAG_KEY);</span><br><span class="line">            pkt-&gt;data = fpkt-&gt;data;</span><br><span class="line">            pkt-&gt;size = fpkt-&gt;size;</span><br><span class="line">            av_packet_free(&amp;fpkt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av_interleaved_write_frame(ofmt_ctx,pkt) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to write&quot;</span> &lt;&lt; frame_index &lt;&lt;<span class="string">&quot; frame&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(pkt);</span><br><span class="line">        frame_index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入文件尾部信息</span></span><br><span class="line">    <span class="keyword">if</span> (av_write_trailer(ofmt_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fail to write trailer &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_bitstream_filter_close(bsf);</span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(out_fmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">        avio_close(ofmt_ctx-&gt;pb);</span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    avformat_free_context(ifmt_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习了一部分ffmpeg的知识，但是没有目标的学习似乎好像学不到什么东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>从MV中提取音频</title>
    <link href="http://example.com/jsblog/8ef2442b.html"/>
    <id>http://example.com/jsblog/8ef2442b.html</id>
    <published>2020-12-20T04:13:33.000Z</published>
    <updated>2020-12-20T04:20:59.405Z</updated>
    
    <content type="html"><![CDATA[<p>看过了FFMPEG中的一些结构体，可能对于怎么使用这些结构体写代码有些遗忘，尤其是如何处理音视频。<a id="more"></a>接下来从头开始实现一个从MV中可以提取音频数据的小例子，但是由于ffmpeg不支持MP3onMP4的encoder，所以在输出文件的时候可以设置为AAC格式，如果设置为MP3输出格式，则不会导出音频数据。</p><p>首先看一下流程图：</p><p><img src="https://pic2.zhimg.com/80/v2-224946e45543a0297fcbc9fc49b6a80d_720w.jpg" alt="img"></p><p>以上流程主要分为：</p><ol><li>打开文件提取参数</li><li>准备输出文件，设置输出流</li><li>参数复制，复制解码器参数信息以及初始AVIOContext</li><li>复制数据</li><li>最后释放资源</li></ol><p>然后看一下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : extrace &lt;input&gt; &lt;output&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* input = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* output = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//注册编解码器</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    <span class="comment">//申请avformatcontext</span></span><br><span class="line">    AVFormatContext *ifmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;ifmt_ctx,input,<span class="literal">NULL</span>,<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to open input stream\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取一些流的信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(ifmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to find the stream info\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将打开文件的信息以及ffmpeg的信息显示到控制台上</span></span><br><span class="line">    av_dump_format(ifmt_ctx,<span class="number">0</span>,input,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//找到最好的音频流的索引</span></span><br><span class="line">    <span class="keyword">int</span> audio_stream_index = <span class="number">-1</span>;</span><br><span class="line">    audio_stream_index = av_find_best_stream(ifmt_ctx,AVMEDIA_TYPE_AUDIO,<span class="number">-1</span>,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (audio_stream_index == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to find the audio stream\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//音频流和此音频的解码器</span></span><br><span class="line">    AVStream *in_stream = ifmt_ctx-&gt;streams[audio_stream_index];</span><br><span class="line">    AVCodec* pCodec = avcodec_find_decoder(in_stream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to find the codec\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从输出文件中读取输出格式</span></span><br><span class="line">    AVOutputFormat *out_fmt = av_guess_format(<span class="literal">NULL</span>,output,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (out_fmt==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;didn`t support this format&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建输出环境，并设置与输出文件关联和设置输出文件的格式</span></span><br><span class="line">    AVFormatContext *ofmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span> (avformat_alloc_output_context2(&amp;ofmt_ctx,out_fmt,out_fmt-&gt;name,output) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to alloc output context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据编解码器和输出ofmt_ctx创建输出流</span></span><br><span class="line">    AVStream *out_stream = avformat_new_stream(ofmt_ctx,pCodec);</span><br><span class="line">    <span class="comment">//设置输出流的编解码器参数</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_parameters_copy(out_stream-&gt;codecpar,in_stream-&gt;codecpar) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to copy parameteres\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建并初始化AVIOContext并置AVIOContext的标志为写入文件，同时与输出文件关联起来</span></span><br><span class="line">    <span class="keyword">if</span> (avio_open(&amp;ofmt_ctx-&gt;pb,output,AVIO_FLAG_WRITE) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to open aviocontext\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入文件头信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_write_header(ofmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to write header\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化AVpacket</span></span><br><span class="line">    AVPacket *pkt = av_packet_alloc();</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    <span class="comment">//读取ifmt_ctx中的包</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(ifmt_ctx,pkt) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;stream_index == audio_stream_index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重新计算时间戳，变换为音频输出的时间戳</span></span><br><span class="line">            pkt-&gt;pts = av_rescale_q_rnd(pkt-&gt;pts,in_stream-&gt;time_base,out_stream-&gt;time_base,(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt-&gt;dts = pkt-&gt;pts;</span><br><span class="line">            pkt-&gt;duration = av_rescale_q(pkt-&gt;duration,in_stream-&gt;time_base,out_stream-&gt;time_base);</span><br><span class="line">            pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">            pkt-&gt;stream_index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//对pkt检查并写入文件包</span></span><br><span class="line">            av_interleaved_write_frame(ofmt_ctx,pkt);</span><br><span class="line">            <span class="comment">//将pkt中的资源释放</span></span><br><span class="line">            av_packet_unref(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入尾部信息</span></span><br><span class="line">    av_write_trailer(ofmt_ctx);</span><br><span class="line">    <span class="comment">//释放资源，释放pkt</span></span><br><span class="line">    av_free_packet(pkt);</span><br><span class="line">    <span class="comment">//关闭aviocontext 写入完成</span></span><br><span class="line">    avio_close(ofmt_ctx-&gt;pb);</span><br><span class="line">    <span class="comment">//释放ofmt_ctx</span></span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">    <span class="comment">//关闭并释放输入ifmt_ctx</span></span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract.exe test.mp4 out.aac</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;看过了FFMPEG中的一些结构体，可能对于怎么使用这些结构体写代码有些遗忘，尤其是如何处理音视频。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>ffprobe的用法</title>
    <link href="http://example.com/jsblog/6a6c7041.html"/>
    <id>http://example.com/jsblog/6a6c7041.html</id>
    <published>2020-12-20T04:12:39.000Z</published>
    <updated>2020-12-20T04:20:59.405Z</updated>
    
    <content type="html"><![CDATA[<p>ffprobe是ffmpeg中一个查看多媒体文件信息的模块。<a id="more"></a>此模块可以用来查看多媒体文件格式以及编码。ffprobe的命令较多，这里只简单的列举了一些比较常用的命令。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-L 显示协议</span><br><span class="line">-h/-?/-help/--help topic 帮助可以选择话题</span><br><span class="line">-version 显示版本</span><br><span class="line">-buildconf 展示编译配置选项</span><br><span class="line">-formats 显示支持的编码</span><br><span class="line">-muxers 展示支持的封装器</span><br><span class="line">-demuxers 展示支持的解封装器</span><br><span class="line">-devices 展示支持的设备</span><br><span class="line">-codecs 展示支持的编码</span><br><span class="line">-decoders 显示支持的解码器</span><br><span class="line">-encoders 显示支持的编码器</span><br><span class="line">-bsfs 显示支持的比特流过滤器</span><br><span class="line">-protocols 展示支持的协议</span><br><span class="line">-filters 展示支持的过滤器</span><br><span class="line">-pix_fmts 显示支持的像素格式</span><br><span class="line">-layouts 展示支持的声道格式</span><br><span class="line">-sample_fmts 显示支持的采样格式</span><br><span class="line">-colors 展示支持的颜色名称</span><br><span class="line">-loglevel loglevel 设置日志级别</span><br><span class="line">-v loglevel 设置日志级别</span><br><span class="line">-report 生成报告</span><br><span class="line">-max_alloc bytes 设置单个已分配块的最大大小</span><br><span class="line">-cpuflags flags 指定cpu标志</span><br><span class="line">-hide_banner hide_banner 不显示程序横幅</span><br><span class="line">-sources device 列出源的输出设备</span><br><span class="line">-sinks device 列出输出设备的接收器</span><br><span class="line">-f format 指定格式</span><br><span class="line">-unit 显示显示值的单位</span><br><span class="line">-prefix 对显示的值使用SI前缀</span><br><span class="line">-byte_binary_prefix 对字节单位使用二进制前缀</span><br><span class="line">-sexagesimal 对时间单位使用六十进制格式 HOURS:MM:SS.MICROSECONDS </span><br><span class="line">-pretty 美化显示输出的值，让人可读</span><br><span class="line">-print_format format 设置打印格式 (available formats are: default, compact, csv, flat, ini, json, xml)</span><br><span class="line">-of format -print_format的编码</span><br><span class="line">-select_streams stream_specifier 选择指定的stream</span><br><span class="line">-sections 打印节结构和节信息，然后退出</span><br><span class="line">-show_data 显示数据包信息</span><br><span class="line">-show_data_hash 显示数据包hash值</span><br><span class="line">-show_error 显示探测中的错误</span><br><span class="line">-show_format 显示格式/容器信息</span><br><span class="line">-show_frames 显示帧信息</span><br><span class="line">-show_format_entry entry 显示格式/容器信息中的特定条目</span><br><span class="line">-show_entries entry_list 显示一组指定的项</span><br><span class="line">-show_log 显示log</span><br><span class="line">-show_packets 显示packet信息</span><br><span class="line">-show_programs  显示程序信息</span><br><span class="line">-show_streams 显示stream的信息</span><br><span class="line">-show_chapters 显示chapters的信息</span><br><span class="line">-count_frames 每个stream中的帧数</span><br><span class="line">-count_packets 每个stream中的包数量</span><br><span class="line">-show_program_version ffprobe的版本</span><br><span class="line">-show_library_versions 库的版本</span><br><span class="line">-show_versions 程序和库的版本号</span><br><span class="line">-show_pixel_formats 展示像素格式描述</span><br><span class="line">-show_private_data 显示私有数据</span><br><span class="line">-private 和显示私有数据一样</span><br><span class="line">-bitexact 强制提取bit输出</span><br><span class="line">-read_intervals read_intervals 设置读取间隔</span><br><span class="line">-default 默认所有选项</span><br><span class="line">-i input_file 读取指定文件</span><br><span class="line">-print_filename print_file 重新显示输入的文件名</span><br><span class="line">-find_stream_info 读取并解码流，用启发式方法填充缺失的信息</span><br></pre></td></tr></table></figure><p>举个例子说明一下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_format test.mp4 -print_format json</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;format&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;test.mp4&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;nb_streams&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;nb_programs&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;format_name&quot;</span>: <span class="string">&quot;mov,mp4,m4a,3gp,3g2,mj2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;format_long_name&quot;</span>: <span class="string">&quot;QuickTime / MOV&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start_time&quot;</span>: <span class="string">&quot;0.000000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;duration&quot;</span>: <span class="string">&quot;319.204000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="string">&quot;20393093&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;bit_rate&quot;</span>: <span class="string">&quot;511098&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;probe_score&quot;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">&quot;tags&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;major_brand&quot;</span>: <span class="string">&quot;isom&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minor_version&quot;</span>: <span class="string">&quot;512&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;compatible_brands&quot;</span>: <span class="string">&quot;isomiso2avc1mp41&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;artist&quot;</span>: <span class="string">&quot;张国荣&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;comment&quot;</span>: <span class="string">&quot;163 key(Don&#x27;t modify):LxuL/bhXK+eaR4o7F6vxHKbEgEKNGLg65XxJgCCH5+sQLLnuMmlonrU27WIYQt6PVE6HRptXEzkJGEUUyqRRgCQJCfXHsb5uK0bdi2lw2dOZM6en1xhkYzGV5bS0uqXI0ZMFdk2CrlfK9x7cKCXIO7AU63YasnAy7YR4dW6boVAOaUvjIWxu5CuHaCLpAF8idLjG4VlAtUpZDj2WEXQJRcZZUFLtJWNVzfbnajHn6j7qG9e0XlNSmOu6RlE/X4MR&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;追 &quot;</span>,</span><br><span class="line">            <span class="attr">&quot;encoder&quot;</span>: <span class="string">&quot;Lavf56.4.101&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;ffprobe是ffmpeg中一个查看多媒体文件信息的模块。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>ffplay的用法</title>
    <link href="http://example.com/jsblog/1616cb96.html"/>
    <id>http://example.com/jsblog/1616cb96.html</id>
    <published>2020-12-20T04:11:58.000Z</published>
    <updated>2020-12-20T04:20:59.404Z</updated>
    
    <content type="html"><![CDATA[<p>ffplay是一个可移植的媒体播放器。<a id="more"></a>ffplay的编译生成需要需要SDL的支持，所以在编译ffmpeg的时候需要打开SDL的支持。在编译ffmpeg之前需要将SDL编译安装。然后编译FFMPEG。简单的说明怎么编译生成ffplay，这不是本篇文章，本篇文章是简单的介绍一下ffplay的用法。首先看下ffplay的基本命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay [options] input_file</span><br></pre></td></tr></table></figure><p>1.主要参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">-L 展示协议</span><br><span class="line">-h/-?/-help/--help topic 显示帮助</span><br><span class="line">-version 展示ffplay版本</span><br><span class="line">-buildconf 展示编译配置</span><br><span class="line">-formats 展示支持的格式</span><br><span class="line">-muxers 显示支持封装器</span><br><span class="line">-demuxers 显示支持的解封装器</span><br><span class="line">-devices 显示支持的设备</span><br><span class="line">-codecs 展示支持的编码</span><br><span class="line">-decoders 展示支持的解码器</span><br><span class="line">-coders 展示支持的编码器</span><br><span class="line">-bsfs 展示支持的比特流过滤器</span><br><span class="line">-protocols 展示支持的协议</span><br><span class="line">-filters 展示支持的过滤器</span><br><span class="line">-pix_fmts 展示支持的像素格式</span><br><span class="line">-layouts 列出标准的声道格式</span><br><span class="line">-sample_fmts 列出支持的音频采样格式</span><br><span class="line">-colors 支持的颜色的名称</span><br><span class="line">-loglevel loglevel 设置日志级别</span><br><span class="line">-v loglevel 设置日志级别</span><br><span class="line">-report 生成一个报告</span><br><span class="line">-max_alloc bytes 设置单个块可以分配的最大大小</span><br><span class="line">-sources device 列出输入设置源</span><br><span class="line">-sinks device 列出输出设备的接收器</span><br><span class="line">-x width 设置显示的宽</span><br><span class="line">-y height 设置显示的高</span><br><span class="line">-s size 设置帧的大小 即宽x高WxH</span><br><span class="line">-fs 全屏</span><br><span class="line">-an 禁用音频</span><br><span class="line">-vn 禁用视频</span><br><span class="line">-sn 禁用字幕</span><br><span class="line">-t duration 设置播放音频或者视频的次数</span><br><span class="line">-byte val 按照bytes跳转 0关闭，1开启，-1自动</span><br><span class="line">-seek_interval seconds 设置按下left/right跳转的单位</span><br><span class="line">-nodisp 禁用图形显示</span><br><span class="line">-noboreder 无边框的界面</span><br><span class="line">-alwaysontop 设置界面在上方</span><br><span class="line">-volume volume 设置音量从0到100</span><br><span class="line">-f fmt 指定解码改革是</span><br><span class="line">-window_title window title 设置界面名字</span><br><span class="line">-af filter_graph 设置音频过滤</span><br><span class="line">-showmode mode 设置显示方式(0 = video, 1 = waves, 2 = RDFT)</span><br><span class="line">-i input_file 读取指定 文件</span><br><span class="line">-codec decoder_name 指定解码器</span><br><span class="line">-autorotate 自动旋转视频</span><br></pre></td></tr></table></figure><p>2.高级选项</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-cpuflags flags 指定CPU标志</span><br><span class="line">-hide_banner hide_banner 不显示程序横幅</span><br><span class="line">-ast stream_specifier 选择想要的音频流</span><br><span class="line">-vst stream_specifier 选择想要的视频流</span><br><span class="line">-sst stream_specifier 选择想要的字幕流</span><br><span class="line">-pix_fmt format 设置像素格式</span><br><span class="line">-stats 显示播放状态</span><br><span class="line">-fast 不符合规范的优化</span><br><span class="line">-genpts 生成pts</span><br><span class="line">-drp 让解码器重新排序点 0=off 1=on -1=auto</span><br><span class="line">-lowres </span><br><span class="line">-sync type  设置音视频同步格式 (type=audio/video/ext)</span><br><span class="line">-autoexit 结束时退出</span><br><span class="line">-exitonkeydown 键盘按下退出</span><br><span class="line">-exitonmousedown 当鼠标键按下退出</span><br><span class="line">-loop loop count 设定回放循环次数</span><br><span class="line">-framedrop 当cpu太慢时丢弃帧</span><br><span class="line">-infbuf 不限制输入缓冲区的大小 (useful with realtime streams)</span><br><span class="line">-left x pos 设置界面的x坐标</span><br><span class="line">-top y pos 设置界面y坐标</span><br><span class="line">-vf filter_graph 设置音频过滤器</span><br><span class="line">-rdftspeed msecs rdft 速率</span><br><span class="line">-default 通用选项</span><br><span class="line">-acodec decoder_name 指定音频解码器</span><br><span class="line">-scodec decoder_name 指定字幕解码器</span><br><span class="line">-vcodec decoder_name 指定视频解码器</span><br><span class="line">-find_stream_info 读取并解码流，用启发式方法填充缺失的信息</span><br><span class="line">-filter_threads 每幅图中过滤器线程数</span><br></pre></td></tr></table></figure><p>3.播放控制（键盘）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">q,esc 表示退出</span><br><span class="line">f 全屏</span><br><span class="line">p,spc 暂停</span><br><span class="line">m 静音</span><br><span class="line">9,0 减小或者提高音量</span><br><span class="line">/,* 减小或者提高音量</span><br><span class="line">a 循环音频</span><br><span class="line">v 循环视频</span><br><span class="line">t 循环字幕</span><br><span class="line">c 循环整个播放的项目</span><br><span class="line">w 循环视频过滤器或者显示</span><br><span class="line">s 激活帧模式</span><br><span class="line">left/right 快退或者快进10s,如果参数-seek_interval使用，则使用用户指定的单位</span><br><span class="line">down/up 快退或者快进1分钟</span><br><span class="line">page down/ page up 快退或者快进10分钟</span><br><span class="line">right mouse click 查找文件中与宽度分数相对应的百分比</span><br><span class="line">left double-click 全屏</span><br></pre></td></tr></table></figure><p>当然还有许多参数可以设定，如果需要更多的用法可以FFMPEG参考官网。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ffplay是一个可移植的媒体播放器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg的用法</title>
    <link href="http://example.com/jsblog/65916f96.html"/>
    <id>http://example.com/jsblog/65916f96.html</id>
    <published>2020-12-20T04:09:52.000Z</published>
    <updated>2020-12-20T04:20:59.403Z</updated>
    
    <content type="html"><![CDATA[<p>通过对ffmpeg源码编译安装得到下面几个文件夹 <a id="more"></a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin:存放编译生成的二进制可执行文件，以及动态链接库dll文件</span><br><span class="line">share: 在linux上可以使用man命令查看</span><br><span class="line">include: 开发所使用到的头文件</span><br><span class="line">lib: 静态链接库lib文件以及动态块a文件</span><br></pre></td></tr></table></figure><p>本文主要是学习一下ffmpeg的用法即使用ffmpeg的命令去处理音视频，ffmpeg的用法如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>1.显示帮助信息以及ffmpeg的功能:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-L license</span><br><span class="line">-h/-?/-help/--help 帮助</span><br><span class="line">-version 展示版本</span><br><span class="line">-buildconf 展示编译时的配置</span><br><span class="line">-format 展示支持的格式</span><br><span class="line">-muxers 展示支持的封装器</span><br><span class="line">-demuxers 展示支持的解封装器</span><br><span class="line">-devices 展示支持的设置</span><br><span class="line">-codecs 展示支持的编码</span><br><span class="line">-decoders 展示可用的解码器</span><br><span class="line">-encoders 展示可用的编码器</span><br><span class="line">-bsfs 展示支持的比特流过滤器</span><br><span class="line">-portocols 展示支持的协议</span><br><span class="line">-filters 展示支持的过滤器</span><br><span class="line">-pix_fmts 展示支持的像素格式</span><br><span class="line">-layouts 列出标准的声道格式</span><br><span class="line">-sample_fmts 列出支持的音频采样格式</span><br><span class="line">-colors 展示颜色的名称</span><br><span class="line">-sources device 列出输入设置源</span><br><span class="line">-sinks device 列出输出设备的接收器</span><br><span class="line">-hwaccels 展示支持的HW加速算法</span><br></pre></td></tr></table></figure><p>2.全局参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-loglevel loglevel 设置日志级别</span><br><span class="line">-v loglevel  也是设置日志级别</span><br><span class="line">-report 产生一个报表</span><br><span class="line">-max_alloc bytes 设置单个块可以分配的最大大小</span><br><span class="line">-y  覆盖输出文件</span><br><span class="line">-n 从不覆盖输出文件</span><br><span class="line">-ignore_unknon 忽略未知流的格式</span><br><span class="line">-filter_threads 不复杂的过滤的线程数量</span><br><span class="line">-filter_complex_threads 复杂的过滤器的线程数量</span><br><span class="line">-stats 显示编码时的进度</span><br><span class="line">-max_error_rate 最大错误率（0.0：no errors ,1.0: 100% errors）</span><br><span class="line">-bits_per_raw_sample number 设置每个采样的位数</span><br><span class="line">-vol volume 改变音量大小（正常为256）</span><br></pre></td></tr></table></figure><p>3.文件参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-f fmt 设置强制的格式</span><br><span class="line">-c codec 指定编码器的名称</span><br><span class="line">-codec codec 指定编码器的名称</span><br><span class="line">-pre preset 预设名称</span><br><span class="line">-map_metadata outfile[,metadata]:infile[,metadata] 设置通过infile输出文件的元数据</span><br><span class="line">-t duration 记录或转码音视频的持续时间</span><br><span class="line">-to time_stop 记录或者转码停止时间</span><br><span class="line">-fs limit_size 设置文件大小限制，以byte为单位</span><br><span class="line">-ss time_off 设置开始时间偏移</span><br><span class="line">-sseof time_off 设置相对于终止的时间偏移</span><br><span class="line">-seek_timestamp 启用/禁用使用-ss跳转到指定的时间戳</span><br><span class="line">-timestamp time 设置正在记录的时间戳</span><br><span class="line">-metadata string=string 添加元数据</span><br><span class="line">-programe title=string:st=number,,, 添加具有指定流的项目</span><br><span class="line">-target type 指定目标文件类型（vcd,svcd,dvd,dv等）</span><br><span class="line">-apad 音频板</span><br><span class="line">-frames number 设置输出的帧数</span><br><span class="line">-filter filter_graph 设置流的过滤图</span><br><span class="line">-filter_script filename 从文件中读取流的过滤图的描述</span><br><span class="line">-reinit_filter 重新初始化输入参数变化的过滤图</span><br><span class="line">-discard 丢弃</span><br><span class="line">-disposition 分发</span><br></pre></td></tr></table></figure><p>4.视频参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-vframes number 设置输出视频帧的数量</span><br><span class="line">-r rate 设置帧率（Hz）</span><br><span class="line">-s size 设置帧的大小 即宽x高WxH</span><br><span class="line">-aspect aspect 设置宽高比（4:3,16:9）</span><br><span class="line">-bits_per_raw_sample numer 设置每个原始样本的比特数</span><br><span class="line">-vn 禁用视频</span><br><span class="line">-vcodec codec 指定使用的视频编码复制到视频流中</span><br><span class="line">-timecode hh:mm:ss[:;,]ff 设置初始的时间值</span><br><span class="line">-pass n 选择处理次数（1 到3）</span><br><span class="line">-vf filter_graph 设置音频滤波器</span><br><span class="line">-ab bitrate 设置音频比特率（使用 -b:a）</span><br><span class="line">-b bitrate 设置视频比特率（使用 -b:v）</span><br><span class="line">-dn 禁用数据</span><br></pre></td></tr></table></figure><p>5.音频参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-aframes number 设置输出的音频帧的数量</span><br><span class="line">-aq quality 设置音频质量（编码器指定）</span><br><span class="line">-ar rate 设置音频采样率（Hz）</span><br><span class="line">-ac channels 设置音频声道数量</span><br><span class="line">-an 禁用视频</span><br><span class="line">-acodec codec 指定使用的音频编码复制到流中</span><br><span class="line">-vol volume 改变音量（正常是256）</span><br><span class="line">-af filter_graph 设置声音过滤器</span><br></pre></td></tr></table></figure><p>6.字幕参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-s size 设置帧大小WxH</span><br><span class="line">-sn 禁用字幕</span><br><span class="line">-scodec codec 指定使用的字幕编码复制到流中</span><br><span class="line">-stag furcc/tag 指定字幕tage /fourcc</span><br><span class="line">-fix_sub_duration 固定字幕持续时间</span><br><span class="line">-canvas_size size 设置画布大小WxH</span><br><span class="line">-spre preset 设置字幕选项展示预设的字幕</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过对ffmpeg源码编译安装得到下面几个文件夹&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVStream结构体</title>
    <link href="http://example.com/jsblog/6a8738f7.html"/>
    <id>http://example.com/jsblog/6a8738f7.html</id>
    <published>2020-12-20T04:08:20.000Z</published>
    <updated>2020-12-20T04:20:59.396Z</updated>
    
    <content type="html"><![CDATA[<p>AVStream是存储每一个视频/音频流信息的结构体。<a id="more"></a>本文分析一下该结构体里重要变量的含义和作用。该结构体位于avformat.h中，首先看一下结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVStream</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;    <span class="comment">/**&lt; stream index in AVFormatContext */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Format-specific stream ID.</span></span><br><span class="line"><span class="comment">     * decoding: set by libavformat</span></span><br><span class="line"><span class="comment">     * encoding: set by the user, replaced by libavformat if left unset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_AVCTX</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @deprecated use the codecpar struct instead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    AVCodecContext *codec;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment">     * of which frame timestamps are represented.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decoding: set by libavformat</span></span><br><span class="line"><span class="comment">     * encoding: May be set by the caller before avformat_write_header() to</span></span><br><span class="line"><span class="comment">     *           provide a hint to the muxer about the desired timebase. In</span></span><br><span class="line"><span class="comment">     *           avformat_write_header(), the muxer will overwrite this field</span></span><br><span class="line"><span class="comment">     *           with the timebase that will actually be used for the timestamps</span></span><br><span class="line"><span class="comment">     *           written into the file (which may or may not be related to the</span></span><br><span class="line"><span class="comment">     *           user-provided one, depending on the format).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational time_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.</span></span><br><span class="line"><span class="comment">     * Only set this if you are absolutely 100% sure that the value you set</span></span><br><span class="line"><span class="comment">     * it to really is the pts of the first frame.</span></span><br><span class="line"><span class="comment">     * This may be undefined (AV_NOPTS_VALUE).</span></span><br><span class="line"><span class="comment">     * @note The ASF header does NOT contain a correct start_time the ASF</span></span><br><span class="line"><span class="comment">     * demuxer must NOT set this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decoding: duration of the stream, in stream time base.</span></span><br><span class="line"><span class="comment">     * If a source file does not specify a duration, but does specify</span></span><br><span class="line"><span class="comment">     * a bitrate, this value will be estimated from bitrate and file size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Encoding: May be set by the caller before avformat_write_header() to</span></span><br><span class="line"><span class="comment">     * provide a hint to the muxer about the estimated duration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> nb_frames;                 <span class="comment">///&lt; number of frames in this stream if known or 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> disposition; <span class="comment">/**&lt; AV_DISPOSITION_* bit field */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> AVDiscard discard; <span class="comment">///&lt; Selects which packets can be discarded at will and do not need to be demuxed.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sample aspect ratio (0 if unknown)</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user.</span></span><br><span class="line"><span class="comment">     * - decoding: Set by libavformat.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational sample_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Average framerate</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: May be set by libavformat when creating the stream or in</span></span><br><span class="line"><span class="comment">     *             avformat_find_stream_info().</span></span><br><span class="line"><span class="comment">     * - muxing: May be set by the caller before avformat_write_header().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational avg_frame_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet</span></span><br><span class="line"><span class="comment">     * will contain the attached picture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decoding: set by libavformat, must not be modified by the caller.</span></span><br><span class="line"><span class="comment">     * encoding: unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVPacket attached_pic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An array of side data that applies to the whole stream (i.e. the</span></span><br><span class="line"><span class="comment">     * container does not allow it to change between packets).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * There may be no overlap between the side data in this array and side data</span></span><br><span class="line"><span class="comment">     * in the packets. I.e. a given side data is either exported by the muxer</span></span><br><span class="line"><span class="comment">     * (demuxing) / set by the caller (muxing) in this array, then it never</span></span><br><span class="line"><span class="comment">     * appears in the packets, or the side data is exported / sent through</span></span><br><span class="line"><span class="comment">     * the packets (always in the first packet where the value becomes known or</span></span><br><span class="line"><span class="comment">     * changes), then it does not appear in this array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: Set by libavformat when the stream is created.</span></span><br><span class="line"><span class="comment">     * - muxing: May be set by the caller before avformat_write_header().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Freed by libavformat in avformat_free_context().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @see av_format_inject_global_side_data()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of elements in the AVStream.side_data array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>            nb_side_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flags for the user to detect events happening on the stream. Flags must</span></span><br><span class="line"><span class="comment">     * be cleared by the user once the event has been handled.</span></span><br><span class="line"><span class="comment">     * A combination of AVSTREAM_EVENT_FLAG_*.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> event_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001 <span class="comment">///&lt; The call resulted in updated metadata.</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Real base framerate of the stream.</span></span><br><span class="line"><span class="comment">     * This is the lowest framerate with which all timestamps can be</span></span><br><span class="line"><span class="comment">     * represented accurately (it is the least common multiple of all</span></span><br><span class="line"><span class="comment">     * framerates in the stream). Note, this value is just a guess!</span></span><br><span class="line"><span class="comment">     * For example, if the time base is 1/90000 and all frames have either</span></span><br><span class="line"><span class="comment">     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational r_frame_rate;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_FFSERVER</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String containing pairs of key and values describing recommended encoder configuration.</span></span><br><span class="line"><span class="comment">     * Pairs are separated by &#x27;,&#x27;.</span></span><br><span class="line"><span class="comment">     * Keys are separated from values by &#x27;=&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @deprecated unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">char</span> *recommended_encoder_configuration;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Codec parameters associated with this stream. Allocated and freed by</span></span><br><span class="line"><span class="comment">     * libavformat in avformat_new_stream() and avformat_free_context()</span></span><br><span class="line"><span class="comment">     * respectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: filled by libavformat on stream creation or in</span></span><br><span class="line"><span class="comment">     *             avformat_find_stream_info()</span></span><br><span class="line"><span class="comment">     * - muxing: filled by the caller before avformat_write_header()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVCodecParameters *codecpar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****************************************************************</span></span><br><span class="line"><span class="comment">     * All fields below this line are not part of the public API. They</span></span><br><span class="line"><span class="comment">     * may not be used outside of libavformat and can be changed and</span></span><br><span class="line"><span class="comment">     * removed at will.</span></span><br><span class="line"><span class="comment">     * Internal note: be aware that physically removing these fields</span></span><br><span class="line"><span class="comment">     * will break ABI. Replace removed fields with dummy fields, and</span></span><br><span class="line"><span class="comment">     * add new fields to AVStreamInternal.</span></span><br><span class="line"><span class="comment">     *****************************************************************</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STD_TIMEBASES (30*12+30+3+6)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream information used internally by avformat_find_stream_info()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> last_dts;</span><br><span class="line">        <span class="keyword">int64_t</span> duration_gcd;</span><br><span class="line">        <span class="keyword">int</span> duration_count;</span><br><span class="line">        <span class="keyword">int64_t</span> rfps_duration_sum;</span><br><span class="line">        <span class="keyword">double</span> (*duration_error)[<span class="number">2</span>][MAX_STD_TIMEBASES];</span><br><span class="line">        <span class="keyword">int64_t</span> codec_info_duration;</span><br><span class="line">        <span class="keyword">int64_t</span> codec_info_duration_fields;</span><br><span class="line">        <span class="keyword">int</span> frame_delay_evidence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 0  -&gt; decoder has not been searched for yet.</span></span><br><span class="line"><span class="comment">         * &gt;0 -&gt; decoder found</span></span><br><span class="line"><span class="comment">         * &lt;0 -&gt; decoder with codec_id == -found_decoder has not been found</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> found_decoder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> last_duration;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Those are used for average framerate estimation.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int64_t</span> fps_first_dts;</span><br><span class="line">        <span class="keyword">int</span>     fps_first_dts_idx;</span><br><span class="line">        <span class="keyword">int64_t</span> fps_last_dts;</span><br><span class="line">        <span class="keyword">int</span>     fps_last_dts_idx;</span><br><span class="line"></span><br><span class="line">    &#125; *info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pts_wrap_bits; <span class="comment">/**&lt; number of bits in pts (used for wrapping control) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timestamp generation support:</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timestamp corresponding to the last dts sync point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Initialized when AVCodecParserContext.dts_sync_point &gt;= 0 and</span></span><br><span class="line"><span class="comment">     * a DTS is received from the underlying container. Otherwise set to</span></span><br><span class="line"><span class="comment">     * AV_NOPTS_VALUE by default.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> first_dts;</span><br><span class="line">    <span class="keyword">int64_t</span> cur_dts;</span><br><span class="line">    <span class="keyword">int64_t</span> last_IP_pts;</span><br><span class="line">    <span class="keyword">int</span> last_IP_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of packets to buffer for codec probing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> probe_packets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of frames that have been demuxed during avformat_find_stream_info()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> codec_info_nb_frames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* av_read_frame() support */</span></span><br><span class="line">    <span class="keyword">enum</span> AVStreamParseType need_parsing;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecParserContext</span> *<span class="title">parser</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * last packet in packet_buffer for this stream when muxing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVPacketList</span> *<span class="title">last_in_packet_buffer</span>;</span></span><br><span class="line">    AVProbeData probe_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REORDER_DELAY 16</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_buffer[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    AVIndexEntry *index_entries; <span class="comment">/**&lt; Only used if the format does not</span></span><br><span class="line"><span class="comment">                                    support seeking natively. */</span></span><br><span class="line">    <span class="keyword">int</span> nb_index_entries;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_entries_allocated_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream Identifier</span></span><br><span class="line"><span class="comment">     * This is the MPEG-TS stream identifier +1</span></span><br><span class="line"><span class="comment">     * 0 means unknown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> stream_identifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Details of the MPEG-TS program which created this stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> program_num;</span><br><span class="line">    <span class="keyword">int</span> pmt_version;</span><br><span class="line">    <span class="keyword">int</span> pmt_stream_idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> interleaver_chunk_size;</span><br><span class="line">    <span class="keyword">int64_t</span> interleaver_chunk_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stream probing state</span></span><br><span class="line"><span class="comment">     * -1   -&gt; probing finished</span></span><br><span class="line"><span class="comment">     *  0   -&gt; no probing requested</span></span><br><span class="line"><span class="comment">     * rest -&gt; perform probing with request_probe being the minimum score to accept.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> request_probe;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates that everything up to the next keyframe</span></span><br><span class="line"><span class="comment">     * should be discarded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> skip_to_keyframe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of samples to skip at the start of the frame decoded from the next packet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> skip_samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If not 0, the number of samples that should be skipped from the start of</span></span><br><span class="line"><span class="comment">     * the stream (the samples are removed from packets with pts==0, which also</span></span><br><span class="line"><span class="comment">     * assumes negative timestamps do not happen).</span></span><br><span class="line"><span class="comment">     * Intended for use with formats such as mp3 with ad-hoc gapless audio</span></span><br><span class="line"><span class="comment">     * support.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_skip_samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If not 0, the first audio sample that should be discarded from the stream.</span></span><br><span class="line"><span class="comment">     * This is broken by design (needs global sample count), but can&#x27;t be</span></span><br><span class="line"><span class="comment">     * avoided for broken by design formats such as mp3 with ad-hoc gapless</span></span><br><span class="line"><span class="comment">     * audio support.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> first_discard_sample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The sample after last sample that is intended to be discarded after</span></span><br><span class="line"><span class="comment">     * first_discard_sample. Works on frame boundaries only. Used to prevent</span></span><br><span class="line"><span class="comment">     * early EOF if the gapless info is broken (considered concatenated mp3s).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> last_discard_sample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of internally decoded frames, used internally in libavformat, do not access</span></span><br><span class="line"><span class="comment">     * its lifetime differs from info which is why it is not in that structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> nb_decoded_frames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timestamp offset added to timestamps before muxing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> mux_ts_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to check for wrapping of the time stamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_wrap_reference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Options for behavior, when a wrap is detected.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Defined by AV_PTS_WRAP_ values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If correction is enabled, there are two possibilities:</span></span><br><span class="line"><span class="comment">     * If the first time stamp is near the wrap point, the wrap offset</span></span><br><span class="line"><span class="comment">     * will be subtracted, which will create negative time stamps.</span></span><br><span class="line"><span class="comment">     * Otherwise the offset will be added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pts_wrap_behavior;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to prevent doing update_initial_durations() twice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> update_initial_durations_done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to generate dts from pts</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_reorder_error[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> pts_reorder_error_count[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to analyze DTS and detect faulty mpeg streams</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> last_dts_for_order_check;</span><br><span class="line">    <span class="keyword">uint8_t</span> dts_ordered;</span><br><span class="line">    <span class="keyword">uint8_t</span> dts_misordered;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to inject global side data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> inject_global_side_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * display aspect ratio (0 if unknown)</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by libavformat to calculate sample_aspect_ratio internally</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational display_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An opaque field for libavformat internal usage.</span></span><br><span class="line"><span class="comment">     * Must not be accessed in any way by callers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVStreamInternal *internal;</span><br><span class="line">&#125; AVStream;</span><br></pre></td></tr></table></figure><p>AVStream一些重要的变量如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index; 标识该音频/视频流</span><br><span class="line"><span class="keyword">int</span> id; 流的标识，依赖于具体的容器格式。解码libavformat,编码由用户设置，用户不设置则使用libavformat</span><br><span class="line">AVCodecContext *codec; 流对应与AVCodecContext结构，调用avformat_open_input设置</span><br><span class="line">AVRational time_base; 表示帧时间戳的基本单位。通过该值可以把PTS,DTS转化为真正的时间，其他结构体中也有这个字段，只有AVStream 中的time_base为真正的时间。</span><br><span class="line"><span class="keyword">int64_t</span> start_time; 流的起始时间，以流的基准时间为单位</span><br><span class="line"><span class="keyword">int64_t</span> duration; 流的持续时间，如果源文件未指定持续时间，但指定了比特率，则将根据比特率和文件大小估计该值。</span><br><span class="line"><span class="keyword">int64_t</span> nb_frames; 流中帧的数据，为<span class="number">0</span>或者已知</span><br><span class="line">AVDictionary *metadata; 元数据</span><br><span class="line">AVRational sample_aspect_ratio; 样本长宽比</span><br><span class="line">AVRational avg_frame_rate; 评价帧率，解封装时：在创建流时设置或者在avformat_find_stream_info()中设置；封装时调用avformat_write_header()设置</span><br><span class="line">AVCodecParameters *codecpar; 编解码器参数</span><br><span class="line"><span class="keyword">int64_t</span> first_dts; 第一个dts</span><br><span class="line"><span class="keyword">int64_t</span> cur_dts; 当前dts</span><br><span class="line"><span class="keyword">int</span> probe_packets; 编码器用户probe的包的个数</span><br><span class="line"><span class="keyword">int</span> codec_info_nb_frames; 在avformat_find_stream_info()期间已经解封装的帧数</span><br><span class="line">AVPacket attached_pic;附带的一些图片</span><br><span class="line"><span class="keyword">int</span> request_probe; 流探测状态，<span class="number">-1</span>表示完成，<span class="number">0</span>表示没有探测请求，rest执行探测</span><br><span class="line"><span class="keyword">int</span> skip_to_keyframe; 是否丢弃所有内容直接跳到关键帧</span><br><span class="line"><span class="keyword">int</span> skip_samples;在下一个数据表解码的帧开始要跳过的采样数</span><br><span class="line"><span class="keyword">int64_t</span> start_skip_samples;从流的开始要跳过的采样的数量</span><br><span class="line"><span class="keyword">int64_t</span> first_discard_sample; 如果不是<span class="number">0</span>，从流中丢弃第一个音频的样本</span><br><span class="line"><span class="keyword">int</span> nb_decoded_frames; 内部解码的帧数</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> pts_reorder_error[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> pts_reorder_error_count[MAX_REORDER_DELAY+<span class="number">1</span>]; 内部数据从pts到dts</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> last_dts_for_order_check; 内部数据用于分析dts和探测mpeg流的错误</span><br><span class="line"><span class="keyword">uint8_t</span> dts_ordered;</span><br><span class="line"><span class="keyword">uint8_t</span> dts_misordered;</span><br><span class="line"></span><br><span class="line">AVRational display_aspect_ratio; 显示的宽高比</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVStream是存储每一个视频/音频流信息的结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVCodecParameters结构体</title>
    <link href="http://example.com/jsblog/9c3dc76b.html"/>
    <id>http://example.com/jsblog/9c3dc76b.html</id>
    <published>2020-12-20T04:07:29.000Z</published>
    <updated>2020-12-20T04:20:59.392Z</updated>
    
    <content type="html"><![CDATA[<p>AVCodecParamteres结构体是将AVCodecContext中编解码器参数抽取出而形成的新的结构体，在新版本中的FFMPEG中，有些结构体中的AVCodecContext已经被弃用，取而代之的就是AVCodecParameters这个参数，该结构体定义在libavcodec/codec_par.h文件中，该结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecParameters</span> &#123;</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General type of the encoded data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">enum</span> AVMediaType codec_type;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specific type of the encoded data (the codec used).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">enum</span> AVCodecID codec_id;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Additional information about the codec (corresponds to the AVI FOURCC).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">uint32_t</span> codec_tag;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extra binary data needed for initializing the decoder, codec-dependent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be allocated with av_malloc() and will be freed by</span></span><br><span class="line"><span class="comment"> * avcodec_parameters_free(). The allocated size of extradata must be at</span></span><br><span class="line"><span class="comment"> * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding</span></span><br><span class="line"><span class="comment"> * bytes zeroed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">uint8_t</span> *extradata;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Size of the extradata content in bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> extradata_size;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - video: the pixel format, the value corresponds to enum AVPixelFormat.</span></span><br><span class="line"><span class="comment"> * - audio: the sample format, the value corresponds to enum AVSampleFormat.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> format;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The average bitrate of the encoded data (in bits per second).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int64_t</span> bit_rate;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of bits per sample in the codedwords.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is basically the bitrate per sample. It is mandatory for a bunch of</span></span><br><span class="line"><span class="comment"> * formats to actually decode them. It&#x27;s the number of bits for one sample in</span></span><br><span class="line"><span class="comment"> * the actual coded bitstream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This could be for example 4 for ADPCM</span></span><br><span class="line"><span class="comment"> * For PCM formats this matches bits_per_raw_sample</span></span><br><span class="line"><span class="comment"> * Can be 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> bits_per_coded_sample;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the number of valid bits in each output sample. If the</span></span><br><span class="line"><span class="comment"> * sample format has more bits, the least significant bits are additional</span></span><br><span class="line"><span class="comment"> * padding bits, which are always 0. Use right shifts to reduce the sample</span></span><br><span class="line"><span class="comment"> * to its actual size. For example, audio formats with 24 bit samples will</span></span><br><span class="line"><span class="comment"> * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.</span></span><br><span class="line"><span class="comment"> * To get the original sample use &quot;(int32_t)sample &gt;&gt; 8&quot;.&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For ADPCM this might be 12 or 16 or similar</span></span><br><span class="line"><span class="comment"> * Can be 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> bits_per_raw_sample;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Codec-specific bitstream restrictions that the stream conforms to.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">int</span> profile;</span><br><span class="line"> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Video only. The dimensions of the video frame in pixels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> width;</span><br><span class="line"> <span class="keyword">int</span> height;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Video only. The aspect ratio (width / height) which a single pixel</span></span><br><span class="line"><span class="comment"> * should have when displayed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the aspect ratio is unknown / undefined, the numerator should be</span></span><br><span class="line"><span class="comment"> * set to 0 (the denominator may have any value).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> AVRational sample_aspect_ratio;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Video only. The order of the fields in interlaced video.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">enum</span> AVFieldOrder field_order;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Video only. Additional colorspace characteristics.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">enum</span> AVColorRange color_range;</span><br><span class="line"> <span class="keyword">enum</span> AVColorPrimaries color_primaries;</span><br><span class="line"> <span class="keyword">enum</span> AVColorTransferCharacteristic color_trc;</span><br><span class="line"> <span class="keyword">enum</span> AVColorSpace color_space;</span><br><span class="line"> <span class="keyword">enum</span> AVChromaLocation chroma_location;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Video only. Number of delayed frames.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> video_delay;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. The channel layout bitmask. May be 0 if the channel layout is</span></span><br><span class="line"><span class="comment"> * unknown or unspecified, otherwise the number of bits set must be equal to</span></span><br><span class="line"><span class="comment"> * the channels field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">uint64_t</span> channel_layout;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. The number of audio channels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> channels;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. The number of audio samples per second.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> sample_rate;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. The number of bytes per coded audio frame, required by some</span></span><br><span class="line"><span class="comment"> * formats.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"> * Corresponds to nBlockAlign in WAVEFORMATEX.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> block_align;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. Audio frame size, if known. Required by some formats to be static.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> frame_size;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. The amount of padding (in samples) inserted by the encoder at</span></span><br><span class="line"><span class="comment"> * the beginning of the audio. I.e. this number of leading decoded samples</span></span><br><span class="line"><span class="comment"> * must be discarded by the caller to get the original audio without leading</span></span><br><span class="line"><span class="comment"> * padding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> initial_padding;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. The amount of padding (in samples) appended by the encoder to</span></span><br><span class="line"><span class="comment"> * the end of the audio. I.e. this number of decoded samples must be</span></span><br><span class="line"><span class="comment"> * discarded by the caller from the end of the stream to get the original</span></span><br><span class="line"><span class="comment"> * audio without any trailing padding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> trailing_padding;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Audio only. Number of samples to skip after a discontinuity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> seek_preroll;</span><br><span class="line">&#125; AVCodecParameters;</span><br></pre></td></tr></table></figure><p>因为AVCodecContext结构体包含的参数太多，AVCodecParameters将编码器的参数从AVCodecContext分离出来，AVCodecParameters结构体中部分重要的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVMediaType codec_type; 编解码器的类型 </span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodec</span> *<span class="title">codec</span>;</span> 编解码器,初始化后不可更改</span><br><span class="line"><span class="keyword">enum</span> AVCodecID codec_id; 编解码器的id</span><br><span class="line"><span class="keyword">int64_t</span> bit_rate; 平均比特率</span><br><span class="line"><span class="keyword">uint8_t</span> *extradata; <span class="keyword">int</span> extradata_size; 针对特定编码器包含的附加信息</span><br><span class="line">AVRational time_base; 根据该参数可以将pts转化为实践</span><br><span class="line"><span class="keyword">int</span> width, height; 每一帧的宽和高</span><br><span class="line"><span class="keyword">int</span> gop_size; 一组图片的数量，编码时用户设置，解码时不使用</span><br><span class="line"><span class="keyword">enum</span> AVPixelFormat pix_fmt; 像素格式，编码时用户设置，解码时可由用户指定，但是在分析数据会被覆盖用户的设置</span><br><span class="line"><span class="keyword">int</span> refs; 参考帧的数量</span><br><span class="line"><span class="keyword">enum</span> AVColorSpace colorspace; YUV色彩空间类型</span><br><span class="line"><span class="keyword">enum</span> AVColorRange color_range; MPEG JPEG YUV范围</span><br><span class="line"><span class="keyword">int</span> sample_rate; 采样率 仅音频</span><br><span class="line"><span class="keyword">int</span> channels; 声道数（音频）</span><br><span class="line"><span class="keyword">enum</span> AVSampleFormat sample_fmt; <span class="comment">//采样格式</span></span><br><span class="line"><span class="keyword">int</span> frame_size; 每个音频帧中每个声道的采样数量</span><br><span class="line"><span class="keyword">int</span> profile;配置类型</span><br><span class="line"><span class="keyword">int</span> level;级别</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AVCodecParamteres结构体是将AVCodecContext中编解码器参数抽取出而形成的新的结构体，在新版本中的FFMPEG中，有些结构体中的AVCodecContext已经被弃用，取而代之的就是AVCodecParameters这个参数，该结构体定义在liba</summary>
      
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVIOContext结构体</title>
    <link href="http://example.com/jsblog/33520746.html"/>
    <id>http://example.com/jsblog/33520746.html</id>
    <published>2020-12-20T04:06:33.000Z</published>
    <updated>2020-12-20T04:20:59.393Z</updated>
    
    <content type="html"><![CDATA[<p>AVIOContext是FFMPEG管理输入输出数据的结构体。<a id="more"></a>本文会详细分析一下这个结构体中的一些重要的变量的含义和作用。首先看一下结构体中的定义（该结构体位于libavformat/avio.h中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVIOContext</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A class for private options.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If this AVIOContext is created by avio_open2(), av_class is set and</span></span><br><span class="line"><span class="comment">     * passes the options down to protocols.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If this AVIOContext is manually allocated, then av_class may be set by</span></span><br><span class="line"><span class="comment">     * the caller.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * warning -- this field can be NULL, be sure to not pass this AVIOContext</span></span><br><span class="line"><span class="comment">     * to any av_opt_* functions in that case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following shows the relationship between buffer, buf_ptr,</span></span><br><span class="line"><span class="comment">     * buf_ptr_max, buf_end, buf_size, and pos, when reading and when writing</span></span><br><span class="line"><span class="comment">     * (since AVIOContext is used for both):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **********************************************************************************</span></span><br><span class="line"><span class="comment">     *                                   READING</span></span><br><span class="line"><span class="comment">     **********************************************************************************</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *                            |              buffer_size              |</span></span><br><span class="line"><span class="comment">     *                            |---------------------------------------|</span></span><br><span class="line"><span class="comment">     *                            |                                       |</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *                         buffer          buf_ptr       buf_end</span></span><br><span class="line"><span class="comment">     *                            +---------------+-----------------------+</span></span><br><span class="line"><span class="comment">     *                            |/ / / / / / / /|/ / / / / / /|         |</span></span><br><span class="line"><span class="comment">     *  read buffer:              |/ / consumed / | to be read /|         |</span></span><br><span class="line"><span class="comment">     *                            |/ / / / / / / /|/ / / / / / /|         |</span></span><br><span class="line"><span class="comment">     *                            +---------------+-----------------------+</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *                                                         pos</span></span><br><span class="line"><span class="comment">     *              +-------------------------------------------+-----------------+</span></span><br><span class="line"><span class="comment">     *  input file: |                                           |                 |</span></span><br><span class="line"><span class="comment">     *              +-------------------------------------------+-----------------+</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **********************************************************************************</span></span><br><span class="line"><span class="comment">     *                                   WRITING</span></span><br><span class="line"><span class="comment">     **********************************************************************************</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *                             |          buffer_size                 |</span></span><br><span class="line"><span class="comment">     *                             |--------------------------------------|</span></span><br><span class="line"><span class="comment">     *                             |                                      |</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *                                                buf_ptr_max</span></span><br><span class="line"><span class="comment">     *                          buffer                 (buf_ptr)       buf_end</span></span><br><span class="line"><span class="comment">     *                             +-----------------------+--------------+</span></span><br><span class="line"><span class="comment">     *                             |/ / / / / / / / / / / /|              |</span></span><br><span class="line"><span class="comment">     *  write buffer:              | / / to be flushed / / |              |</span></span><br><span class="line"><span class="comment">     *                             |/ / / / / / / / / / / /|              |</span></span><br><span class="line"><span class="comment">     *                             +-----------------------+--------------+</span></span><br><span class="line"><span class="comment">     *                               buf_ptr can be in this</span></span><br><span class="line"><span class="comment">     *                               due to a backward seek</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *                            pos</span></span><br><span class="line"><span class="comment">     *               +-------------+----------------------------------------------+</span></span><br><span class="line"><span class="comment">     *  output file: |             |                                              |</span></span><br><span class="line"><span class="comment">     *               +-------------+----------------------------------------------+</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;  <span class="comment">/**&lt; Start of the buffer. */</span></span><br><span class="line">    <span class="keyword">int</span> buffer_size;        <span class="comment">/**&lt; Maximum buffer size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_ptr; <span class="comment">/**&lt; Current position in the buffer */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_end; <span class="comment">/**&lt; End of the data, may be less than</span></span><br><span class="line"><span class="comment">                                 buffer+buffer_size if the read function returned</span></span><br><span class="line"><span class="comment">                                 less data than requested, e.g. for streams where</span></span><br><span class="line"><span class="comment">                                 no more data has been received yet. */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;           <span class="comment">/**&lt; A private pointer, passed to the read/write/seek/...</span></span><br><span class="line"><span class="comment">                                 functions. */</span></span><br><span class="line">    <span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size);</span><br><span class="line">    <span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*seek)(<span class="keyword">void</span> *opaque, <span class="keyword">int64_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int64_t</span> pos;            <span class="comment">/**&lt; position in the file of the current buffer */</span></span><br><span class="line">    <span class="keyword">int</span> eof_reached;        <span class="comment">/**&lt; true if was unable to read due to error or eof */</span></span><br><span class="line">    <span class="keyword">int</span> write_flag;         <span class="comment">/**&lt; true if open for writing */</span></span><br><span class="line">    <span class="keyword">int</span> max_packet_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> checksum;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *checksum_ptr;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*update_checksum)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> checksum, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> error;              <span class="comment">/**&lt; contains the error code or 0 if no error happened */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pause or resume playback for network streaming protocols - e.g. MMS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*read_pause)(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Seek to a given timestamp in stream with the specified stream_index.</span></span><br><span class="line"><span class="comment">     * Needed for some network streaming protocols which don&#x27;t support seeking</span></span><br><span class="line"><span class="comment">     * to byte position.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> (*read_seek)(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> stream_index,</span><br><span class="line">                         <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> seekable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max filesize, used to limit allocations</span></span><br><span class="line"><span class="comment">     * This field is internal to libavformat and access from outside is not allowed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> maxsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * avio_read and avio_write should if possible be satisfied directly</span></span><br><span class="line"><span class="comment">     * instead of going through a buffer, and avio_seek will always</span></span><br><span class="line"><span class="comment">     * call the underlying seek function directly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> direct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bytes read statistic</span></span><br><span class="line"><span class="comment">     * This field is internal to libavformat and access from outside is not allowed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> bytes_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * seek statistic</span></span><br><span class="line"><span class="comment">     * This field is internal to libavformat and access from outside is not allowed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> seek_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * writeout statistic</span></span><br><span class="line"><span class="comment">     * This field is internal to libavformat and access from outside is not allowed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> writeout_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Original buffer size</span></span><br><span class="line"><span class="comment">     * used internally after probing and ensure seekback to reset the buffer size</span></span><br><span class="line"><span class="comment">     * This field is internal to libavformat and access from outside is not allowed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> orig_buffer_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Threshold to favor readahead over seek.</span></span><br><span class="line"><span class="comment">     * This is current internal only, do not use from outside.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> short_seek_threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;,&#x27; separated list of allowed protocols.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;,&#x27; separated list of disallowed protocols.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callback that is used instead of write_packet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_data_type)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size,</span><br><span class="line">                           <span class="keyword">enum</span> AVIODataMarkerType type, <span class="keyword">int64_t</span> time);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If set, don&#x27;t call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,</span></span><br><span class="line"><span class="comment">     * but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly</span></span><br><span class="line"><span class="comment">     * small chunks of data returned from the callback).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ignore_boundary_point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal, not meant to be used from outside of AVIOContext.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVIODataMarkerType current_type;</span><br><span class="line">    <span class="keyword">int64_t</span> last_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callback that is used instead of short_seek_threshold.</span></span><br><span class="line"><span class="comment">     * This is current internal only, do not use from outside.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*short_seek_get)(<span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> written;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum reached position before a backward seek in the write buffer,</span></span><br><span class="line"><span class="comment">     * used keeping track of already written data for a later flush.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_ptr_max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Try to buffer at least this amount of data before flushing it</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> min_packet_size;</span><br><span class="line">&#125; AVIOContext;</span><br></pre></td></tr></table></figure><p>AVIOContext的相关调用都是在AVFormatContext中间触发的。</p><p>AVIOContext中一些比较重要的字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size); 读取音视频包的函数</span><br><span class="line"><span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size); 写入音视频包的函数</span><br><span class="line"><span class="keyword">int64_t</span> (*seek)(<span class="keyword">void</span> *opaque, <span class="keyword">int64_t</span> offset, <span class="keyword">int</span> whence); 跳转到指定的位置，offset为偏移</span><br><span class="line"><span class="keyword">void</span> *opaque; 一个私有指针传递给 read/write/seek…函数，paque指向了URLContext。URLContext结构体中还有一个结构体URLProtocol。</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer; 缓存开始位置</span><br><span class="line"><span class="keyword">int</span> buffer_size; 缓冲区大小</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_ptr; 当前缓冲区的位置</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_end; 缓存结束位置，可能会小于开始buffer+buffer_size</span><br><span class="line"><span class="keyword">int</span> (*read_pause)(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> pause); 暂停或恢复网络协议媒体的播放</span><br><span class="line"><span class="keyword">int64_t</span> pos; 当前缓冲区所在文中的位置</span><br><span class="line"><span class="keyword">int</span> eof_reached; 读到eof或者发生错误时为<span class="literal">true</span></span><br><span class="line"><span class="keyword">int</span> write_flag;  为写入的时候为<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>PS : 参考雷神博客</p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/leixiaohua1020/p/3901977.html">FFMPEG结构体分析：AVIOContext - leixiaohua1020 - 博客园www.cnblogs.com</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVIOContext是FFMPEG管理输入输出数据的结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVPacket结构体</title>
    <link href="http://example.com/jsblog/7229756e.html"/>
    <id>http://example.com/jsblog/7229756e.html</id>
    <published>2020-12-20T04:04:00.000Z</published>
    <updated>2020-12-20T04:20:59.395Z</updated>
    
    <content type="html"><![CDATA[<p>AVPacket是存储压缩编码数据相关信息的结构体。<a id="more"></a>AVPacket是FFmpeg中很重要的一个结构体，它保存了压缩后的数据以及这些数据的信息，比如显示时间戳pts,解码时间戳dts,每一帧持续的时间duration以及媒体流的索引等。</p><p>对于视频而言一个AVPacket通常是一个压缩的AVFrame，而一个音频AVPacket可能包含若干个AVFrame。当然也有可能AVPacket是一个空的，不包含任何数据仅仅包含sider data。（例如在编码结束时更新一些流的参数）。根据官方文档，AVPacket的大小是公开ABI的一部分，这样的结构体在FFmpeg中很少，因此它可能在栈中分配空间，并且如果libavcodec和libavformat没有较大的改动，那么AVPacket将不会添加新的字段。</p><p>AVPacket的定义如下（在libavcodec/packet.h文件中定义）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVPacket</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A reference to the reference-counted buffer where the packet data is</span></span><br><span class="line"><span class="comment">     * stored.</span></span><br><span class="line"><span class="comment">     * May be NULL, then the packet data is not reference-counted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Presentation timestamp in AVStream-&gt;time_base units; the time at which</span></span><br><span class="line"><span class="comment">     * the decompressed packet will be presented to the user.</span></span><br><span class="line"><span class="comment">     * Can be AV_NOPTS_VALUE if it is not stored in the file.</span></span><br><span class="line"><span class="comment">     * pts MUST be larger or equal to dts as presentation cannot happen before</span></span><br><span class="line"><span class="comment">     * decompression, unless one wants to view hex dumps. Some formats misuse</span></span><br><span class="line"><span class="comment">     * the terms dts and pts/cts to mean something different. Such timestamps</span></span><br><span class="line"><span class="comment">     * must be converted to true pts/dts before they are stored in AVPacket.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decompression timestamp in AVStream-&gt;time_base units; the time at which</span></span><br><span class="line"><span class="comment">     * the packet is decompressed.</span></span><br><span class="line"><span class="comment">     * Can be AV_NOPTS_VALUE if it is not stored in the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> dts;</span><br><span class="line">    <span class="keyword">uint8_t</span> *data;</span><br><span class="line">    <span class="keyword">int</span>   size;</span><br><span class="line">    <span class="keyword">int</span>   stream_index;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A combination of AV_PKT_FLAG values</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>   flags;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Additional packet data that can be provided by the container.</span></span><br><span class="line"><span class="comment">     * Packet can contain several types of side information.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="keyword">int</span> side_data_elems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Duration of this packet in AVStream-&gt;time_base units, 0 if unknown.</span></span><br><span class="line"><span class="comment">     * Equals next_pts - this_pts in presentation order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> pos;                            <span class="comment">///&lt; byte position in stream, -1 if unknown</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_CONVERGENCE_DURATION</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @deprecated Same as the duration field, but as int64_t. This was required</span></span><br><span class="line"><span class="comment">     * for Matroska subtitles, whose duration values could overflow when the</span></span><br><span class="line"><span class="comment">     * duration field was still an int.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int64_t</span> convergence_duration;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><p>AVPacket相比其他的结构体而言简单，但却是非常常用的一个。在AVPacket结构体中，重要的变量有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AVBufferRef *buf; 指向引用的数据，如果如<span class="literal">NULL</span>,那么packet中的data没被使用</span><br><span class="line"><span class="keyword">int64_t</span> pts; 显示时间戳</span><br><span class="line"><span class="keyword">int64_t</span> dts; 解码时间戳</span><br><span class="line"><span class="keyword">uint8_t</span> *data;压缩的编码数据</span><br><span class="line"><span class="keyword">int</span> size;data的大小</span><br><span class="line"><span class="keyword">int</span> stream_index; packet所在的流索引</span><br><span class="line"><span class="keyword">int</span> flags; 标志，其中最低为<span class="number">1</span>表示该数据是一个关键帧</span><br><span class="line">AVPacketSideData *side_data;Packet是一个容器，此字段说明额外的数据可以被packet提供</span><br><span class="line"><span class="keyword">int64_t</span> duration;数据的持续时长</span><br><span class="line"><span class="keyword">int64_t</span> pos; 数据在流中位置，<span class="number">-1</span>表示未知</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVPacket是存储压缩编码数据相关信息的结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVFrame结构体</title>
    <link href="http://example.com/jsblog/ed193d9d.html"/>
    <id>http://example.com/jsblog/ed193d9d.html</id>
    <published>2020-12-20T04:03:04.000Z</published>
    <updated>2020-12-20T04:20:59.415Z</updated>
    
    <content type="html"><![CDATA[<p>AVFrame结构体是存储音视频原始数据（即未被编码的数据）的结构体。<a id="more"></a>该结构体位于libavutil/frame.h中。分析一下结构体中里的重要变量的含义和作用，首先看一下结构体的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFrame</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NUM_DATA_POINTERS 8</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pointer to the picture/channel planes.</span></span><br><span class="line"><span class="comment">     * This might be different from the first allocated byte</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some decoders access areas outside 0,0 - width,height, please</span></span><br><span class="line"><span class="comment">     * see avcodec_align_dimensions2(). Some filters and swscale can read</span></span><br><span class="line"><span class="comment">     * up to 16 bytes beyond the planes, if these filters are to be used,</span></span><br><span class="line"><span class="comment">     * then 16 extra bytes must be allocated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> Except for hwaccel formats, pointers not needed by the format</span></span><br><span class="line"><span class="comment">     * MUST be set to NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For video, size in bytes of each picture line.</span></span><br><span class="line"><span class="comment">     * For audio, size in bytes of each plane.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For audio, only linesize[0] may be set. For planar audio, each channel</span></span><br><span class="line"><span class="comment">     * plane must be the same size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For video the linesizes should be multiples of the CPUs alignment</span></span><br><span class="line"><span class="comment">     * preference, this is 16 or 32 for modern desktop CPUs.</span></span><br><span class="line"><span class="comment">     * Some code requires such alignment other code can be slower without</span></span><br><span class="line"><span class="comment">     * correct alignment, for yet other it makes no difference.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note The linesize may be larger than the size of usable data -- there</span></span><br><span class="line"><span class="comment">     * may be extra padding present for performance reasons.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> linesize[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pointers to the data planes/channels.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For video, this should simply point to data[].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For planar audio, each channel has a separate data pointer, and</span></span><br><span class="line"><span class="comment">     * linesize[0] contains the size of each channel buffer.</span></span><br><span class="line"><span class="comment">     * For packed audio, there is just one data pointer, and linesize[0]</span></span><br><span class="line"><span class="comment">     * contains the total size of the buffer for all channels.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note: Both data and extended_data should always be set in a valid frame,</span></span><br><span class="line"><span class="comment">     * but for planar audio with more channels that can fit in data,</span></span><br><span class="line"><span class="comment">     * extended_data must be used in order to access all channels.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> **extended_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @name Video dimensions</span></span><br><span class="line"><span class="comment">     * Video frames only. The coded dimensions (in pixels) of the video frame,</span></span><br><span class="line"><span class="comment">     * i.e. the size of the rectangle that contains some well-defined values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note The part of the frame intended for display/presentation is further</span></span><br><span class="line"><span class="comment">     * restricted by the @ref cropping &quot;Cropping rectangle&quot;.</span></span><br><span class="line"><span class="comment">     * @&#123;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> width, height;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * number of audio samples (per channel) described by this frame</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> nb_samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * format of the frame, -1 if unknown or unset</span></span><br><span class="line"><span class="comment">     * Values correspond to enum AVPixelFormat for video frames,</span></span><br><span class="line"><span class="comment">     * enum AVSampleFormat for audio)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 -&gt; keyframe, 0-&gt; not</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> key_frame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Picture type of the frame.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVPictureType pict_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational sample_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Presentation timestamp in time_base units (time when frame should be shown to user).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PKT_PTS</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PTS copied from the AVPacket that was decoded to produce this frame.</span></span><br><span class="line"><span class="comment">     * @deprecated use the pts field instead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int64_t</span> pkt_pts;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn&#x27;t used)</span></span><br><span class="line"><span class="comment">     * This is also the Presentation time of this AVFrame calculated from</span></span><br><span class="line"><span class="comment">     * only AVPacket.dts values without pts values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pkt_dts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * picture number in bitstream order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> coded_picture_number;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * picture number in display order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> display_picture_number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * quality (between 1 (good) and FF_LAMBDA_MAX (bad))</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> quality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * for some private data of the user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_ERROR_FRAME</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @deprecated unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">uint64_t</span> error[AV_NUM_DATA_POINTERS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When decoding, this signals how much the picture must be delayed.</span></span><br><span class="line"><span class="comment">     * extra_delay = repeat_pict / (2*fps)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> repeat_pict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The content of the picture is interlaced.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> interlaced_frame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If the content is interlaced, is top field displayed first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> top_field_first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tell user application that palette has changed from previous frame.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> palette_has_changed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reordered opaque 64 bits (generally an integer or a double precision float</span></span><br><span class="line"><span class="comment">     * PTS but can be anything).</span></span><br><span class="line"><span class="comment">     * The user sets AVCodecContext.reordered_opaque to represent the input at</span></span><br><span class="line"><span class="comment">     * that time,</span></span><br><span class="line"><span class="comment">     * the decoder reorders values as needed and sets AVFrame.reordered_opaque</span></span><br><span class="line"><span class="comment">     * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> reordered_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sample rate of the audio data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> sample_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Channel layout of the audio data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> channel_layout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AVBuffer references backing the data for this frame. If all elements of</span></span><br><span class="line"><span class="comment">     * this array are NULL, then this frame is not reference counted. This array</span></span><br><span class="line"><span class="comment">     * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must</span></span><br><span class="line"><span class="comment">     * also be non-NULL for all j &lt; i.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * There may be at most one AVBuffer per data plane, so for video this array</span></span><br><span class="line"><span class="comment">     * always contains all the references. For planar audio with more than</span></span><br><span class="line"><span class="comment">     * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in</span></span><br><span class="line"><span class="comment">     * this array. Then the extra AVBufferRef pointers are stored in the</span></span><br><span class="line"><span class="comment">     * extended_buf array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVBufferRef *buf[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For planar audio which requires more than AV_NUM_DATA_POINTERS</span></span><br><span class="line"><span class="comment">     * AVBufferRef pointers, this array will hold all the references which</span></span><br><span class="line"><span class="comment">     * cannot fit into AVFrame.buf.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this is different from AVFrame.extended_data, which always</span></span><br><span class="line"><span class="comment">     * contains all the pointers. This array only contains the extra pointers,</span></span><br><span class="line"><span class="comment">     * which cannot fit into AVFrame.buf.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This array is always allocated using av_malloc() by whoever constructs</span></span><br><span class="line"><span class="comment">     * the frame. It is freed in av_frame_unref().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVBufferRef **extended_buf;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of elements in extended_buf.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>        nb_extended_buf;</span><br><span class="line"></span><br><span class="line">    AVFrameSideData **side_data;</span><br><span class="line">    <span class="keyword">int</span>            nb_side_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @defgroup lavu_frame_flags AV_FRAME_FLAGS</span></span><br><span class="line"><span class="comment"> * @ingroup lavu_frame</span></span><br><span class="line"><span class="comment"> * Flags describing additional frame properties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The frame data may be corrupted, e.g. due to decoding errors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_FRAME_FLAG_CORRUPT       (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag to mark the frames which need to be decoded, but shouldn&#x27;t be output.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_FRAME_FLAG_DISCARD   (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Frame flags, a combination of @ref lavu_frame_flags</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MPEG vs JPEG YUV range.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user</span></span><br><span class="line"><span class="comment">     * - decoding: Set by libavcodec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVColorRange color_range;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> AVColorPrimaries color_primaries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> AVColorTransferCharacteristic color_trc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * YUV colorspace type.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user</span></span><br><span class="line"><span class="comment">     * - decoding: Set by libavcodec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVColorSpace colorspace;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> AVChromaLocation chroma_location;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * frame timestamp estimated using various heuristics, in stream time base</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by libavcodec, read by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> best_effort_timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reordered pos from the last AVPacket that has been input into the decoder</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Read by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pkt_pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * duration of the corresponding packet, expressed in</span></span><br><span class="line"><span class="comment">     * AVStream-&gt;time_base units, 0 if unknown.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Read by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pkt_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * metadata.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user.</span></span><br><span class="line"><span class="comment">     * - decoding: Set by libavcodec.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * decode error flags of the frame, set to a combination of</span></span><br><span class="line"><span class="comment">     * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there</span></span><br><span class="line"><span class="comment">     * were errors during the decoding.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by libavcodec, read by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> decode_error_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DECODE_ERROR_INVALID_BITSTREAM   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DECODE_ERROR_MISSING_REFERENCE   2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DECODE_ERROR_CONCEALMENT_ACTIVE  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DECODE_ERROR_DECODE_SLICES       8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * number of audio channels, only used for audio.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Read by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> channels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * size of the corresponding packet containing the compressed</span></span><br><span class="line"><span class="comment">     * frame.</span></span><br><span class="line"><span class="comment">     * It is set to a negative value if unknown.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by libavcodec, read by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pkt_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_FRAME_QP</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * QP table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int8_t</span> *qscale_table;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * QP store stride</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> qstride;</span><br><span class="line"></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> qscale_type;</span><br><span class="line"></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    AVBufferRef *qp_table_buf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For hwaccel-format frames, this should be a reference to the</span></span><br><span class="line"><span class="comment">     * AVHWFramesContext describing the frame.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVBufferRef *hw_frames_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AVBufferRef for free use by the API user. FFmpeg will never check the</span></span><br><span class="line"><span class="comment">     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when</span></span><br><span class="line"><span class="comment">     * the frame is unreferenced. av_frame_copy_props() calls create a new</span></span><br><span class="line"><span class="comment">     * reference with av_buffer_ref() for the target frame&#x27;s opaque_ref field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is unrelated to the opaque field, although it serves a similar</span></span><br><span class="line"><span class="comment">     * purpose.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVBufferRef *opaque_ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @anchor cropping</span></span><br><span class="line"><span class="comment">     * @name Cropping</span></span><br><span class="line"><span class="comment">     * Video frames only. The number of pixels to discard from the the</span></span><br><span class="line"><span class="comment">     * top/bottom/left/right border of the frame to obtain the sub-rectangle of</span></span><br><span class="line"><span class="comment">     * the frame intended for presentation.</span></span><br><span class="line"><span class="comment">     * @&#123;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">size_t</span> crop_top;</span><br><span class="line">    <span class="keyword">size_t</span> crop_bottom;</span><br><span class="line">    <span class="keyword">size_t</span> crop_left;</span><br><span class="line">    <span class="keyword">size_t</span> crop_right;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AVBufferRef for internal use by a single libav* library.</span></span><br><span class="line"><span class="comment">     * Must not be used to transfer data between libraries.</span></span><br><span class="line"><span class="comment">     * Has to be NULL when ownership of the frame leaves the respective library.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Code outside the FFmpeg libs should never check or change the contents of the buffer ref.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.</span></span><br><span class="line"><span class="comment">     * av_frame_copy_props() calls create a new reference with av_buffer_ref()</span></span><br><span class="line"><span class="comment">     * for the target frame&#x27;s private_ref field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVBufferRef *private_ref;</span><br><span class="line">&#125; AVFrame;</span><br></pre></td></tr></table></figure><p>AVFrame结构体一般是用来存储原始数据（视频数据是YUV 和RGB，音频数据是PCM）。编码的时候也存储了一些相关的信息，在使用ffmpeg进行开发的时候，AVFrame是一个很重要的结构体。</p><p>接下来我们看下结构体中重要的变量和作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *data[AV_NUM_DATA_POINTERS]; 解码后的原始数据，视频数据是YUV 和RGB，音频数据是PCM）</span><br><span class="line"><span class="keyword">int</span> linesize[AV_NUM_DATA_POINTERS];data中“一行“数据的大小，一般大于图像的宽</span><br><span class="line"><span class="keyword">int</span> width, height; 对视频而言指视频的宽和高</span><br><span class="line"><span class="keyword">int</span> nb_samples; 音频中一个AVFrame包含多个音频帧，表示音频帧的数量</span><br><span class="line"><span class="keyword">int</span> format; 帧的格式，原始数据的类型</span><br><span class="line"><span class="keyword">int</span> key_frame; 是否为关键帧</span><br><span class="line"><span class="keyword">enum</span> AVPictureType pict_type; 帧的类型</span><br><span class="line">AVRational sample_aspect_ratio; 宽高比</span><br><span class="line"><span class="keyword">int64_t</span> pts; 显示时间戳</span><br><span class="line"><span class="keyword">int64_t</span> pkt_dts;每一帧的时间</span><br><span class="line"><span class="keyword">int</span> coded_picture_number;编码帧的序号</span><br><span class="line"><span class="keyword">int</span> display_picture_number;显示帧的序号</span><br><span class="line"><span class="keyword">int</span> sample_rate; 采样率（音频）</span><br><span class="line"><span class="keyword">uint64_t</span> channel_layout; 声道格式（音频）</span><br><span class="line"><span class="keyword">int</span> channels; 声道数量（编码未使用），解码只读</span><br><span class="line"><span class="keyword">int</span> interlaced_frame;是否隔行扫描</span><br><span class="line"><span class="keyword">int8_t</span> *qscale_table;QP表</span><br><span class="line"><span class="keyword">int</span> quality; 帧的质量，<span class="number">1</span>表示好 FF_LAMBDA_MAX表示bad</span><br><span class="line"><span class="keyword">enum</span> AVColorRange color_range; MPEG,JPEG,YUV的色彩范围</span><br><span class="line"><span class="keyword">enum</span> AVColorSpace colorspace; YUV的色彩空间</span><br><span class="line"><span class="keyword">int64_t</span> pkt_duration; 相关包的流逝时间</span><br><span class="line">AVDictionary *metadata;元数据</span><br></pre></td></tr></table></figure><p>其他的变量不再一一列举，重点学习一下一定要理解的数据：</p><p>\1. uint8_t *data[AV_NUM_DATA_POINTERS]；</p><p>对于packed格式的数据会存到data[0]中,例如RGB24</p><p>对于plannar格式的数据会存到data[0],data[1]…,例如YUV420P，会分开存到Y : data[0],U :data[1],V:data[2]</p><p>\2. enum AVPictureType pict_type;包含以下类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVPictureType &#123;</span><br><span class="line"> AV_PICTURE_TYPE_NONE = <span class="number">0</span>, <span class="comment">///&lt; Undefined</span></span><br><span class="line"> AV_PICTURE_TYPE_I, <span class="comment">///&lt; Intra</span></span><br><span class="line"> AV_PICTURE_TYPE_P, <span class="comment">///&lt; Predicted</span></span><br><span class="line"> AV_PICTURE_TYPE_B, <span class="comment">///&lt; Bi-dir predicted</span></span><br><span class="line"> AV_PICTURE_TYPE_S, <span class="comment">///&lt; S(GMC)-VOP MPEG-4</span></span><br><span class="line"> AV_PICTURE_TYPE_SI, <span class="comment">///&lt; Switching Intra</span></span><br><span class="line"> AV_PICTURE_TYPE_SP, <span class="comment">///&lt; Switching Predicted</span></span><br><span class="line"> AV_PICTURE_TYPE_BI, <span class="comment">///&lt; BI type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>\3. AVRational sample_aspect_ratio;</p><p>宽高比是一个分数，FFMPEG中使用AVRational表示分数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator</span></span><br><span class="line"> <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>\4. int8_t *qscale_table;</p><p>QP表指向一块内存，里面存储的是每个宏块的QP值。宏块的标号是从左往右，一行一行的来的。每个宏块对应1个QP。qscale_table[0]就是第1行第1列宏块的QP值；qscale_table[1]就是第1行第2列宏块的QP值；qscale_table[2]就是第1行第3列宏块的QP值。以此类推…</p><p>宏块的个数用下式计算：</p><p>注：宏块大小是16x16的。</p><p>每行宏块数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mb_stride = pCodecCtx-&gt;width/<span class="number">16</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>宏块的总数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mb_sum = ((pCodecCtx-&gt;height+<span class="number">15</span>)&gt;&gt;<span class="number">4</span>)*(pCodecCtx-&gt;width/<span class="number">16</span>+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>5.uint64_t channel_layout; 声道格式（音频）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_FRONT_LEFT             0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_FRONT_RIGHT            0x00000002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_FRONT_CENTER           0x00000004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LOW_FREQUENCY          0x00000008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_BACK_LEFT              0x00000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_BACK_RIGHT             0x00000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_FRONT_LEFT_OF_CENTER   0x00000040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_FRONT_RIGHT_OF_CENTER  0x00000080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_BACK_CENTER            0x00000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_SIDE_LEFT              0x00000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_SIDE_RIGHT             0x00000400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_CENTER             0x00000800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_FRONT_LEFT         0x00001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_FRONT_CENTER       0x00002000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_FRONT_RIGHT        0x00004000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_BACK_LEFT          0x00008000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_BACK_CENTER        0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_TOP_BACK_RIGHT         0x00020000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_STEREO_LEFT            0x20000000  <span class="comment">///&lt; Stereo downmix.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_STEREO_RIGHT           0x40000000  <span class="comment">///&lt; See AV_CH_STEREO_LEFT.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_WIDE_LEFT              0x0000000080000000ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_WIDE_RIGHT             0x0000000100000000ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_SURROUND_DIRECT_LEFT   0x0000000200000000ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_SURROUND_DIRECT_RIGHT  0x0000000400000000ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LOW_FREQUENCY_2        0x0000000800000000ULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Channel mask value used for AVCodecContext.request_channel_layout</span></span><br><span class="line"><span class="comment">    to indicate that the user requests the channel order of the decoder output</span></span><br><span class="line"><span class="comment">    to be the native codec channel order. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_NATIVE          0x8000000000000000ULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> * @defgroup channel_mask_c Audio channel layouts</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_MONO              (AV_CH_FRONT_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_STEREO            (AV_CH_FRONT_LEFT|AV_CH_FRONT_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_2POINT1           (AV_CH_LAYOUT_STEREO|AV_CH_LOW_FREQUENCY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_2_1               (AV_CH_LAYOUT_STEREO|AV_CH_BACK_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_SURROUND          (AV_CH_LAYOUT_STEREO|AV_CH_FRONT_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_3POINT1           (AV_CH_LAYOUT_SURROUND|AV_CH_LOW_FREQUENCY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_4POINT0           (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_4POINT1           (AV_CH_LAYOUT_4POINT0|AV_CH_LOW_FREQUENCY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_2_2               (AV_CH_LAYOUT_STEREO|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_QUAD              (AV_CH_LAYOUT_STEREO|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_5POINT0           (AV_CH_LAYOUT_SURROUND|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_5POINT1           (AV_CH_LAYOUT_5POINT0|AV_CH_LOW_FREQUENCY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_5POINT0_BACK      (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_5POINT1_BACK      (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_LOW_FREQUENCY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_6POINT0           (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_6POINT0_FRONT     (AV_CH_LAYOUT_2_2|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_HEXAGONAL         (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_BACK_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_6POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_6POINT1_BACK      (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_BACK_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_6POINT1_FRONT     (AV_CH_LAYOUT_6POINT0_FRONT|AV_CH_LOW_FREQUENCY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_7POINT0           (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_7POINT0_FRONT     (AV_CH_LAYOUT_5POINT0|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_7POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_7POINT1_WIDE      (AV_CH_LAYOUT_5POINT1|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_7POINT1_WIDE_BACK (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_OCTAGONAL         (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_CENTER|AV_CH_BACK_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_HEXADECAGONAL     (AV_CH_LAYOUT_OCTAGONAL|AV_CH_WIDE_LEFT|AV_CH_WIDE_RIGHT|AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_RIGHT|AV_CH_TOP_BACK_CENTER|AV_CH_TOP_FRONT_CENTER|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CH_LAYOUT_STEREO_DOWNMIX    (AV_CH_STEREO_LEFT|AV_CH_STEREO_RIGHT)</span></span><br></pre></td></tr></table></figure><p>PS: 参考雷神博客<a href="https://link.zhihu.com/?target=https://blog.csdn.net/leixiaohua1020/article/details/14214577">FFMPEG结构体分析：AVFrame_雷霄骅(leixiaohua1020)的专栏-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVFrame结构体是存储音视频原始数据（即未被编码的数据）的结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFFMPEG" scheme="http://example.com/tags/FFFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVCodec结构体</title>
    <link href="http://example.com/jsblog/b5ef7346.html"/>
    <id>http://example.com/jsblog/b5ef7346.html</id>
    <published>2020-12-20T04:02:28.000Z</published>
    <updated>2020-12-20T04:20:59.411Z</updated>
    
    <content type="html"><![CDATA[<p>AVCodec结构体是存储编解码器信息的结构体。<a id="more"></a>该结构体位于codec.h中。分析一下结构体中里的每个变量的含义和作用，首先看一下结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodec</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Name of the codec implementation.</span></span><br><span class="line"><span class="comment">     * The name is globally unique among encoders and among decoders (but an</span></span><br><span class="line"><span class="comment">     * encoder and a decoder can share the same name).</span></span><br><span class="line"><span class="comment">     * This is the primary way to find a codec from the user perspective.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Descriptive name for the codec, meant to be more human readable than name.</span></span><br><span class="line"><span class="comment">     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *long_name;</span><br><span class="line">    <span class="keyword">enum</span> AVMediaType type;</span><br><span class="line">    <span class="keyword">enum</span> AVCodecID id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Codec capabilities.</span></span><br><span class="line"><span class="comment">     * see AV_CODEC_CAP_*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> capabilities;</span><br><span class="line">    <span class="keyword">const</span> AVRational *supported_framerates; <span class="comment">///&lt; array of supported framerates, or NULL if any, array is terminated by &#123;0,0&#125;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat *pix_fmts;     <span class="comment">///&lt; array of supported pixel formats, or NULL if unknown, array is terminated by -1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *supported_samplerates;       <span class="comment">///&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">enum</span> AVSampleFormat *sample_fmts; <span class="comment">///&lt; array of supported sample formats, or NULL if unknown, array is terminated by -1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> *channel_layouts;         <span class="comment">///&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0</span></span><br><span class="line">    <span class="keyword">uint8_t</span> max_lowres;                     <span class="comment">///&lt; maximum value for lowres supported by the decoder</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_class;              <span class="comment">///&lt; AVClass for the private context</span></span><br><span class="line">    <span class="keyword">const</span> AVProfile *profiles;              <span class="comment">///&lt; array of recognized profiles, or NULL if unknown, array is terminated by &#123;FF_PROFILE_UNKNOWN&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Group name of the codec implementation.</span></span><br><span class="line"><span class="comment">     * This is a short symbolic name of the wrapper backing this codec. A</span></span><br><span class="line"><span class="comment">     * wrapper uses some kind of external implementation for the codec, such</span></span><br><span class="line"><span class="comment">     * as an external library, or a codec implementation provided by the OS or</span></span><br><span class="line"><span class="comment">     * the hardware.</span></span><br><span class="line"><span class="comment">     * If this field is NULL, this is a builtin, libavcodec native codec.</span></span><br><span class="line"><span class="comment">     * If non-NULL, this will be the suffix in AVCodec.name in most cases</span></span><br><span class="line"><span class="comment">     * (usually AVCodec.name will be of the form &quot;&lt;codec_name&gt;_&lt;wrapper_name&gt;&quot;).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *wrapper_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****************************************************************</span></span><br><span class="line"><span class="comment">     * No fields below this line are part of the public API. They</span></span><br><span class="line"><span class="comment">     * may not be used outside of libavcodec and can be changed and</span></span><br><span class="line"><span class="comment">     * removed at will.</span></span><br><span class="line"><span class="comment">     * New public fields should be added right above.</span></span><br><span class="line"><span class="comment">     *****************************************************************</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVCodec</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @name Frame-level threading support functions</span></span><br><span class="line"><span class="comment">     * @&#123;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy necessary context variables from a previous thread context to the current one.</span></span><br><span class="line"><span class="comment">     * If not defined, the next thread will start automatically; otherwise, the codec</span></span><br><span class="line"><span class="comment">     * must call ff_thread_finish_setup().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*update_thread_context)(struct AVCodecContext *dst, <span class="keyword">const</span> struct AVCodecContext *src);</span><br><span class="line">    <span class="comment">/** @&#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Private codec-specific defaults.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> AVCodecDefault *defaults;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize codec static data, called from avcodec_register().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is not intended for time consuming operations as it is</span></span><br><span class="line"><span class="comment">     * run for every codec regardless of that codec being used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*init_static_data)(struct AVCodec *codec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*init)(struct AVCodecContext *);</span><br><span class="line">    <span class="keyword">int</span> (*encode_sub)(struct AVCodecContext *, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size,</span><br><span class="line">                      <span class="keyword">const</span> struct AVSubtitle *sub);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Encode data to an AVPacket.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param      avctx          codec context</span></span><br><span class="line"><span class="comment">     * @param      avpkt          output AVPacket (may contain a user-provided buffer)</span></span><br><span class="line"><span class="comment">     * @param[in]  frame          AVFrame containing the raw data to be encoded</span></span><br><span class="line"><span class="comment">     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a</span></span><br><span class="line"><span class="comment">     *                            non-empty packet was returned in avpkt.</span></span><br><span class="line"><span class="comment">     * @return 0 on success, negative error code on failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*encode2)(struct AVCodecContext *avctx, struct AVPacket *avpkt,</span><br><span class="line">                   <span class="keyword">const</span> struct AVFrame *frame, <span class="keyword">int</span> *got_packet_ptr);</span><br><span class="line">    <span class="keyword">int</span> (*decode)(struct AVCodecContext *, <span class="keyword">void</span> *outdata, <span class="keyword">int</span> *outdata_size, struct AVPacket *avpkt);</span><br><span class="line">    <span class="keyword">int</span> (*close)(struct AVCodecContext *);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Encode API with decoupled packet/frame dataflow. The API is the</span></span><br><span class="line"><span class="comment">     * same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except</span></span><br><span class="line"><span class="comment">     * that:</span></span><br><span class="line"><span class="comment">     * - never called if the codec is closed or the wrong type,</span></span><br><span class="line"><span class="comment">     * - if AV_CODEC_CAP_DELAY is not set, drain frames are never sent,</span></span><br><span class="line"><span class="comment">     * - only one drain frame is ever passed down,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*send_frame)(struct AVCodecContext *avctx, <span class="keyword">const</span> struct AVFrame *frame);</span><br><span class="line">    <span class="keyword">int</span> (*receive_packet)(struct AVCodecContext *avctx, struct AVPacket *avpkt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decode API with decoupled packet/frame dataflow. This function is called</span></span><br><span class="line"><span class="comment">     * to get one output frame. It should call ff_decode_get_packet() to obtain</span></span><br><span class="line"><span class="comment">     * input data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*receive_frame)(struct AVCodecContext *avctx, struct AVFrame *frame);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flush buffers.</span></span><br><span class="line"><span class="comment">     * Will be called when seeking</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush)(struct AVCodecContext *);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal codec capabilities.</span></span><br><span class="line"><span class="comment">     * See FF_CODEC_CAP_* in internal.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> caps_internal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decoding only, a comma-separated list of bitstream filters to apply to</span></span><br><span class="line"><span class="comment">     * packets before decoding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bsfs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Array of pointers to hardware configurations supported by the codec,</span></span><br><span class="line"><span class="comment">     * or NULL if no hardware supported.  The array is terminated by a NULL</span></span><br><span class="line"><span class="comment">     * pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The user can only access this field via avcodec_get_hw_config().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecHWConfigInternal</span> **<span class="title">hw_configs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of supported codec_tags, terminated by FF_CODEC_TAGS_END.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> *codec_tags;</span><br><span class="line">&#125; AVCodec;</span><br></pre></td></tr></table></figure><p>来看一下结构体中几个重要的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name; 编解码器的名称，较短</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *long_name; 编解码器的全称</span><br><span class="line"><span class="keyword">enum</span> AVMediaType type; 多媒体的类型，视频，音频或者字幕</span><br><span class="line"><span class="keyword">enum</span> AVCodecID id; 编解码器的ID,在上一篇文章中介绍过</span><br><span class="line"><span class="keyword">int</span> capabilities; 解码能力</span><br><span class="line"><span class="keyword">const</span> AVRational *supported_framerates; 支持的帧率（仅视频）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat *pix_fmts; 支持的像素格式（仅视频）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *supported_samplerates;  支持的采样率（仅音频）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> AVSampleFormat *sample_fmts; 采样格式 （仅音频）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> *channel_layouts； 支持的声道数（仅音频）</span><br><span class="line"><span class="keyword">int</span> priv_data_size; 私有数据大小</span><br><span class="line"><span class="keyword">const</span> AVProfile *profiles; 可识别的型 在一篇文章中提到过</span><br></pre></td></tr></table></figure><p>详细介绍几个变量：</p><p>\1. enum AVMediaType type</p><p>AVMediaType定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVMediaType &#123;</span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>\2. enum AVCodecID codec_id</p><p>AVCodecID 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVCodecID &#123;</span><br><span class="line">    AV_CODEC_ID_NONE,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* video codecs */</span></span><br><span class="line">    AV_CODEC_ID_MPEG1VIDEO,</span><br><span class="line">    AV_CODEC_ID_MPEG2VIDEO, <span class="comment">///&lt; preferred ID for MPEG-1/2 video decoding</span></span><br><span class="line">    AV_CODEC_ID_H261,</span><br><span class="line">    AV_CODEC_ID_H263,</span><br><span class="line">    AV_CODEC_ID_RV10,</span><br><span class="line">    AV_CODEC_ID_RV20,</span><br><span class="line">    AV_CODEC_ID_MJPEG,</span><br><span class="line">    AV_CODEC_ID_MJPEGB,</span><br><span class="line">    AV_CODEC_ID_LJPEG,</span><br><span class="line">    AV_CODEC_ID_SP5X,</span><br><span class="line">    AV_CODEC_ID_JPEGLS,</span><br><span class="line">    AV_CODEC_ID_MPEG4,</span><br><span class="line">    AV_CODEC_ID_RAWVIDEO,</span><br><span class="line">    AV_CODEC_ID_MSMPEG4V1,</span><br><span class="line">    AV_CODEC_ID_MSMPEG4V2,</span><br><span class="line">    AV_CODEC_ID_MSMPEG4V3,</span><br><span class="line">    AV_CODEC_ID_WMV1,</span><br><span class="line">    AV_CODEC_ID_WMV2,</span><br><span class="line">    AV_CODEC_ID_H263P,</span><br><span class="line">    AV_CODEC_ID_H263I,</span><br><span class="line">    AV_CODEC_ID_FLV1,</span><br><span class="line">    AV_CODEC_ID_SVQ1,</span><br><span class="line">    AV_CODEC_ID_SVQ3,</span><br><span class="line">    AV_CODEC_ID_DVVIDEO,</span><br><span class="line">    AV_CODEC_ID_HUFFYUV,</span><br><span class="line">    AV_CODEC_ID_CYUV,</span><br><span class="line">    AV_CODEC_ID_H264,</span><br><span class="line">    AV_CODEC_ID_INDEO3,</span><br><span class="line">    AV_CODEC_ID_VP3,</span><br><span class="line">    AV_CODEC_ID_THEORA,</span><br><span class="line">    AV_CODEC_ID_ASV1,</span><br><span class="line">    AV_CODEC_ID_ASV2,</span><br><span class="line">    AV_CODEC_ID_FFV1,</span><br><span class="line">    AV_CODEC_ID_4XM,</span><br><span class="line">    AV_CODEC_ID_VCR1,</span><br><span class="line">    AV_CODEC_ID_CLJR,</span><br><span class="line">    AV_CODEC_ID_MDEC,</span><br><span class="line">    AV_CODEC_ID_ROQ,</span><br><span class="line">    AV_CODEC_ID_INTERPLAY_VIDEO,</span><br><span class="line">    AV_CODEC_ID_XAN_WC3,</span><br><span class="line">    AV_CODEC_ID_XAN_WC4,</span><br><span class="line">    AV_CODEC_ID_RPZA,</span><br><span class="line">    AV_CODEC_ID_CINEPAK,</span><br><span class="line">    AV_CODEC_ID_WS_VQA,</span><br><span class="line">    AV_CODEC_ID_MSRLE,</span><br><span class="line">    AV_CODEC_ID_MSVIDEO1,</span><br><span class="line">    AV_CODEC_ID_IDCIN,</span><br><span class="line">    AV_CODEC_ID_8BPS,</span><br><span class="line">    AV_CODEC_ID_SMC,</span><br><span class="line">    AV_CODEC_ID_FLIC,</span><br><span class="line">    AV_CODEC_ID_TRUEMOTION1,</span><br><span class="line">    AV_CODEC_ID_VMDVIDEO,</span><br><span class="line">    AV_CODEC_ID_MSZH,</span><br><span class="line">    AV_CODEC_ID_ZLIB,</span><br><span class="line">    AV_CODEC_ID_QTRLE,</span><br><span class="line">    AV_CODEC_ID_TSCC,</span><br><span class="line">    AV_CODEC_ID_ULTI,</span><br><span class="line">    AV_CODEC_ID_QDRAW,</span><br><span class="line">    AV_CODEC_ID_VIXL,</span><br><span class="line">    AV_CODEC_ID_QPEG,</span><br><span class="line">    AV_CODEC_ID_PNG,</span><br><span class="line">    AV_CODEC_ID_PPM,</span><br><span class="line">    AV_CODEC_ID_PBM,</span><br><span class="line">    AV_CODEC_ID_PGM,</span><br><span class="line">    AV_CODEC_ID_PGMYUV,</span><br><span class="line">    AV_CODEC_ID_PAM,</span><br><span class="line">    AV_CODEC_ID_FFVHUFF,</span><br><span class="line">    AV_CODEC_ID_RV30,</span><br><span class="line">    AV_CODEC_ID_RV40,</span><br><span class="line">    AV_CODEC_ID_VC1,</span><br><span class="line">    AV_CODEC_ID_WMV3,</span><br><span class="line">    AV_CODEC_ID_LOCO,</span><br><span class="line">    AV_CODEC_ID_WNV1,</span><br><span class="line">    AV_CODEC_ID_AASC,</span><br><span class="line">    AV_CODEC_ID_INDEO2,</span><br><span class="line">    AV_CODEC_ID_FRAPS,</span><br><span class="line">    AV_CODEC_ID_TRUEMOTION2,</span><br><span class="line">    AV_CODEC_ID_BMP,</span><br><span class="line">    AV_CODEC_ID_CSCD,</span><br><span class="line">    AV_CODEC_ID_MMVIDEO,</span><br><span class="line">    AV_CODEC_ID_ZMBV,</span><br><span class="line">    AV_CODEC_ID_AVS,</span><br><span class="line">    AV_CODEC_ID_SMACKVIDEO,</span><br><span class="line">    AV_CODEC_ID_NUV,</span><br><span class="line">    AV_CODEC_ID_KMVC,</span><br><span class="line">    AV_CODEC_ID_FLASHSV,</span><br><span class="line">    AV_CODEC_ID_CAVS,</span><br><span class="line">    AV_CODEC_ID_JPEG2000,</span><br><span class="line">    AV_CODEC_ID_VMNC,</span><br><span class="line">    AV_CODEC_ID_VP5,</span><br><span class="line">    AV_CODEC_ID_VP6,</span><br><span class="line">    AV_CODEC_ID_VP6F,</span><br><span class="line">    AV_CODEC_ID_TARGA,</span><br><span class="line">    AV_CODEC_ID_DSICINVIDEO,</span><br><span class="line">    AV_CODEC_ID_TIERTEXSEQVIDEO,</span><br><span class="line">    AV_CODEC_ID_TIFF,</span><br><span class="line">    AV_CODEC_ID_GIF,</span><br><span class="line">    AV_CODEC_ID_DXA,</span><br><span class="line">    AV_CODEC_ID_DNXHD,</span><br><span class="line">    AV_CODEC_ID_THP,</span><br><span class="line">    AV_CODEC_ID_SGI,</span><br><span class="line">    AV_CODEC_ID_C93,</span><br><span class="line">    AV_CODEC_ID_BETHSOFTVID,</span><br><span class="line">    AV_CODEC_ID_PTX,</span><br><span class="line">    AV_CODEC_ID_TXD,</span><br><span class="line">    AV_CODEC_ID_VP6A,</span><br><span class="line">    AV_CODEC_ID_AMV,</span><br><span class="line">    AV_CODEC_ID_VB,</span><br><span class="line">    AV_CODEC_ID_PCX,</span><br><span class="line">    AV_CODEC_ID_SUNRAST,</span><br><span class="line">    AV_CODEC_ID_INDEO4,</span><br><span class="line">    AV_CODEC_ID_INDEO5,</span><br><span class="line">    AV_CODEC_ID_MIMIC,</span><br><span class="line">    AV_CODEC_ID_RL2,</span><br><span class="line">    AV_CODEC_ID_ESCAPE124,</span><br><span class="line">    AV_CODEC_ID_DIRAC,</span><br><span class="line">    AV_CODEC_ID_BFI,</span><br><span class="line">    AV_CODEC_ID_CMV,</span><br><span class="line">    AV_CODEC_ID_MOTIONPIXELS,</span><br><span class="line">    AV_CODEC_ID_TGV,</span><br><span class="line">    AV_CODEC_ID_TGQ,</span><br><span class="line">    AV_CODEC_ID_TQI,</span><br><span class="line">    AV_CODEC_ID_AURA,</span><br><span class="line">    AV_CODEC_ID_AURA2,</span><br><span class="line">    AV_CODEC_ID_V210X,</span><br><span class="line">    AV_CODEC_ID_TMV,</span><br><span class="line">    AV_CODEC_ID_V210,</span><br><span class="line">    AV_CODEC_ID_DPX,</span><br><span class="line">    AV_CODEC_ID_MAD,</span><br><span class="line">    AV_CODEC_ID_FRWU,</span><br><span class="line">    AV_CODEC_ID_FLASHSV2,</span><br><span class="line">    AV_CODEC_ID_CDGRAPHICS,</span><br><span class="line">    AV_CODEC_ID_R210,</span><br><span class="line">    AV_CODEC_ID_ANM,</span><br><span class="line">    AV_CODEC_ID_BINKVIDEO,</span><br><span class="line">    AV_CODEC_ID_IFF_ILBM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CODEC_ID_IFF_BYTERUN1 AV_CODEC_ID_IFF_ILBM</span></span><br><span class="line">    AV_CODEC_ID_KGV1,</span><br><span class="line">    AV_CODEC_ID_YOP,</span><br><span class="line">    AV_CODEC_ID_VP8,</span><br><span class="line">    AV_CODEC_ID_PICTOR,</span><br><span class="line">    AV_CODEC_ID_ANSI,</span><br><span class="line">    AV_CODEC_ID_A64_MULTI,</span><br><span class="line">    AV_CODEC_ID_A64_MULTI5,</span><br><span class="line">    AV_CODEC_ID_R10K,</span><br><span class="line">    AV_CODEC_ID_MXPEG,</span><br><span class="line">    AV_CODEC_ID_LAGARITH,</span><br><span class="line">    AV_CODEC_ID_PRORES,</span><br><span class="line">    AV_CODEC_ID_JV,</span><br><span class="line">    AV_CODEC_ID_DFA,</span><br><span class="line">    AV_CODEC_ID_WMV3IMAGE,</span><br><span class="line">    AV_CODEC_ID_VC1IMAGE,</span><br><span class="line">    AV_CODEC_ID_UTVIDEO,</span><br><span class="line">    AV_CODEC_ID_BMV_VIDEO,</span><br><span class="line">    AV_CODEC_ID_VBLE,</span><br><span class="line">    AV_CODEC_ID_DXTORY,</span><br><span class="line">    AV_CODEC_ID_V410,</span><br><span class="line">    AV_CODEC_ID_XWD,</span><br><span class="line">    AV_CODEC_ID_CDXL,</span><br><span class="line">    AV_CODEC_ID_XBM,</span><br><span class="line">    AV_CODEC_ID_ZEROCODEC,</span><br><span class="line">    AV_CODEC_ID_MSS1,</span><br><span class="line">    AV_CODEC_ID_MSA1,</span><br><span class="line">    AV_CODEC_ID_TSCC2,</span><br><span class="line">    AV_CODEC_ID_MTS2,</span><br><span class="line">    AV_CODEC_ID_CLLC,</span><br><span class="line">    AV_CODEC_ID_MSS2,</span><br><span class="line">    AV_CODEC_ID_VP9,</span><br><span class="line">    AV_CODEC_ID_AIC,</span><br><span class="line">    AV_CODEC_ID_ESCAPE130,</span><br><span class="line">    AV_CODEC_ID_G2M,</span><br><span class="line">    AV_CODEC_ID_WEBP,</span><br><span class="line">    AV_CODEC_ID_HNM4_VIDEO,</span><br><span class="line">    AV_CODEC_ID_HEVC,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CODEC_ID_H265 AV_CODEC_ID_HEVC</span></span><br><span class="line">    AV_CODEC_ID_FIC,</span><br><span class="line">    AV_CODEC_ID_ALIAS_PIX,</span><br><span class="line">    AV_CODEC_ID_BRENDER_PIX,</span><br><span class="line">    AV_CODEC_ID_PAF_VIDEO,</span><br><span class="line">    AV_CODEC_ID_EXR,</span><br><span class="line">    AV_CODEC_ID_VP7,</span><br><span class="line">    AV_CODEC_ID_SANM,</span><br><span class="line">    AV_CODEC_ID_SGIRLE,</span><br><span class="line">    AV_CODEC_ID_MVC1,</span><br><span class="line">    AV_CODEC_ID_MVC2,</span><br><span class="line">    AV_CODEC_ID_HQX,</span><br><span class="line">    AV_CODEC_ID_TDSC,</span><br><span class="line">    AV_CODEC_ID_HQ_HQA,</span><br><span class="line">    AV_CODEC_ID_HAP,</span><br><span class="line">    AV_CODEC_ID_DDS,</span><br><span class="line">    AV_CODEC_ID_DXV,</span><br><span class="line">    AV_CODEC_ID_SCREENPRESSO,</span><br><span class="line">    AV_CODEC_ID_RSCC,</span><br><span class="line">    AV_CODEC_ID_AVS2,</span><br><span class="line">…代码太多省略部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\3. const enum AVPixelFormat *pix_fmts</p><p>AVPixelFormat的类型在我的上一篇文章已经给出，并且代码太多，这里就不在展示</p><p>\4. const enum AVSampleFormat *sample_fmts</p><p>enum AVSampleFormat定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVSampleFormat &#123;</span><br><span class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S64,         <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S64P,        <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种解码器对应一个结构体，查看ffmpeg的源代码，我们看一下H.264解码器的结构体，该结构体位于h264dec.c 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name                  = <span class="string">&quot;h264&quot;</span>,</span><br><span class="line">    .long_name             = NULL_IF_CONFIG_SMALL(<span class="string">&quot;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&quot;</span>),</span><br><span class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id                    = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size        = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init                  = h264_decode_init,</span><br><span class="line">    .close                 = h264_decode_end,</span><br><span class="line">    .decode                = h264_decode_frame,</span><br><span class="line">    .capabilities          = <span class="comment">/*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/</span> AV_CODEC_CAP_DR1 |</span><br><span class="line">                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |</span><br><span class="line">                             AV_CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .hw_configs            = (<span class="keyword">const</span> AVCodecHWConfigInternal*[]) &#123;</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_DXVA2_HWACCEL</span><br><span class="line">                               HWACCEL_DXVA2(h264),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_D3D11VA_HWACCEL</span><br><span class="line">                               HWACCEL_D3D11VA(h264),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_D3D11VA2_HWACCEL</span><br><span class="line">                               HWACCEL_D3D11VA2(h264),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_NVDEC_HWACCEL</span><br><span class="line">                               HWACCEL_NVDEC(h264),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_VAAPI_HWACCEL</span><br><span class="line">                               HWACCEL_VAAPI(h264),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_VDPAU_HWACCEL</span><br><span class="line">                               HWACCEL_VDPAU(h264),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> CONFIG_H264_VIDEOTOOLBOX_HWACCEL</span><br><span class="line">                               HWACCEL_VIDEOTOOLBOX(h264),</span><br><span class="line">#endif</span><br><span class="line">                               <span class="literal">NULL</span></span><br><span class="line">                           &#125;,</span><br><span class="line">    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |</span><br><span class="line">                             FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,</span><br><span class="line">    .flush                 = h264_decode_flush,</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</span><br><span class="line">    .profiles              = NULL_IF_CONFIG_SMALL(ff_h264_profiles),</span><br><span class="line">    .priv_class            = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>jpeg2000解码器结构体（jpeg2000dec.c）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_jpeg2000_decoder = &#123;</span><br><span class="line">    .name             = <span class="string">&quot;jpeg2000&quot;</span>,</span><br><span class="line">    .long_name        = NULL_IF_CONFIG_SMALL(<span class="string">&quot;JPEG 2000&quot;</span>),</span><br><span class="line">    .type             = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id               = AV_CODEC_ID_JPEG2000,</span><br><span class="line">    .capabilities     = AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_DR1,</span><br><span class="line">    .priv_data_size   = <span class="keyword">sizeof</span>(Jpeg2000DecoderContext),</span><br><span class="line">    .init             = jpeg2000_decode_init,</span><br><span class="line">    .decode           = jpeg2000_decode_frame,</span><br><span class="line">    .priv_class       = &amp;jpeg2000_class,</span><br><span class="line">    .max_lowres       = <span class="number">5</span>,</span><br><span class="line">    .profiles         = NULL_IF_CONFIG_SMALL(ff_jpeg2000_profiles)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在AVCodec结构体中有一个变量为struct AVCodec *next，表明这些编解码器以链表的形式存储。遍历ffmpeg中的编解码器信息的方法：</p><p>\1. 注册所有的编解码器： av_register_all();</p><p>\2. 声明一个AVCodec类型的指针，</p><p>\3. 调用av_codec_next()函数，即可获得链表中下一个编解码器的指针，重复第三步即可获取所有编解码器的信息。如果想要获取第一个解码器的指针，需要将参数设置为NULL即可</p><p>PS:参考雷神博客<a href="https://link.zhihu.com/?target=https://blog.csdn.net/leixiaohua1020/article/details/14215833">FFMPEG结构体分析：AVCodec_雷霄骅(leixiaohua1020)的专栏-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVCodec结构体是存储编解码器信息的结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVCodecContext结构体</title>
    <link href="http://example.com/jsblog/f65b7c6d.html"/>
    <id>http://example.com/jsblog/f65b7c6d.html</id>
    <published>2020-12-20T03:59:33.000Z</published>
    <updated>2020-12-20T04:20:59.416Z</updated>
    
    <content type="html"><![CDATA[<p>AVCondecContext 是FFmpeg使用过程中比较重要的结构体<a id="more"></a>，该结构体位于<strong>avcodec.h</strong>文件中保存了编码器上下文的相关信息。不管是编码，还是解码都会用到，但在两种不同的应用场景中，结构体中部分字段的作用和说明并不一致，在使用的时候要特别注意。</p><p>该结构体中得定义很多，其中有一些比较重要的放在这里记录一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVMediaType codec_type; 编解码器的类型 </span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodec</span>  *<span class="title">codec</span>;</span> 编解码器,初始化后不可更改</span><br><span class="line"><span class="keyword">enum</span> AVCodecID codec_id;  编解码器的id</span><br><span class="line"><span class="keyword">int64_t</span> bit_rate; 平均比特率</span><br><span class="line"><span class="keyword">uint8_t</span> *extradata; <span class="keyword">int</span> extradata_size; 针对特定编码器包含的附加信息</span><br><span class="line">AVRational time_base; 根据该参数可以将pts转化为实践</span><br><span class="line"><span class="keyword">int</span> width, height; 每一帧的宽和高</span><br><span class="line"><span class="keyword">int</span> gop_size;  一组图片的数量，编码时用户设置，解码时不使用</span><br><span class="line"><span class="keyword">enum</span> AVPixelFormat pix_fmt; 像素格式，编码时用户设置，解码时可由用户指定，但是在分析数据会被覆盖用户的设置</span><br><span class="line"><span class="keyword">int</span> refs; 参考帧的数量</span><br><span class="line"><span class="keyword">enum</span> AVColorSpace colorspace; YUV色彩空间类型</span><br><span class="line"><span class="keyword">enum</span> AVColorRange color_range; MPEG JPEG YUV范围</span><br><span class="line"><span class="keyword">int</span> sample_rate; 采样率 仅音频</span><br><span class="line"><span class="keyword">int</span> channels; 声道数（音频）</span><br><span class="line"><span class="keyword">enum</span> AVSampleFormat sample_fmt; <span class="comment">//采样格式</span></span><br><span class="line"><span class="keyword">int</span> frame_size; 每个音频帧中每个声道的采样数量</span><br><span class="line"><span class="keyword">int</span> profile;配置类型</span><br><span class="line"><span class="keyword">int</span> level;级别</span><br></pre></td></tr></table></figure><p>1编解码器类型：AVMediaType：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVMediaType &#123;</span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2 YUV色彩空间类型：AVColorSpace</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVColorSpace &#123;</span><br><span class="line">    AVCOL_SPC_RGB         = <span class="number">0</span>,  <span class="comment">///&lt; order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)</span></span><br><span class="line">    AVCOL_SPC_BT709       = <span class="number">1</span>,  <span class="comment">///&lt; also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B</span></span><br><span class="line">    AVCOL_SPC_UNSPECIFIED = <span class="number">2</span>,</span><br><span class="line">    AVCOL_SPC_RESERVED    = <span class="number">3</span>,</span><br><span class="line">    AVCOL_SPC_FCC         = <span class="number">4</span>,  <span class="comment">///&lt; FCC Title 47 Code of Federal Regulations 73.682 (a)(20)</span></span><br><span class="line">    AVCOL_SPC_BT470BG     = <span class="number">5</span>,  <span class="comment">///&lt; also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL &amp; SECAM / IEC 61966-2-4 xvYCC601</span></span><br><span class="line">    AVCOL_SPC_SMPTE170M   = <span class="number">6</span>,  <span class="comment">///&lt; also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC</span></span><br><span class="line">    AVCOL_SPC_SMPTE240M   = <span class="number">7</span>,  <span class="comment">///&lt; functionally identical to above</span></span><br><span class="line">    AVCOL_SPC_YCGCO       = <span class="number">8</span>,  <span class="comment">///&lt; Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16</span></span><br><span class="line">    AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,</span><br><span class="line">    AVCOL_SPC_BT2020_NCL  = <span class="number">9</span>,  <span class="comment">///&lt; ITU-R BT2020 non-constant luminance system</span></span><br><span class="line">    AVCOL_SPC_BT2020_CL   = <span class="number">10</span>, <span class="comment">///&lt; ITU-R BT2020 constant luminance system</span></span><br><span class="line">    AVCOL_SPC_SMPTE2085   = <span class="number">11</span>, <span class="comment">///&lt; SMPTE 2085, Y&#x27;D&#x27;zD&#x27;x</span></span><br><span class="line">    AVCOL_SPC_CHROMA_DERIVED_NCL = <span class="number">12</span>, <span class="comment">///&lt; Chromaticity-derived non-constant luminance system</span></span><br><span class="line">    AVCOL_SPC_CHROMA_DERIVED_CL = <span class="number">13</span>, <span class="comment">///&lt; Chromaticity-derived constant luminance system</span></span><br><span class="line">    AVCOL_SPC_ICTCP       = <span class="number">14</span>, <span class="comment">///&lt; ITU-R BT.2100-0, ICtCp</span></span><br><span class="line">    AVCOL_SPC_NB                <span class="comment">///&lt; Not part of ABI</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.色彩空间范围：AVColorRange</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVColorRange &#123;</span><br><span class="line">    AVCOL_RANGE_UNSPECIFIED = <span class="number">0</span>,</span><br><span class="line">    AVCOL_RANGE_MPEG        = <span class="number">1</span>, <span class="comment">///&lt; the normal 219*2^(n-8) &quot;MPEG&quot; YUV ranges</span></span><br><span class="line">    AVCOL_RANGE_JPEG        = <span class="number">2</span>, <span class="comment">///&lt; the normal     2^n-1   &quot;JPEG&quot; YUV ranges</span></span><br><span class="line">    AVCOL_RANGE_NB               <span class="comment">///&lt; Not part of ABI</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4 FFmpeg采样格式：AVSampleFormat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVSampleFormat &#123;</span><br><span class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"></span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S64,         <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S64P,        <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"></span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>\5. 配置类型profile:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_UNKNOWN -99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_RESERVED -100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_MAIN 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_LOW1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_SSR2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_LTP3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_HE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_HE_V2 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_LD22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AAC_ELD38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_AAC_LOW 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_AAC_HE131</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DNXHD0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DNXHR_LB1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DNXHR_SQ2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DNXHR_HQ3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DNXHR_HQX4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DNXHR_4445</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DTS20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DTS_ES30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DTS_96_2440</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DTS_HD_HRA50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DTS_HD_MA60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_DTS_EXPRESS 70</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_4220</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_HIGH1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_SS2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_SNR_SCALABLE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_MAIN4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG2_SIMPLE 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_CONSTRAINED(1&lt;&lt;9)<span class="comment">// 8+1; constraint_set1_flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_INTRA(1&lt;&lt;11) <span class="comment">// 8+3; constraint_set3_flag</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_BASELINE66</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_CONSTRAINED_BASELINE (66|FF_PROFILE_H264_CONSTRAINED)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_MAIN77</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_EXTENDED88</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_10110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_10_INTRA(110|FF_PROFILE_H264_INTRA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_MULTIVIEW_HIGH118</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_422122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_422_INTRA(122|FF_PROFILE_H264_INTRA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_STEREO_HIGH128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_444144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_444_PREDICTIVE244</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_HIGH_444_INTRA(244|FF_PROFILE_H264_INTRA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_H264_CAVLC_44444</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VC1_SIMPLE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VC1_MAIN1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VC1_COMPLEX2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VC1_ADVANCED 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_SIMPLE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_SIMPLE_SCALABLE1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_CORE2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_MAIN3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_N_BIT4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_SCALABLE_TEXTURE5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_HYBRID8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_REAL_TIME9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_CORE_SCALABLE10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_CODING11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_CORE12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_SIMPLE_STUDIO14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_SIMPLE15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION32768</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_JPEG2000_DCINEMA_2K3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_JPEG2000_DCINEMA_4K4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VP9_00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VP9_11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VP9_22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_VP9_33</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_HEVC_MAIN1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_HEVC_MAIN_102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_HEVC_MAIN_STILL_PICTURE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_HEVC_REXT4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AV1_MAIN0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AV1_HIGH1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_AV1_PROFESSIONAL2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT 0xc1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT0xc2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS0xc3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_MJPEG_JPEG_LS0xf7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_SBC_MSBC1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_PRORES_PROXY0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_PRORES_LT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_PRORES_STANDARD2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_PRORES_HQ3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_PRORES_44444</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_PRORES_XQ5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_ARIB_PROFILE_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_ARIB_PROFILE_C 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_KLVA_SYNC 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PROFILE_KLVA_ASYNC </span></span><br></pre></td></tr></table></figure><p>6 像素格式:AVPixelFormat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVPixelFormat &#123;</span><br><span class="line">    AV_PIX_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_PIX_FMT_YUV420P,   <span class="comment">///&lt; planar YUV 4:2:0, 12bpp, (1 Cr &amp; Cb sample per 2x2 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUYV422,   <span class="comment">///&lt; packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr</span></span><br><span class="line">    AV_PIX_FMT_RGB24,     <span class="comment">///&lt; packed RGB 8:8:8, 24bpp, RGBRGB...</span></span><br><span class="line">    AV_PIX_FMT_BGR24,     <span class="comment">///&lt; packed RGB 8:8:8, 24bpp, BGRBGR...</span></span><br><span class="line">    AV_PIX_FMT_YUV422P,   <span class="comment">///&lt; planar YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUV444P,   <span class="comment">///&lt; planar YUV 4:4:4, 24bpp, (1 Cr &amp; Cb sample per 1x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUV410P,   <span class="comment">///&lt; planar YUV 4:1:0,  9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUV411P,   <span class="comment">///&lt; planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_GRAY8,     <span class="comment">///&lt;        Y        ,  8bpp</span></span><br><span class="line">    AV_PIX_FMT_MONOWHITE, <span class="comment">///&lt;        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb</span></span><br><span class="line">    AV_PIX_FMT_MONOBLACK, <span class="comment">///&lt;        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb</span></span><br><span class="line">    AV_PIX_FMT_PAL8,      <span class="comment">///&lt; 8 bits with AV_PIX_FMT_RGB32 palette</span></span><br><span class="line">    AV_PIX_FMT_YUVJ420P,  <span class="comment">///&lt; planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_YUVJ422P,  <span class="comment">///&lt; planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_YUVJ444P,  <span class="comment">///&lt; planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_UYVY422,   <span class="comment">///&lt; packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1</span></span><br><span class="line">    AV_PIX_FMT_UYYVYY411, <span class="comment">///&lt; packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3</span></span><br><span class="line">    AV_PIX_FMT_BGR8,      <span class="comment">///&lt; packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)</span></span><br><span class="line">    AV_PIX_FMT_BGR4,      <span class="comment">///&lt; packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits</span></span><br><span class="line">    AV_PIX_FMT_BGR4_BYTE, <span class="comment">///&lt; packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)</span></span><br><span class="line">    AV_PIX_FMT_RGB8,      <span class="comment">///&lt; packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)</span></span><br><span class="line">    AV_PIX_FMT_RGB4,      <span class="comment">///&lt; packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits</span></span><br><span class="line">    AV_PIX_FMT_RGB4_BYTE, <span class="comment">///&lt; packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)</span></span><br><span class="line">    AV_PIX_FMT_NV12,      <span class="comment">///&lt; planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)</span></span><br><span class="line">    AV_PIX_FMT_NV21,      <span class="comment">///&lt; as above, but U and V bytes are swapped</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_ARGB,      <span class="comment">///&lt; packed ARGB 8:8:8:8, 32bpp, ARGBARGB...</span></span><br><span class="line">    AV_PIX_FMT_RGBA,      <span class="comment">///&lt; packed RGBA 8:8:8:8, 32bpp, RGBARGBA...</span></span><br><span class="line">    AV_PIX_FMT_ABGR,      <span class="comment">///&lt; packed ABGR 8:8:8:8, 32bpp, ABGRABGR...</span></span><br><span class="line">    AV_PIX_FMT_BGRA,      <span class="comment">///&lt; packed BGRA 8:8:8:8, 32bpp, BGRABGRA...</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GRAY16BE,  <span class="comment">///&lt;        Y        , 16bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAY16LE,  <span class="comment">///&lt;        Y        , 16bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV440P,   <span class="comment">///&lt; planar YUV 4:4:0 (1 Cr &amp; Cb sample per 1x2 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUVJ440P,  <span class="comment">///&lt; planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P,  <span class="comment">///&lt; planar YUV 4:2:0, 20bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples)</span></span><br><span class="line">    AV_PIX_FMT_RGB48BE,   <span class="comment">///&lt; packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian</span></span><br><span class="line">    AV_PIX_FMT_RGB48LE,   <span class="comment">///&lt; packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_RGB565BE,  <span class="comment">///&lt; packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian</span></span><br><span class="line">    AV_PIX_FMT_RGB565LE,  <span class="comment">///&lt; packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian</span></span><br><span class="line">    AV_PIX_FMT_RGB555BE,  <span class="comment">///&lt; packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_RGB555LE,  <span class="comment">///&lt; packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_BGR565BE,  <span class="comment">///&lt; packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian</span></span><br><span class="line">    AV_PIX_FMT_BGR565LE,  <span class="comment">///&lt; packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian</span></span><br><span class="line">    AV_PIX_FMT_BGR555BE,  <span class="comment">///&lt; packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_BGR555LE,  <span class="comment">///&lt; packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> FF_API_VAAPI</span><br><span class="line">    <span class="comment">/** @name Deprecated pixel formats */</span></span><br><span class="line">    <span class="comment">/**@&#123;*/</span></span><br><span class="line">    AV_PIX_FMT_VAAPI_MOCO, <span class="comment">///&lt; HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers</span></span><br><span class="line">    AV_PIX_FMT_VAAPI_IDCT, <span class="comment">///&lt; HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers</span></span><br><span class="line">    AV_PIX_FMT_VAAPI_VLD,  <span class="comment">///&lt; HW decoding through VA API, Picture.data[3] contains a VASurfaceID</span></span><br><span class="line">    <span class="comment">/**@&#125;*/</span></span><br><span class="line">    AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Hardware acceleration through VA-API, data[3] contains a</span></span><br><span class="line"><span class="comment">     *  VASurfaceID.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_VAAPI,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_YUV420P16LE,  <span class="comment">///&lt; planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P16BE,  <span class="comment">///&lt; planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P16LE,  <span class="comment">///&lt; planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P16BE,  <span class="comment">///&lt; planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P16LE,  <span class="comment">///&lt; planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P16BE,  <span class="comment">///&lt; planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_DXVA2_VLD,    <span class="comment">///&lt; HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_RGB444LE,  <span class="comment">///&lt; packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_RGB444BE,  <span class="comment">///&lt; packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_BGR444LE,  <span class="comment">///&lt; packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_BGR444BE,  <span class="comment">///&lt; packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_YA8,       <span class="comment">///&lt; 8 bits gray, 8 bits alpha</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, <span class="comment">///&lt; alias for AV_PIX_FMT_YA8</span></span><br><span class="line">    AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, <span class="comment">///&lt; alias for AV_PIX_FMT_YA8</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_BGR48BE,   <span class="comment">///&lt; packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian</span></span><br><span class="line">    AV_PIX_FMT_BGR48LE,   <span class="comment">///&lt; packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The following 12 formats have the disadvantage of needing 1 format for each bit depth.</span></span><br><span class="line"><span class="comment">     * Notice that each 9/10 bits sample is stored in 16 bits with extra padding.</span></span><br><span class="line"><span class="comment">     * If you want to support multiple bit depths, then using AV_PIX_FMT_YUV420P16* with the bpp stored separately is better.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_YUV420P9BE, <span class="comment">///&lt; planar YUV 4:2:0, 13.5bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P9LE, <span class="comment">///&lt; planar YUV 4:2:0, 13.5bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P10BE,<span class="comment">///&lt; planar YUV 4:2:0, 15bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P10LE,<span class="comment">///&lt; planar YUV 4:2:0, 15bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P10BE,<span class="comment">///&lt; planar YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P10LE,<span class="comment">///&lt; planar YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P9BE, <span class="comment">///&lt; planar YUV 4:4:4, 27bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P9LE, <span class="comment">///&lt; planar YUV 4:4:4, 27bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P10BE,<span class="comment">///&lt; planar YUV 4:4:4, 30bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P10LE,<span class="comment">///&lt; planar YUV 4:4:4, 30bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P9BE, <span class="comment">///&lt; planar YUV 4:2:2, 18bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P9LE, <span class="comment">///&lt; planar YUV 4:2:2, 18bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP,      <span class="comment">///&lt; planar GBR 4:4:4 24bpp</span></span><br><span class="line">    AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP, <span class="comment">// alias for #AV_PIX_FMT_GBRP</span></span><br><span class="line">    AV_PIX_FMT_GBRP9BE,   <span class="comment">///&lt; planar GBR 4:4:4 27bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP9LE,   <span class="comment">///&lt; planar GBR 4:4:4 27bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP10BE,  <span class="comment">///&lt; planar GBR 4:4:4 30bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP10LE,  <span class="comment">///&lt; planar GBR 4:4:4 30bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP16BE,  <span class="comment">///&lt; planar GBR 4:4:4 48bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP16LE,  <span class="comment">///&lt; planar GBR 4:4:4 48bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P,  <span class="comment">///&lt; planar YUV 4:2:2 24bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples)</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P,  <span class="comment">///&lt; planar YUV 4:4:4 32bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples)</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P9BE,  <span class="comment">///&lt; planar YUV 4:2:0 22.5bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P9LE,  <span class="comment">///&lt; planar YUV 4:2:0 22.5bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P9BE,  <span class="comment">///&lt; planar YUV 4:2:2 27bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P9LE,  <span class="comment">///&lt; planar YUV 4:2:2 27bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P9BE,  <span class="comment">///&lt; planar YUV 4:4:4 36bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P9LE,  <span class="comment">///&lt; planar YUV 4:4:4 36bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P10BE, <span class="comment">///&lt; planar YUV 4:2:0 25bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P10LE, <span class="comment">///&lt; planar YUV 4:2:0 25bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, little-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P10BE, <span class="comment">///&lt; planar YUV 4:2:2 30bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P10LE, <span class="comment">///&lt; planar YUV 4:2:2 30bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, little-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P10BE, <span class="comment">///&lt; planar YUV 4:4:4 40bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P10LE, <span class="comment">///&lt; planar YUV 4:4:4 40bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, little-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P16BE, <span class="comment">///&lt; planar YUV 4:2:0 40bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA420P16LE, <span class="comment">///&lt; planar YUV 4:2:0 40bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, little-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P16BE, <span class="comment">///&lt; planar YUV 4:2:2 48bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P16LE, <span class="comment">///&lt; planar YUV 4:2:2 48bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, little-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P16BE, <span class="comment">///&lt; planar YUV 4:4:4 64bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P16LE, <span class="comment">///&lt; planar YUV 4:4:4 64bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, little-endian)</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_VDPAU,     <span class="comment">///&lt; HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_XYZ12LE,      <span class="comment">///&lt; packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0</span></span><br><span class="line">    AV_PIX_FMT_XYZ12BE,      <span class="comment">///&lt; packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0</span></span><br><span class="line">    AV_PIX_FMT_NV16,         <span class="comment">///&lt; interleaved chroma YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_NV20LE,       <span class="comment">///&lt; interleaved chroma YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_NV20BE,       <span class="comment">///&lt; interleaved chroma YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_RGBA64BE,     <span class="comment">///&lt; packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian</span></span><br><span class="line">    AV_PIX_FMT_RGBA64LE,     <span class="comment">///&lt; packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian</span></span><br><span class="line">    AV_PIX_FMT_BGRA64BE,     <span class="comment">///&lt; packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian</span></span><br><span class="line">    AV_PIX_FMT_BGRA64LE,     <span class="comment">///&lt; packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_YVYU422,   <span class="comment">///&lt; packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_YA16BE,       <span class="comment">///&lt; 16 bits gray, 16 bits alpha (big-endian)</span></span><br><span class="line">    AV_PIX_FMT_YA16LE,       <span class="comment">///&lt; 16 bits gray, 16 bits alpha (little-endian)</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GBRAP,        <span class="comment">///&lt; planar GBRA 4:4:4:4 32bpp</span></span><br><span class="line">    AV_PIX_FMT_GBRAP16BE,    <span class="comment">///&lt; planar GBRA 4:4:4:4 64bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRAP16LE,    <span class="comment">///&lt; planar GBRA 4:4:4:4 64bpp, little-endian</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  HW acceleration through QSV, data[3] contains a pointer to the</span></span><br><span class="line"><span class="comment">     *  mfxFrameSurface1 structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_QSV,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HW acceleration though MMAL, data[3] contains a pointer to the</span></span><br><span class="line"><span class="comment">     * MMAL_BUFFER_HEADER_T structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_MMAL,</span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_D3D11VA_VLD,  <span class="comment">///&lt; HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HW acceleration through CUDA. data[i] contain CUdeviceptr pointers</span></span><br><span class="line"><span class="comment">     * exactly as for system memory frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_CUDA,</span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_0RGB,        <span class="comment">///&lt; packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_RGB0,        <span class="comment">///&lt; packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_0BGR,        <span class="comment">///&lt; packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined</span></span><br><span class="line">    AV_PIX_FMT_BGR0,        <span class="comment">///&lt; packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_YUV420P12BE, <span class="comment">///&lt; planar YUV 4:2:0,18bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P12LE, <span class="comment">///&lt; planar YUV 4:2:0,18bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P14BE, <span class="comment">///&lt; planar YUV 4:2:0,21bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV420P14LE, <span class="comment">///&lt; planar YUV 4:2:0,21bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P12BE, <span class="comment">///&lt; planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P12LE, <span class="comment">///&lt; planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P14BE, <span class="comment">///&lt; planar YUV 4:2:2,28bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV422P14LE, <span class="comment">///&lt; planar YUV 4:2:2,28bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P12BE, <span class="comment">///&lt; planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P12LE, <span class="comment">///&lt; planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P14BE, <span class="comment">///&lt; planar YUV 4:4:4,42bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV444P14LE, <span class="comment">///&lt; planar YUV 4:4:4,42bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP12BE,    <span class="comment">///&lt; planar GBR 4:4:4 36bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP12LE,    <span class="comment">///&lt; planar GBR 4:4:4 36bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP14BE,    <span class="comment">///&lt; planar GBR 4:4:4 42bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRP14LE,    <span class="comment">///&lt; planar GBR 4:4:4 42bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVJ411P,    <span class="comment">///&lt; planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_BAYER_BGGR8,    <span class="comment">///&lt; bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples</span></span><br><span class="line">    AV_PIX_FMT_BAYER_RGGB8,    <span class="comment">///&lt; bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples</span></span><br><span class="line">    AV_PIX_FMT_BAYER_GBRG8,    <span class="comment">///&lt; bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples</span></span><br><span class="line">    AV_PIX_FMT_BAYER_GRBG8,    <span class="comment">///&lt; bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples</span></span><br><span class="line">    AV_PIX_FMT_BAYER_BGGR16LE, <span class="comment">///&lt; bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_BGGR16BE, <span class="comment">///&lt; bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_RGGB16LE, <span class="comment">///&lt; bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_RGGB16BE, <span class="comment">///&lt; bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_GBRG16LE, <span class="comment">///&lt; bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_GBRG16BE, <span class="comment">///&lt; bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_GRBG16LE, <span class="comment">///&lt; bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian</span></span><br><span class="line">    AV_PIX_FMT_BAYER_GRBG16BE, <span class="comment">///&lt; bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_XVMC,<span class="comment">///&lt; XVideo Motion Acceleration via common packet passing</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_YUV440P10LE, <span class="comment">///&lt; planar YUV 4:4:0,20bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV440P10BE, <span class="comment">///&lt; planar YUV 4:4:0,20bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV440P12LE, <span class="comment">///&lt; planar YUV 4:4:0,24bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUV440P12BE, <span class="comment">///&lt; planar YUV 4:4:0,24bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), big-endian</span></span><br><span class="line">    AV_PIX_FMT_AYUV64LE,    <span class="comment">///&lt; packed AYUV 4:4:4,64bpp (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), little-endian</span></span><br><span class="line">    AV_PIX_FMT_AYUV64BE,    <span class="comment">///&lt; packed AYUV 4:4:4,64bpp (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), big-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_VIDEOTOOLBOX, <span class="comment">///&lt; hardware decoding through Videotoolbox</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_P010LE, <span class="comment">///&lt; like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian</span></span><br><span class="line">    AV_PIX_FMT_P010BE, <span class="comment">///&lt; like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GBRAP12BE,  <span class="comment">///&lt; planar GBR 4:4:4:4 48bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRAP12LE,  <span class="comment">///&lt; planar GBR 4:4:4:4 48bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GBRAP10BE,  <span class="comment">///&lt; planar GBR 4:4:4:4 40bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRAP10LE,  <span class="comment">///&lt; planar GBR 4:4:4:4 40bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_MEDIACODEC, <span class="comment">///&lt; hardware decoding through MediaCodec</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GRAY12BE,   <span class="comment">///&lt;        Y        , 12bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAY12LE,   <span class="comment">///&lt;        Y        , 12bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAY10BE,   <span class="comment">///&lt;        Y        , 10bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAY10LE,   <span class="comment">///&lt;        Y        , 10bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_P016LE, <span class="comment">///&lt; like NV12, with 16bpp per component, little-endian</span></span><br><span class="line">    AV_PIX_FMT_P016BE, <span class="comment">///&lt; like NV12, with 16bpp per component, big-endian</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hardware surfaces for Direct3D11.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11</span></span><br><span class="line"><span class="comment">     * hwaccel API and filtering support AV_PIX_FMT_D3D11 only.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * data[0] contains a ID3D11Texture2D pointer, and data[1] contains the</span></span><br><span class="line"><span class="comment">     * texture array index of the frame as intptr_t if the ID3D11Texture2D is</span></span><br><span class="line"><span class="comment">     * an array texture (or always 0 if it&#x27;s a normal texture).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_D3D11,</span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GRAY9BE,   <span class="comment">///&lt;        Y        , 9bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAY9LE,   <span class="comment">///&lt;        Y        , 9bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GBRPF32BE,  <span class="comment">///&lt; IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRPF32LE,  <span class="comment">///&lt; IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRAPF32BE, <span class="comment">///&lt; IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GBRAPF32LE, <span class="comment">///&lt; IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DRM-managed buffers exposed through PRIME buffer sharing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * data[0] points to an AVDRMFrameDescriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_DRM_PRIME,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hardware surfaces for OpenCL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * data[i] contain 2D image objects (typed in C as cl_mem, used</span></span><br><span class="line"><span class="comment">     * in OpenCL as image2d_t) for each plane of the surface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_OPENCL,</span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GRAY14BE,   <span class="comment">///&lt;        Y        , 14bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAY14LE,   <span class="comment">///&lt;        Y        , 14bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_GRAYF32BE,  <span class="comment">///&lt; IEEE-754 single precision Y, 32bpp, big-endian</span></span><br><span class="line">    AV_PIX_FMT_GRAYF32LE,  <span class="comment">///&lt; IEEE-754 single precision Y, 32bpp, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_YUVA422P12BE, <span class="comment">///&lt; planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), 12b alpha, big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA422P12LE, <span class="comment">///&lt; planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), 12b alpha, little-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P12BE, <span class="comment">///&lt; planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), 12b alpha, big-endian</span></span><br><span class="line">    AV_PIX_FMT_YUVA444P12LE, <span class="comment">///&lt; planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), 12b alpha, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_NV24,      <span class="comment">///&lt; planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)</span></span><br><span class="line">    AV_PIX_FMT_NV42,      <span class="comment">///&lt; as above, but U and V bytes are swapped</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Vulkan hardware images.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * data[0] points to an AVVkFrame</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AV_PIX_FMT_VULKAN,</span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_Y210BE,    <span class="comment">///&lt; packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian</span></span><br><span class="line">    AV_PIX_FMT_Y210LE,    <span class="comment">///&lt; packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian</span></span><br><span class="line"></span><br><span class="line">    AV_PIX_FMT_NB         <span class="comment">///&lt; number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AVCodecContext结构体的全部代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;</span><br><span class="line">    <span class="keyword">int</span> log_level_offset;</span><br><span class="line">    <span class="keyword">enum</span> AVMediaType codec_type; <span class="comment">/* see AVMEDIA_TYPE_xxx */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodec</span>  *<span class="title">codec</span>;</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID     codec_id; <span class="comment">/* see AV_CODEC_ID_xxx */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> codec_tag;</span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecInternal</span> *<span class="title">internal</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate;</span><br><span class="line">    <span class="keyword">int</span> bit_rate_tolerance;</span><br><span class="line">    <span class="keyword">int</span> global_quality;</span><br><span class="line">    <span class="keyword">int</span> compression_level;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_COMPRESSION_DEFAULT -1</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> flags2;</span><br><span class="line">    <span class="keyword">uint8_t</span> *extradata;</span><br><span class="line">    <span class="keyword">int</span> extradata_size;</span><br><span class="line">    AVRational time_base;</span><br><span class="line">    <span class="keyword">int</span> ticks_per_frame;</span><br><span class="line">    <span class="keyword">int</span> delay;</span><br><span class="line">    <span class="keyword">int</span> width, height;</span><br><span class="line">    <span class="keyword">int</span> coded_width, coded_height;</span><br><span class="line">    <span class="keyword">int</span> gop_size;</span><br><span class="line">    <span class="keyword">enum</span> AVPixelFormat pix_fmt;</span><br><span class="line">    <span class="keyword">void</span> (*draw_horiz_band)(struct AVCodecContext *s,</span><br><span class="line">                            <span class="keyword">const</span> AVFrame *src, <span class="keyword">int</span> offset[AV_NUM_DATA_POINTERS],</span><br><span class="line">                            <span class="keyword">int</span> y, <span class="keyword">int</span> type, <span class="keyword">int</span> height);</span><br><span class="line">    <span class="function"><span class="keyword">enum</span> <span class="title">AVPixelFormat</span> <span class="params">(*get_format)</span><span class="params">(struct AVCodecContext *s, <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat * fmt)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> max_b_frames;</span><br><span class="line">    <span class="keyword">float</span> b_quant_factor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> b_frame_strategy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">float</span> b_quant_offset;</span><br><span class="line">    <span class="keyword">int</span> has_b_frames;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> mpeg_quant;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">float</span> i_quant_factor;</span><br><span class="line">    <span class="keyword">float</span> i_quant_offset;</span><br><span class="line">    <span class="keyword">float</span> lumi_masking;</span><br><span class="line">    <span class="keyword">float</span> temporal_cplx_masking;</span><br><span class="line">    <span class="keyword">float</span> spatial_cplx_masking;</span><br><span class="line">    <span class="keyword">float</span> p_masking;</span><br><span class="line">    <span class="keyword">float</span> dark_masking;</span><br><span class="line">    <span class="keyword">int</span> slice_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">     <span class="keyword">int</span> prediction_method;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PRED_LEFT   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PRED_PLANE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_PRED_MEDIAN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> *slice_offset;</span><br><span class="line">    AVRational sample_aspect_ratio;</span><br><span class="line">    <span class="keyword">int</span> me_cmp;</span><br><span class="line">    <span class="keyword">int</span> me_sub_cmp;</span><br><span class="line">    <span class="keyword">int</span> mb_cmp;</span><br><span class="line">    <span class="keyword">int</span> ildct_cmp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_SAD          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_SSE          1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_SATD         2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_DCT          3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_PSNR         4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_BIT          5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_RD           6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_ZERO         7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_VSAD         8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_VSSE         9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_NSSE         10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_W53          11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_W97          12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_DCTMAX       13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_DCT264       14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_MEDIAN_SAD   15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CMP_CHROMA       256</span></span><br><span class="line">    <span class="keyword">int</span> dia_size;</span><br><span class="line">    <span class="keyword">int</span> last_predictor_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> pre_me;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> me_pre_cmp;</span><br><span class="line">    <span class="keyword">int</span> pre_dia_size;</span><br><span class="line">    <span class="keyword">int</span> me_subpel_quality;</span><br><span class="line">    <span class="keyword">int</span> me_range;</span><br><span class="line">    <span class="keyword">int</span> slice_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLICE_FLAG_CODED_ORDER    0x0001 <span class="comment">///&lt; draw_horiz_band() is called in coded order instead of display</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLICE_FLAG_ALLOW_FIELD    0x0002 <span class="comment">///&lt; allow draw_horiz_band() with field slices (MPEG-2 field pics)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLICE_FLAG_ALLOW_PLANE    0x0004 </span></span><br><span class="line">    <span class="keyword">int</span> mb_decision;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_MB_DECISION_SIMPLE 0        <span class="comment">///&lt; uses mb_cmp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_MB_DECISION_BITS   1        <span class="comment">///&lt; chooses the one which needs the fewest bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_MB_DECISION_RD     2        </span></span><br><span class="line">    <span class="keyword">uint16_t</span> *intra_matrix;</span><br><span class="line">    <span class="keyword">uint16_t</span> *inter_matrix;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> scenechange_threshold;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> noise_reduction;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> intra_dc_precision;</span><br><span class="line">    <span class="keyword">int</span> skip_top;</span><br><span class="line">    <span class="keyword">int</span> skip_bottom;</span><br><span class="line">    <span class="keyword">int</span> mb_lmin;</span><br><span class="line">    <span class="keyword">int</span> mb_lmax;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> me_penalty_compensation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> bidir_refine;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> brd_scale;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> keyint_min;</span><br><span class="line">    <span class="keyword">int</span> refs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> chromaoffset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> mv0_threshold;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> b_sensitivity;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">enum</span> AVColorPrimaries color_primaries;</span><br><span class="line">    <span class="keyword">enum</span> AVColorTransferCharacteristic color_trc;</span><br><span class="line">    <span class="keyword">enum</span> AVColorSpace colorspace;</span><br><span class="line">    <span class="keyword">enum</span> AVColorRange color_range;</span><br><span class="line">    <span class="keyword">enum</span> AVChromaLocation chroma_sample_location;</span><br><span class="line">    <span class="keyword">int</span> slices;</span><br><span class="line">    <span class="keyword">enum</span> AVFieldOrder field_order;</span><br><span class="line">    <span class="keyword">int</span> sample_rate; </span><br><span class="line">    <span class="keyword">int</span> channels;    </span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat sample_fmt;  </span><br><span class="line">    <span class="keyword">int</span> frame_size;</span><br><span class="line">    <span class="keyword">int</span> frame_number;</span><br><span class="line">    <span class="keyword">int</span> block_align;</span><br><span class="line">    <span class="keyword">int</span> cutoff;</span><br><span class="line">    <span class="keyword">uint64_t</span> channel_layout;</span><br><span class="line">    <span class="keyword">uint64_t</span> request_channel_layout;</span><br><span class="line">    <span class="keyword">enum</span> AVAudioServiceType audio_service_type;</span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat request_sample_fmt;</span><br><span class="line">    <span class="keyword">int</span> (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, <span class="keyword">int</span> flags);</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> refcounted_frames;</span><br><span class="line">    <span class="keyword">float</span> qcompress;  <span class="comment">///&lt; amount of qscale change between easy &amp; hard scenes (0.0-1.0)</span></span><br><span class="line">    <span class="keyword">float</span> qblur;      <span class="comment">///&lt; amount of qscale smoothing over time (0.0-1.0)</span></span><br><span class="line">    <span class="keyword">int</span> qmin;</span><br><span class="line">    <span class="keyword">int</span> qmax;</span><br><span class="line">    <span class="keyword">int</span> max_qdiff;</span><br><span class="line">    <span class="keyword">int</span> rc_buffer_size;</span><br><span class="line">    <span class="keyword">int</span> rc_override_count;</span><br><span class="line">    RcOverride *rc_override;</span><br><span class="line">    <span class="keyword">int64_t</span> rc_max_rate;</span><br><span class="line">    <span class="keyword">int64_t</span> rc_min_rate;</span><br><span class="line">    <span class="keyword">float</span> rc_max_available_vbv_use;</span><br><span class="line">    <span class="keyword">float</span> rc_min_vbv_overflow_use;</span><br><span class="line">    <span class="keyword">int</span> rc_initial_buffer_occupancy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_CODER_TYPE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FF_CODER_TYPE_VLC       0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CODER_TYPE_AC        1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CODER_TYPE_RAW       2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CODER_TYPE_RLE       3</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> coder_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* FF_API_CODER_TYPE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> context_model;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> frame_skip_threshold;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> frame_skip_factor;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> frame_skip_exp;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> frame_skip_cmp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> trellis;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> min_prediction_order;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> max_prediction_order;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int64_t</span> timecode_frame_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_RTP_CALLBACK</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">void</span> (*rtp_callback)(struct AVCodecContext *avctx, <span class="keyword">void</span> *data, <span class="keyword">int</span> size, <span class="keyword">int</span> mb_nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_PRIVATE_OPT</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> rtp_payload_size;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_STAT_BITS</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> mv_bits;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> header_bits;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> i_tex_bits;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> p_tex_bits;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> i_count;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> p_count;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> skip_count;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> misc_bits;</span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> frame_bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">char</span> *stats_out;</span><br><span class="line">    <span class="keyword">char</span> *stats_in;</span><br><span class="line">    <span class="keyword">int</span> workaround_bugs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_AUTODETECT       1  <span class="comment">///&lt; autodetection</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_XVID_ILACE       4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_UMP4             8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_NO_PADDING       16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_AMV              32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_QPEL_CHROMA      64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_STD_QPEL         128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_QPEL_CHROMA2     256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_DIRECT_BLOCKSIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_EDGE             1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_HPEL_CHROMA      2048</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_DC_CLIP          4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_MS               8192 <span class="comment">///&lt; Work around various bugs in Microsoft&#x27;s broken decoders.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_TRUNCATED       16384</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_BUG_IEDGE           32768</span></span><br><span class="line">    <span class="keyword">int</span> strict_std_compliance;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_COMPLIANCE_VERY_STRICT   2 <span class="comment">///&lt; Strictly conform to an older more strict version of the spec or reference software.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_COMPLIANCE_STRICT        1 <span class="comment">///&lt; Strictly conform to all the things in the spec no matter what consequences.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_COMPLIANCE_NORMAL        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_COMPLIANCE_UNOFFICIAL   -1 <span class="comment">///&lt; Allow unofficial extensions</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_COMPLIANCE_EXPERIMENTAL -2 <span class="comment">///&lt; Allow nonstandardized experimental things.</span></span></span><br><span class="line">    <span class="keyword">int</span> error_concealment;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_EC_GUESS_MVS   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_EC_DEBLOCK     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_EC_FAVOR_INTER 256</span></span><br><span class="line">    <span class="keyword">int</span> debug;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_PICT_INFO   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_RC          2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_BITSTREAM   4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_MB_TYPE     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_QP          16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_DEBUG_MV</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_MV          32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_DCT_COEFF   0x00000040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_SKIP        0x00000080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_STARTCODE   0x00000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_ER          0x00000400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_MMCO        0x00000800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_BUGS        0x00001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_DEBUG_MV</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_QP      0x00002000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MB_TYPE 0x00004000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_BUFFERS     0x00008000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_THREADS     0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_GREEN_MD    0x00800000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_NOMC        0x01000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_DEBUG_MV</span></span><br><span class="line">    <span class="keyword">int</span> debug_mv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MV_P_FOR  0x00000001 <span class="comment">// visualize forward predicted MVs of P-frames</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MV_B_FOR  0x00000002 <span class="comment">// visualize forward predicted MVs of B-frames</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MV_B_BACK 0x00000004 <span class="comment">// visualize backward predicted MVs of B-frames</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> err_recognition;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_CRCCHECK  (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_BITSTREAM (1&lt;&lt;1)          <span class="comment">///&lt; detect bitstream specification deviations</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_BUFFER    (1&lt;&lt;2)          <span class="comment">///&lt; detect improper bitstream length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_EXPLODE   (1&lt;&lt;3)          <span class="comment">///&lt; abort decoding on minor error detection</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_IGNORE_ERR (1&lt;&lt;15)        <span class="comment">///&lt; ignore errors and continue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_CAREFUL    (1&lt;&lt;16)        <span class="comment">///&lt; consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_COMPLIANT  (1&lt;&lt;17)        <span class="comment">///&lt; consider all spec non compliances as errors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_EF_AGGRESSIVE (1&lt;&lt;18)        <span class="comment">///&lt; consider things that a sane encoder should not do as an error</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> reordered_opaque;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVHWAccel</span> *<span class="title">hwaccel</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *hwaccel_context;</span><br><span class="line">    <span class="keyword">uint64_t</span> error[AV_NUM_DATA_POINTERS];</span><br><span class="line">    <span class="keyword">int</span> dct_algo;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DCT_AUTO    0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DCT_FASTINT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DCT_INT     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DCT_MMX     3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DCT_ALTIVEC 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DCT_FAAN    6</span></span><br><span class="line">    <span class="keyword">int</span> idct_algo;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_AUTO          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_INT           1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLE        2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLEMMX     3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_ARM           7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_ALTIVEC       8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLEARM     10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_XVID          14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLEARMV5TE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLEARMV6   17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_FAAN          20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLENEON    22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_NONE          24 <span class="comment">/* Used by XvMC to extract IDCT coefficients with FF_IDCT_PERM_NONE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_IDCT_SIMPLEAUTO    128</span></span><br><span class="line">    <span class="keyword">int</span> bits_per_coded_sample;</span><br><span class="line">    <span class="keyword">int</span> bits_per_raw_sample;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LOWRES</span></span><br><span class="line">     <span class="keyword">int</span> lowres;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_CODED_FRAME</span></span><br><span class="line">    attribute_deprecated AVFrame *coded_frame;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> thread_count;</span><br><span class="line">    <span class="keyword">int</span> thread_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_THREAD_FRAME   1 <span class="comment">///&lt; Decode more than one frame at once</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_THREAD_SLICE   2 <span class="comment">///&lt; Decode more than one part of a single frame at once</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> active_thread_type;</span><br><span class="line">    <span class="keyword">int</span> thread_safe_callbacks;</span><br><span class="line">    <span class="keyword">int</span> (*execute)(struct AVCodecContext *c, <span class="keyword">int</span> (*func)(struct AVCodecContext *c2, <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg2, <span class="keyword">int</span> *ret, <span class="keyword">int</span> count, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int</span> (*execute2)(struct AVCodecContext *c, <span class="keyword">int</span> (*func)(struct AVCodecContext *c2, <span class="keyword">void</span> *arg, <span class="keyword">int</span> jobnr, <span class="keyword">int</span> threadnr), <span class="keyword">void</span> *arg2, <span class="keyword">int</span> *ret, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span> nsse_weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> profile;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_LEVEL_UNKNOWN -99</span></span><br><span class="line">    <span class="keyword">enum</span> AVDiscard skip_loop_filter;</span><br><span class="line">    <span class="keyword">enum</span> AVDiscard skip_idct;</span><br><span class="line">    <span class="keyword">enum</span> AVDiscard skip_frame;</span><br><span class="line">    <span class="keyword">uint8_t</span> *subtitle_header;</span><br><span class="line">    <span class="keyword">int</span> subtitle_header_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_VBV_DELAY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_SIDEDATA_ONLY_PKT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> initial_padding;</span><br><span class="line">    AVRational framerate;</span><br><span class="line">    <span class="keyword">enum</span> AVPixelFormat sw_pix_fmt;</span><br><span class="line">    AVRational pkt_timebase;</span><br><span class="line">    <span class="keyword">const</span> AVCodecDescriptor *codec_descriptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !FF_API_LOWRES</span></span><br><span class="line">    <span class="keyword">int</span> lowres;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_correction_num_faulty_pts; <span class="comment">/// Number of incorrect PTS values so far</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_correction_num_faulty_dts; <span class="comment">/// Number of incorrect DTS values so far</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_correction_last_pts;       <span class="comment">/// PTS of the last frame</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_correction_last_dts;       <span class="comment">/// DTS of the last frame</span></span><br><span class="line">    <span class="keyword">char</span> *sub_charenc;</span><br><span class="line">    <span class="keyword">int</span> sub_charenc_mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_SUB_CHARENC_MODE_DO_NOTHING  -1  <span class="comment">///&lt; do nothing (demuxer outputs a stream supposed to be already in UTF-8, or the codec is bitmap for instance)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_SUB_CHARENC_MODE_AUTOMATIC    0  <span class="comment">///&lt; libavcodec will select the mode itself</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_SUB_CHARENC_MODE_PRE_DECODER  1  <span class="comment">///&lt; the AVPacket data needs to be recoded to UTF-8 before being fed to the decoder, requires iconv</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_SUB_CHARENC_MODE_IGNORE       2  <span class="comment">///&lt; neither convert the subtitles, nor check them for valid UTF-8</span></span></span><br><span class="line">    <span class="keyword">int</span> skip_alpha;</span><br><span class="line">    <span class="keyword">int</span> seek_preroll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !FF_API_DEBUG_MV</span></span><br><span class="line">    <span class="keyword">int</span> debug_mv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MV_P_FOR  0x00000001 <span class="comment">//visualize forward predicted MVs of P frames</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MV_B_FOR  0x00000002 <span class="comment">//visualize forward predicted MVs of B frames</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_DEBUG_VIS_MV_B_BACK 0x00000004 <span class="comment">//visualize backward predicted MVs of B frames</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint16_t</span> *chroma_intra_matrix;</span><br><span class="line">    <span class="keyword">uint8_t</span> *dump_separator;</span><br><span class="line">    <span class="keyword">char</span> *codec_whitelist;</span><br><span class="line">    <span class="keyword">unsigned</span> properties;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CODEC_PROPERTY_LOSSLESS        0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_CODEC_PROPERTY_CLOSED_CAPTIONS 0x00000002</span></span><br><span class="line">    AVPacketSideData *coded_side_data;</span><br><span class="line">    <span class="keyword">int</span>            nb_coded_side_data;</span><br><span class="line">    AVBufferRef *hw_frames_ctx;</span><br><span class="line">    <span class="keyword">int</span> sub_text_format;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_SUB_TEXT_FMT_ASS              0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_ASS_TIMING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> trailing_padding;</span><br><span class="line">    <span class="keyword">int64_t</span> max_pixels;</span><br><span class="line">    AVBufferRef *hw_device_ctx;</span><br><span class="line">    <span class="keyword">int</span> hwaccel_flags;</span><br><span class="line">    <span class="keyword">int</span> apply_cropping;</span><br><span class="line">    <span class="keyword">int</span> extra_hw_frames;</span><br><span class="line">    <span class="keyword">int</span> discard_damaged_percentage;</span><br><span class="line">    <span class="keyword">int64_t</span> max_samples;</span><br><span class="line">    <span class="keyword">int</span> export_side_data;</span><br><span class="line">&#125; AVCodecContext;</span><br></pre></td></tr></table></figure><p>PS:参考雷神博客<a href="https://link.zhihu.com/?target=https://blog.csdn.net/leixiaohua1020/article/details/14214859">https://blog.csdn.net/leixiaohu</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVCondecContext 是FFmpeg使用过程中比较重要的结构体&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>AVFormatContext结构体</title>
    <link href="http://example.com/jsblog/4a837348.html"/>
    <id>http://example.com/jsblog/4a837348.html</id>
    <published>2020-12-20T03:58:32.000Z</published>
    <updated>2020-12-20T04:20:59.412Z</updated>
    
    <content type="html"><![CDATA[<p>AVFormatContext 描述了一个媒体文件或者媒体流的构成和基本信息<a id="more"></a>，该结构体在avformat.h声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A class for logging and @ref avoptions. Set by avformat_alloc_context().</span></span><br><span class="line"><span class="comment">     * Exports (de)muxer private options if they exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The input container format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by avformat_open_input().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ff_const59 <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The output container format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Muxing only, must be set by the caller before avformat_write_header().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ff_const59 <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Format private data. This is an AVOptions-enabled struct</span></span><br><span class="line"><span class="comment">     * if and only if iformat/oformat.priv_class is not NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - muxing: set by avformat_write_header()</span></span><br><span class="line"><span class="comment">     * - demuxing: set by avformat_open_input()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * I/O context.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: either set by the user before avformat_open_input() (then</span></span><br><span class="line"><span class="comment">     *             the user must close it manually) or set by avformat_open_input().</span></span><br><span class="line"><span class="comment">     * - muxing: set by the user before avformat_write_header(). The caller must</span></span><br><span class="line"><span class="comment">     *           take care of closing / freeing the IO context.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do NOT set this field if AVFMT_NOFILE flag is set in</span></span><br><span class="line"><span class="comment">     * iformat/oformat.flags. In such a case, the (de)muxer will handle</span></span><br><span class="line"><span class="comment">     * I/O in some other way and this field will be NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVIOContext *pb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stream info */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flags signalling stream properties. A combination of AVFMTCTX_*.</span></span><br><span class="line"><span class="comment">     * Set by libavformat.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ctx_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of elements in AVFormatContext.streams.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Set by avformat_new_stream(), must not be modified by any other code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A list of all streams in the file. New streams are created with</span></span><br><span class="line"><span class="comment">     * avformat_new_stream().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: streams are created by libavformat in avformat_open_input().</span></span><br><span class="line"><span class="comment">     *             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also</span></span><br><span class="line"><span class="comment">     *             appear in av_read_frame().</span></span><br><span class="line"><span class="comment">     * - muxing: streams are created by the user before avformat_write_header().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Freed by libavformat in avformat_free_context().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVStream **streams;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_FORMAT_FILENAME</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * input or output filename</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: set by avformat_open_input()</span></span><br><span class="line"><span class="comment">     * - muxing: may be set by the caller before avformat_write_header()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @deprecated Use url instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">1024</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * input or output URL. Unlike the old filename field, this field has no</span></span><br><span class="line"><span class="comment">     * length restriction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: set by avformat_open_input(), initialized to an empty</span></span><br><span class="line"><span class="comment">     *             string if url parameter was NULL in avformat_open_input().</span></span><br><span class="line"><span class="comment">     * - muxing: may be set by the caller before calling avformat_write_header()</span></span><br><span class="line"><span class="comment">     *           (or avformat_init_output() if that is called first) to a string</span></span><br><span class="line"><span class="comment">     *           which is freeable by av_free(). Set to an empty string if it</span></span><br><span class="line"><span class="comment">     *           was NULL in avformat_init_output().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Freed by libavformat in avformat_free_context().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Position of the first frame of the component, in</span></span><br><span class="line"><span class="comment">     * AV_TIME_BASE fractional seconds. NEVER set this value directly:</span></span><br><span class="line"><span class="comment">     * It is deduced from the AVStream values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by libavformat.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Duration of the stream, in AV_TIME_BASE fractional</span></span><br><span class="line"><span class="comment">     * seconds. Only set this value if you know none of the individual stream</span></span><br><span class="line"><span class="comment">     * durations and also do not set any of them. This is deduced from the</span></span><br><span class="line"><span class="comment">     * AVStream values if not set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by libavformat.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Total stream bitrate in bit/s, 0 if not</span></span><br><span class="line"><span class="comment">     * available. Never set it directly if the file_size and the</span></span><br><span class="line"><span class="comment">     * duration are known as FFmpeg can compute it automatically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">int</span> max_delay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.</span></span><br><span class="line"><span class="comment">     * Set by the user before avformat_open_input() / avformat_write_header().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_GENPTS       0x0001 <span class="comment">///&lt; Generate missing pts even if it requires parsing future frames.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_IGNIDX       0x0002 <span class="comment">///&lt; Ignore index.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NONBLOCK     0x0004 <span class="comment">///&lt; Do not block when reading packets from input.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_IGNDTS       0x0008 <span class="comment">///&lt; Ignore DTS on frames that contain both DTS &amp; PTS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NOFILLIN     0x0010 <span class="comment">///&lt; Do not infer any values from other values, just return what is stored in the container</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NOPARSE      0x0020 <span class="comment">///&lt; Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -&gt; no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NOBUFFER     0x0040 <span class="comment">///&lt; Do not buffer frames when possible</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_CUSTOM_IO    0x0080 <span class="comment">///&lt; The caller has supplied a custom AVIOContext, don&#x27;t avio_close() it.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_DISCARD_CORRUPT  0x0100 <span class="comment">///&lt; Discard frames marked corrupted</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_FLUSH_PACKETS    0x0200 <span class="comment">///&lt; Flush the AVIOContext every packet.</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When muxing, try to avoid writing any random/volatile data to the output.</span></span><br><span class="line"><span class="comment"> * This includes any random IDs, real-time timestamps/dates, muxer version, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This flag is mainly intended for testing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_BITEXACT         0x0400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_MP4A_LATM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_MP4A_LATM    0x8000 <span class="comment">///&lt; Deprecated, does nothing.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_SORT_DTS    0x10000 <span class="comment">///&lt; try to interleave outputted packets by dts (using this flag can slow demuxing down)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_PRIV_OPT    0x20000 <span class="comment">///&lt; Enable use of private options by delaying codec open (this could be made default once all code is converted)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_KEEPSIDE_FLAG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_KEEP_SIDE_DATA 0x40000 <span class="comment">///&lt; Deprecated, does nothing.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_FAST_SEEK   0x80000 <span class="comment">///&lt; Enable fast, but inaccurate seeks for some formats</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_SHORTEST   0x100000 <span class="comment">///&lt; Stop muxing when the shortest stream stops.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_AUTO_BSF   0x200000 <span class="comment">///&lt; Add bitstream filters as requested by the muxer</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum size of the data read from input for determining</span></span><br><span class="line"><span class="comment">     * the input container format.</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by the caller before avformat_open_input().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> probesize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum duration (in AV_TIME_BASE units) of the data read</span></span><br><span class="line"><span class="comment">     * from input in avformat_find_stream_info().</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by the caller before avformat_find_stream_info().</span></span><br><span class="line"><span class="comment">     * Can be set to 0 to let avformat choose using a heuristic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_analyze_duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *key;</span><br><span class="line">    <span class="keyword">int</span> keylen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_programs;</span><br><span class="line">    AVProgram **programs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced video codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID video_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced audio codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID audio_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced subtitle codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID subtitle_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum amount of memory in bytes to use for the index of each stream.</span></span><br><span class="line"><span class="comment">     * If the index exceeds this size, entries will be discarded as</span></span><br><span class="line"><span class="comment">     * needed to maintain a smaller size. This can lead to slower or less</span></span><br><span class="line"><span class="comment">     * accurate seeking (depends on demuxer).</span></span><br><span class="line"><span class="comment">     * Demuxers for which a full in-memory index is mandatory will ignore</span></span><br><span class="line"><span class="comment">     * this.</span></span><br><span class="line"><span class="comment">     * - muxing: unused</span></span><br><span class="line"><span class="comment">     * - demuxing: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum amount of memory in bytes to use for buffering frames</span></span><br><span class="line"><span class="comment">     * obtained from realtime capture devices.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of chapters in AVChapter array.</span></span><br><span class="line"><span class="comment">     * When muxing, chapters are normally written in the file header,</span></span><br><span class="line"><span class="comment">     * so nb_chapters should normally be initialized before write_header</span></span><br><span class="line"><span class="comment">     * is called. Some muxers (e.g. mov and mkv) can also write chapters</span></span><br><span class="line"><span class="comment">     * in the trailer.  To write chapters in the trailer, nb_chapters</span></span><br><span class="line"><span class="comment">     * must be zero when write_header is called and non-zero when</span></span><br><span class="line"><span class="comment">     * write_trailer is called.</span></span><br><span class="line"><span class="comment">     * - muxing: set by user</span></span><br><span class="line"><span class="comment">     * - demuxing: set by libavformat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_chapters;</span><br><span class="line">    AVChapter **chapters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Metadata that applies to the whole file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: set by libavformat in avformat_open_input()</span></span><br><span class="line"><span class="comment">     * - muxing: may be set by the caller before avformat_write_header()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Freed by libavformat in avformat_free_context().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start time of the stream in real world time, in microseconds</span></span><br><span class="line"><span class="comment">     * since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the</span></span><br><span class="line"><span class="comment">     * stream was captured at this real world time.</span></span><br><span class="line"><span class="comment">     * - muxing: Set by the caller before avformat_write_header(). If set to</span></span><br><span class="line"><span class="comment">     *           either 0 or AV_NOPTS_VALUE, then the current wall-time will</span></span><br><span class="line"><span class="comment">     *           be used.</span></span><br><span class="line"><span class="comment">     * - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that</span></span><br><span class="line"><span class="comment">     *             the value may become known after some number of frames</span></span><br><span class="line"><span class="comment">     *             have been received.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_time_realtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of frames used for determining the framerate in</span></span><br><span class="line"><span class="comment">     * avformat_find_stream_info().</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by the caller before avformat_find_stream_info().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> fps_probe_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Error recognition; higher values will detect more errors but may</span></span><br><span class="line"><span class="comment">     * misdetect some more or less valid parts as errors.</span></span><br><span class="line"><span class="comment">     * Demuxing only, set by the caller before avformat_open_input().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> error_recognition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom interrupt callbacks for the I/O layer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * demuxing: set by the user before avformat_open_input().</span></span><br><span class="line"><span class="comment">     * muxing: set by the user before avformat_write_header()</span></span><br><span class="line"><span class="comment">     * (mainly useful for AVFMT_NOFILE formats). The callback</span></span><br><span class="line"><span class="comment">     * should also be passed to avio_open2() if it&#x27;s used to</span></span><br><span class="line"><span class="comment">     * open the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flags to enable debugging.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> debug;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_FDEBUG_TS        0x0001</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum buffering duration for interleaving.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * To ensure all the streams are interleaved correctly,</span></span><br><span class="line"><span class="comment">     * av_interleaved_write_frame() will wait until it has at least one packet</span></span><br><span class="line"><span class="comment">     * for each stream before actually writing any packets to the output file.</span></span><br><span class="line"><span class="comment">     * When some streams are &quot;sparse&quot; (i.e. there are large gaps between</span></span><br><span class="line"><span class="comment">     * successive packets), this can result in excessive buffering.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This field specifies the maximum difference between the timestamps of the</span></span><br><span class="line"><span class="comment">     * first and the last packet in the muxing queue, above which libavformat</span></span><br><span class="line"><span class="comment">     * will output a packet regardless of whether it has queued a packet for all</span></span><br><span class="line"><span class="comment">     * the streams.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Muxing only, set by the caller before avformat_write_header().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_interleave_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allow non-standard and experimental extension</span></span><br><span class="line"><span class="comment">     * @see AVCodecContext.strict_std_compliance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> strict_std_compliance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flags for the user to detect events happening on the file. Flags must</span></span><br><span class="line"><span class="comment">     * be cleared by the user once the event has been handled.</span></span><br><span class="line"><span class="comment">     * A combination of AVFMT_EVENT_FLAG_*.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> event_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001 <span class="comment">///&lt; The call resulted in updated metadata.</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum number of packets to read while waiting for the first timestamp.</span></span><br><span class="line"><span class="comment">     * Decoding only.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max_ts_probe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Avoid negative timestamps during muxing.</span></span><br><span class="line"><span class="comment">     * Any value of the AVFMT_AVOID_NEG_TS_* constants.</span></span><br><span class="line"><span class="comment">     * Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)</span></span><br><span class="line"><span class="comment">     * - muxing: Set by user</span></span><br><span class="line"><span class="comment">     * - demuxing: unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> avoid_negative_ts;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_AVOID_NEG_TS_AUTO             -1 <span class="comment">///&lt; Enabled when required by target format</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 <span class="comment">///&lt; Shift timestamps so they are non negative</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_AVOID_NEG_TS_MAKE_ZERO         2 <span class="comment">///&lt; Shift timestamps so that they start at 0</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transport stream id.</span></span><br><span class="line"><span class="comment">     * This will be moved into demuxer private options. Thus no API/ABI compatibility</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ts_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio preload in microseconds.</span></span><br><span class="line"><span class="comment">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user</span></span><br><span class="line"><span class="comment">     * - decoding: unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> audio_preload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Max chunk time in microseconds.</span></span><br><span class="line"><span class="comment">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user</span></span><br><span class="line"><span class="comment">     * - decoding: unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max_chunk_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Max chunk size in bytes</span></span><br><span class="line"><span class="comment">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user</span></span><br><span class="line"><span class="comment">     * - decoding: unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * forces the use of wallclock timestamps as pts/dts of packets</span></span><br><span class="line"><span class="comment">     * This has undefined results in the presence of B frames.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> use_wallclock_as_timestamps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * avio flags, used to force AVIO_FLAG_DIRECT.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> avio_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The duration field can be estimated through various ways, and this field can be used</span></span><br><span class="line"><span class="comment">     * to know how the duration was estimated.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Read by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVDurationEstimationMethod duration_estimation_method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Skip initial bytes when opening stream</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> skip_initial_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Correct single timestamp overflows</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> correct_ts_overflow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Force seeking to any (also non key) frames.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> seek2any;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flush the I/O context after each packet.</span></span><br><span class="line"><span class="comment">     * - encoding: Set by user</span></span><br><span class="line"><span class="comment">     * - decoding: unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> flush_packets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * format probing score.</span></span><br><span class="line"><span class="comment">     * The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes</span></span><br><span class="line"><span class="comment">     * the format.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by avformat, read by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> probe_score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * number of bytes to read maximally to identify format.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> format_probesize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;,&#x27; separated list of allowed decoders.</span></span><br><span class="line"><span class="comment">     * If NULL then all are allowed</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *codec_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;,&#x27; separated list of allowed demuxers.</span></span><br><span class="line"><span class="comment">     * If NULL then all are allowed</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *format_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An opaque field for libavformat internal usage.</span></span><br><span class="line"><span class="comment">     * Must not be accessed in any way by callers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVFormatInternal *internal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IO repositioned flag.</span></span><br><span class="line"><span class="comment">     * This is set by avformat when the underlaying IO context read pointer</span></span><br><span class="line"><span class="comment">     * is repositioned, for example when doing byte based seeking.</span></span><br><span class="line"><span class="comment">     * Demuxers can use the flag to detect such changes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> io_repositioned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced video codec.</span></span><br><span class="line"><span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></span><br><span class="line"><span class="comment">     * the same codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVCodec *video_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced audio codec.</span></span><br><span class="line"><span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></span><br><span class="line"><span class="comment">     * the same codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVCodec *audio_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced subtitle codec.</span></span><br><span class="line"><span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></span><br><span class="line"><span class="comment">     * the same codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVCodec *subtitle_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced data codec.</span></span><br><span class="line"><span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></span><br><span class="line"><span class="comment">     * the same codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVCodec *data_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of bytes to be written as padding in a metadata header.</span></span><br><span class="line"><span class="comment">     * Demuxing: Unused.</span></span><br><span class="line"><span class="comment">     * Muxing: Set by user via av_format_set_metadata_header_padding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> metadata_header_padding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User data.</span></span><br><span class="line"><span class="comment">     * This is a place for some private data of the user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback used by devices to communicate with application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    av_format_control_message control_message_cb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Output timestamp offset, in microseconds.</span></span><br><span class="line"><span class="comment">     * Muxing: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> output_ts_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dump format separator.</span></span><br><span class="line"><span class="comment">     * can be &quot;, &quot; or &quot;\n      &quot; or anything else</span></span><br><span class="line"><span class="comment">     * - muxing: Set by user.</span></span><br><span class="line"><span class="comment">     * - demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *dump_separator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forced Data codec_id.</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID data_codec_id;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_OLD_OPEN_CALLBACKS</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called to open further IO contexts when needed for demuxing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This can be set by the user application to perform security checks on</span></span><br><span class="line"><span class="comment">     * the URLs before opening them.</span></span><br><span class="line"><span class="comment">     * The function should behave like avio_open2(), AVFormatContext is provided</span></span><br><span class="line"><span class="comment">     * as contextual information and to reach AVFormatContext.opaque.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If NULL then some simple checks are used together with avio_open2().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Must not be accessed directly from outside avformat.</span></span><br><span class="line"><span class="comment">     * @See av_format_set_open_cb()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @deprecated Use io_open and io_close.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> (*open_cb)(struct AVFormatContext *s, AVIOContext **p, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;,&#x27; separated list of allowed protocols.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *protocol_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callback for opening new IO streams.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Whenever a muxer or a demuxer needs to open an IO stream (typically from</span></span><br><span class="line"><span class="comment">     * avformat_open_input() for demuxers, but for certain formats can happen at</span></span><br><span class="line"><span class="comment">     * other times as well), it will call this callback to obtain an IO context.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param s the format context</span></span><br><span class="line"><span class="comment">     * @param pb on success, the newly opened IO context should be returned here</span></span><br><span class="line"><span class="comment">     * @param url the url to open</span></span><br><span class="line"><span class="comment">     * @param flags a combination of AVIO_FLAG_*</span></span><br><span class="line"><span class="comment">     * @param options a dictionary of additional options, with the same</span></span><br><span class="line"><span class="comment">     *                semantics as in avio_open2()</span></span><br><span class="line"><span class="comment">     * @return 0 on success, a negative AVERROR code on failure</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note Certain muxers and demuxers do nesting, i.e. they open one or more</span></span><br><span class="line"><span class="comment">     * additional internal format contexts. Thus the AVFormatContext pointer</span></span><br><span class="line"><span class="comment">     * passed to this callback may be different from the one facing the caller.</span></span><br><span class="line"><span class="comment">     * It will, however, have the same &#x27;opaque&#x27; field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*io_open)(struct AVFormatContext *s, AVIOContext **pb, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span><br><span class="line">                   <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callback for closing the streams opened with AVFormatContext.io_open().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*io_close)(struct AVFormatContext *s, AVIOContext *pb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;,&#x27; separated list of disallowed protocols.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *protocol_blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum number of streams.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Skip duration calcuation in estimate_timings_from_pts.</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> skip_estimate_duration_from_pts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum number of packets that can be probed</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: set by user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max_probe_packets;</span><br><span class="line">&#125; AVFormatContext;</span><br></pre></td></tr></table></figure><p>在使用FFMPEG对音视频解封装和封装的时候都需要使用到AVFormatContext在使用FFMPEG进行开发的过程中是一个贯穿始终的数据结构，很多的函数都需要使用到此结构体作为参数。看一下几个主要的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入数据的封装格式，仅解封转由avformat_open_input（）设置</span></span><br><span class="line">ff_const59 <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span></span><br><span class="line"><span class="comment">//输出数据的封装格式,仅封装时使用，调用者在调用avformat_write_header(）之前设置</span></span><br><span class="line">ff_const59 <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span> </span><br><span class="line"><span class="comment">//I/O上下文，解封装：用户在avformat_open_input()之前设置用户手动关闭，或通过avformat_open_input()设置</span></span><br><span class="line"><span class="comment">//封装：在调用avformat_write_header()之前调用，用户设置后必须注意关闭</span></span><br><span class="line">AVIOContext *pb; </span><br><span class="line"><span class="comment">//AVFormatContext.streams 的元素数量，只能被avformat_new_stream()设置，不能以其他方式更改</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams;</span><br><span class="line"><span class="comment">//文件中音视频流列表</span></span><br><span class="line">AVStream **streams;</span><br><span class="line"><span class="comment">//输入输出文件路径,没有长度限制</span></span><br><span class="line"><span class="keyword">char</span> *url;</span><br><span class="line"><span class="comment">//第一帧的位置</span></span><br><span class="line"><span class="keyword">int64_t</span> start_time;</span><br><span class="line"><span class="comment">//音视频流的持续时间</span></span><br><span class="line"><span class="keyword">int64_t</span> duration;</span><br><span class="line"><span class="comment">//总比特率bit/s，不可用时为0</span></span><br><span class="line"><span class="keyword">int64_t</span> bit_rate;</span><br><span class="line"><span class="comment">//仅封装使用，从输入读取用于确定输入容器格式的最大大小，在调用avforamat_open_input()之前设置</span></span><br><span class="line"><span class="keyword">int64_t</span> probesize;</span><br><span class="line"><span class="comment">//视频解码器ID，解封装，用户设置</span></span><br><span class="line"> <span class="keyword">enum</span> AVCodecID video_codec_id;</span><br><span class="line"><span class="comment">//音频解码器ID,解封装，用户设置</span></span><br><span class="line"> <span class="keyword">enum</span> AVCodecID audio_codec_id;</span><br><span class="line"><span class="comment">//字幕解码器ID</span></span><br><span class="line"> <span class="keyword">enum</span> AVCodecID subtitle_codec_id;</span><br><span class="line"><span class="comment">//数据解码器ID</span></span><br><span class="line"><span class="keyword">enum</span> AVCodecID data_codec_id</span><br><span class="line"><span class="comment">//文件的元数据</span></span><br><span class="line">AVDictionary *metadata;</span><br><span class="line"><span class="comment">//用户指定的用于解封装的音视频解码器</span></span><br><span class="line">AVCodec *video_codec;</span><br><span class="line">AVCodec *audio_codec;</span><br><span class="line"><span class="comment">//字幕解码器</span></span><br><span class="line">AVCodec *subtitle_codec;</span><br><span class="line"><span class="comment">//用户指定的用于解封装的数据解码器</span></span><br><span class="line"> AVCodec *data_codec;</span><br><span class="line"><span class="comment">//打开Io stream的回调函数</span></span><br><span class="line"><span class="keyword">int</span> (*io_open)(struct AVFormatContext *s, AVIOContext **pb, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span><br><span class="line">                   <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line"><span class="comment">//关闭使用AVFormatContext.io_open()打开的流的回调函数</span></span><br><span class="line"><span class="keyword">void</span> (*io_close)(struct AVFormatContext *s, AVIOContext *pb);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;AVFormatContext 描述了一个媒体文件或者媒体流的构成和基本信息&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG结构体</title>
    <link href="http://example.com/jsblog/ca777205.html"/>
    <id>http://example.com/jsblog/ca777205.html</id>
    <published>2020-12-20T03:54:18.000Z</published>
    <updated>2020-12-20T04:20:59.398Z</updated>
    
    <content type="html"><![CDATA[<p>FFMPEG中最关键的结构体，主要用于解协议，解封装，解码以及存数据。 <a id="more"></a></p><p><strong>解协议(http,rtsp,rtmp,mms)：</strong></p><p>AVIOContext,URLProtocol,URLContext主要存储视音频使用的协议的类型以及状态。URLProtocol存储输入视音频使用的封装格式。每一种协议都对应一个URLProtocol结构。</p><p><strong>解封装（flv,avi,rmvb,mp4）:</strong></p><p>AVFormatContext主要存储视音频封装格式中包含的信息；AVInputFormat 存储输入音视频使用的封装格式，每种音视频封装格式都对应一个AVInputFormat 结构</p><p><strong>解码（h264,mpeg2,aac,mp3，ogg等）:</strong></p><p>每个AVStream存储一个视音频流的相关数据；每个AVStream对应一个AVCodecContext,存储该视音频流使用解码方式的相关数据；每个AVCodecContext中对应一个AVCodec,包含该视音频对应的解码器。每个解码器都对应一个AVCodec结构。</p><p><strong>存数据：（主要是包packet和frame）</strong></p><p>数据中每个packet可能包含多个frame，需要通过解码将packet中frame提取出来。视频每个frame都是一帧，音频要好几个frame</p><p>解码前的数据为：AVPacket;</p><p>解码后的数据为：AVFrame</p><p>关系如图：（引用雷神的图）</p><p><img src="https://pic4.zhimg.com/80/v2-335a7efc53276ebeed9744f52b8972f7_720w.jpg" alt="img"></p><p>参考雷神的博客：**<a href="https://link.zhihu.com/?target=https://blog.csdn.net/leixiaohua1020/article/details/11693997">《FFMPEG中最关键的结构体之间的关系》</a>**</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;FFMPEG中最关键的结构体，主要用于解协议，解封装，解码以及存数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>解码视频</title>
    <link href="http://example.com/jsblog/3836e290.html"/>
    <id>http://example.com/jsblog/3836e290.html</id>
    <published>2020-12-20T03:50:10.000Z</published>
    <updated>2020-12-20T04:20:59.407Z</updated>
    
    <content type="html"><![CDATA[<p>解码视频和解码音频的算法步骤差不多，在这里还是参考雷神的博客 <a id="more"></a></p><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/leixiaohua1020/article/details/38868499?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">《最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）》</a></p><p>，并参考FFMPEG官网示例程序。从最基础的版本学习开始。首先来看一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="comment">//log函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_packet</span><span class="params">(<span class="keyword">const</span> AVFormatContext *fmt_ctx, <span class="keyword">const</span> AVPacket *pkt, <span class="keyword">const</span> <span class="keyword">char</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n&quot;</span>,</span><br><span class="line">           tag,</span><br><span class="line">           av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base),</span><br><span class="line">           av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base),</span><br><span class="line">           pkt-&gt;stream_index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//step 1 register all muxing and demuxing</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_url = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output_url = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//step 2 calloc the FormatContext</span></span><br><span class="line">    AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    ifmt_ctx = avformat_alloc_context();</span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;ifmt_ctx,input_url,<span class="literal">NULL</span>,<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t open the input stream\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//step 3 find the stream info</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(ifmt_ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t find the input stream information\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用av_dump_format()为AVFormatContext中得streams填上正确信息</span></span><br><span class="line">    av_dump_format(ifmt_ctx,<span class="number">0</span>,input_url,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请输出context</span></span><br><span class="line">    AVFormatContext *ofmt_Ctx = <span class="literal">NULL</span>;</span><br><span class="line">    avformat_alloc_output_context2(&amp;ofmt_Ctx,<span class="literal">NULL</span>,<span class="literal">NULL</span>,output_url);</span><br><span class="line">    <span class="keyword">if</span> (!ofmt_Ctx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to allocat the output context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取输出格式</span></span><br><span class="line">    AVOutputFormat *ofmt = ofmt_Ctx-&gt;oformat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stream_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> stream_mapping_size = ifmt_ctx-&gt;nb_streams;</span><br><span class="line">    <span class="keyword">int</span> *stream_mapping = <span class="literal">NULL</span>;</span><br><span class="line">    stream_mapping = av_mallocz_array(stream_mapping_size,<span class="keyword">sizeof</span>(*stream_mapping));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; stream_mapping_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取音视频信息流的索引</span></span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVCodecParameters *in_codecpar = in_stream-&gt;codecpar;</span><br><span class="line">        <span class="keyword">if</span>(in_codecpar-&gt;codec_type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">            in_codecpar-&gt;codec_type != AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">            in_codecpar-&gt;codec_type != AVMEDIA_TYPE_SUBTITLE)&#123;</span><br><span class="line">                stream_mapping[i] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stream_mapping[i] = stream_index++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//申请输出AVStream</span></span><br><span class="line">             AVStream *out_stream;</span><br><span class="line">             out_stream = avformat_new_stream(ofmt_Ctx,in_stream-&gt;codec-&gt;codec);</span><br><span class="line">            <span class="keyword">if</span> (!out_stream)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;fail to allocated the output stream\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码器信息进行copy</span></span><br><span class="line">            <span class="keyword">if</span> (avcodec_parameters_copy(out_stream-&gt;codecpar,in_codecpar) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;fail to copy the avcodec parameters\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用av_dump_format()为AVFormatContext中得streams填上正确信息</span></span><br><span class="line">    av_dump_format(ofmt_Ctx,<span class="number">0</span>,output_url,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//打开输出文件</span></span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(avio_open(&amp;ofmt_Ctx-&gt;pb,output_url,AVIO_FLAG_WRITE) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not open the file output file\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入信息头</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_write_header(ofmt_Ctx,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured when opening output file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取每一帧并保存到输出文件中</span></span><br><span class="line">    AVPacket *pkt = <span class="literal">NULL</span>;</span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        AVStream *in_stream,*out_stream;</span><br><span class="line">        <span class="keyword">if</span> (av_read_frame(ifmt_ctx,pkt) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        in_stream = ifmt_ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        <span class="comment">//当前packet无效</span></span><br><span class="line">        <span class="keyword">if</span>(pkt-&gt;stream_index &gt;= stream_mapping_size ||</span><br><span class="line">           stream_mapping[pkt-&gt;stream_index] &lt; <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">            av_packet_unref(pkt);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           pkt-&gt;stream_index = stream_mapping[pkt-&gt;stream_index];</span><br><span class="line">           out_stream = ofmt_Ctx-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">            <span class="comment">//输出日志信息</span></span><br><span class="line">            log_packet(ifmt_ctx,pkt,<span class="string">&quot;in&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//copy packet</span></span><br><span class="line">            pkt-&gt;pts = av_rescale_q_rnd(pkt-&gt;pts,in_stream-&gt;time_base,out_stream-&gt;time_base,AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">            pkt-&gt;dts = av_rescale_q_rnd(pkt-&gt;dts,in_stream-&gt;time_base,out_stream-&gt;time_base,AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">            pkt-&gt;duration = av_rescale_q(pkt-&gt;duration,in_stream-&gt;time_base,out_stream-&gt;time_base);</span><br><span class="line">            pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">            log_packet(ofmt_Ctx,pkt,<span class="string">&quot;out&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av_interleaved_write_frame(ofmt_Ctx,pkt) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error in muxing packet\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入尾部信息</span></span><br><span class="line">    av_write_trailer(ofmt_Ctx);</span><br><span class="line">    <span class="comment">//释放申请的资源</span></span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    <span class="comment">//关闭输出环境</span></span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">    &#123;</span><br><span class="line">        avio_closep(&amp;ofmt_Ctx-&gt;pb);</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_free_context(ofmt_Ctx);</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤如下：</p><ol><li>注册Muxer 和 Demuxer</li><li>构建输入AVFormatContext，使用avformat_allo_context()并使用avformat_open_input()与文件关联起来</li><li>使用av_find_stream_info()查找音视频流信息</li><li>构建输出AVFormatContext使用avformat_alloc_output_context2()和输出文件关联起来</li><li>申请AVStream，输入输出流，对于输出流需要使用acformat_new_stream() 函数初始化</li><li>使用avcodec_parameters_copy ()复制解码器信息，在复制好解码器信息之后，要使用avio_open()函数设置输出文件为写入，最后使用avio_closep()释放数据</li><li>使用avformat_write_header()写入文件头信息</li><li>将数据包packet写入，首先使用av_read_frame()读取每一个包</li><li>使用av_write_trailer()写入文件尾部信息</li><li>释放所有申请的资源</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;解码视频和解码音频的算法步骤差不多，在这里还是参考雷神的博客&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
</feed>
