<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-12T03:01:48.918Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV for Windows</title>
    <link href="http://example.com/jsblog/2116d0b5.html"/>
    <id>http://example.com/jsblog/2116d0b5.html</id>
    <published>2020-09-12T03:00:29.000Z</published>
    <updated>2020-09-12T03:01:48.918Z</updated>
    
    <content type="html"><![CDATA[<p>我的配置是vs2015+opencv3.4.0。opencv3.4.0可以在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Releases - OpenCV library 官方网站下载，当然你也可以在  </span><br><span class="line">OpenCV GitHub进行下载，如果在GitHub下载，在Windows上你需要自己编译，使用vs2015或者cmake进行编译</span><br></pre></td></tr></table></figure><p>使用cmake编译的时候首先打开cmd然后进入<strong>opencv安装目录下的源代码目录下，</strong>使用如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build </span><br><span class="line"> cmake .. -DCMAKE_INSTALL_PREFIX=D:/opencv</span><br></pre></td></tr></table></figure><p>”-DCMAKE_INSTALL_PREFIX=D:/opencv“ 设置其安装目录为D盘opencv目录。</p><p>就拿我的配置环境来说：</p><p>我先在官网下载opencv3.4.0.exe文件然后解压到D盘，首先要配置好环境变量，打开<strong>控制面板</strong>找到<strong>系统</strong>（或者系统与安全）</p><p><img src="https://pic3.zhimg.com/80/v2-dec01822104fa1e0edc58bea8c506b78_720w.jpg" alt="img"></p><p>点击高级系统设置，然后选择环境变量</p><p><img src="https://pic2.zhimg.com/80/v2-d8e2412a9b2f5b4a39a4ca35402e35cc_720w.jpg" alt="img"></p><p>点击环境变量，然后找到<strong>path变量</strong></p><p><img src="https://pic2.zhimg.com/80/v2-2716ee22eb16b2bc7b6aec39e32472ad_720w.jpg" alt="img"></p><p>点击新建，然后将</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc14\bin</span><br><span class="line">D:\opencv\opencv\build\x64\vc15\bin</span><br></pre></td></tr></table></figure><p>加入环境变量（我的opencv配置是64位的，所以在vs2015创建项目学习opencv的时候</p><p><img src="https://pic3.zhimg.com/80/v2-b17d6291df112e3cf963f81545927747_720w.jpg" alt="img"></p><p>一定要把x86改成x64还有就是一定把debug改成release才能运行，其他版本的opencv不一定要把debug改成release）</p><p>添加好环境变量之后，就是修改vs2015的c++配置,首先新建一个<strong>win32控制台项目</strong>，然后</p><p><img src="https://pic3.zhimg.com/80/v2-f990d5b644dbce886cde0c9d83c7d6f6_720w.jpg" alt="img"></p><p>点击属性管理器，</p><p><img src="https://pic1.zhimg.com/80/v2-a55e65fa2b922270b83ef380a37365c4_720w.jpg" alt="img"></p><p>点击</p><p><img src="https://pic1.zhimg.com/80/v2-8dd9f2c7e64db07b1967b0104c8f8340_720w.jpg" alt="img"></p><p>进入属性设置</p><p><img src="https://pic2.zhimg.com/80/v2-55934bf0d09dff9b742f2788a9e1452e_720w.jpg" alt="img"></p><p>在包含目录将opencv解压目录下的build目录下的include添加进去，在链接器中选择输入</p><p><img src="https://pic4.zhimg.com/80/v2-817bd286ef6360b08cea8e23046bd7bb_720w.jpg" alt="img"></p><p>在输入中的附加依赖项将（在我的电脑上就是）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc14\lib\opencv_world340.lib</span><br><span class="line">D:\opencv\opencv\build\x64\vc14\lib\opencv_world340d.lib  opencv_world340d.lib代表debug版本</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc15\lib\opencv_world340.lib</span><br><span class="line">D:\opencv\opencv\build\x64\vc15\lib\opencv_world340d.lib  opencv_world340d.lib代表debug版本</span><br></pre></td></tr></table></figure><p>选择14还是15要看你的visual c++编译器版本。我们来测试一下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat img = imread(&quot;D:\\opencv\\opencv\\sources\\samples\\data\\lena.jpg&quot;);</span><br><span class="line">imshow(&quot;lena image&quot;,img);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyWindow(&quot;lena image&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-b58b2195ff3a74de0f816370e40330a2_720w.jpg" alt="img"></p><p>当出现这张图片的时候就可以进行opencv的开发。其他版本的配置也与此类似</p><p><strong>python:</strong></p><p>首先在</p><p><a href="https://link.zhihu.com/?target=https://www.python.org/">Welcome to Python.orgwww.python.org<img src="https://picb.zhimg.com/v2-ff06c339780f23112c1cbbbb284158ff_ipico.jpg" alt="图标"></a></p><p>首先在</p><p><a href="https://link.zhihu.com/?target=https://www.python.org/">https://www.python.org/</a></p><p>官网上下载python3.5.4由于我的电脑是64位的所以我选择的是python3.5.4</p><p><img src="https://pic3.zhimg.com/80/v2-c0257b899bd67be788689b6a0066dbd9_720w.jpg" alt="img"></p><p>这个版本，在安装的时候要要把python添加进入环境变量，要不然就需要自己配置环境变量</p><p>安装好之后打开cmd然后输入python,如果出现下图结果则安装完成。</p><p><img src="https://pic4.zhimg.com/80/v2-d485d17d55d51482e0684f142784d308_720w.jpg" alt="img"></p><p>要安装opencv首先要安装numpy这个时候可以使用pip来进行安装opencv。安装命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br><span class="line">pip install opencv_python</span><br><span class="line">pip install opencv-contrib-python // opencv的扩展包，里边有一些图像处理的算法</span><br></pre></td></tr></table></figure><p>我们看个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&quot;imgs/2.jpg&quot;,cv.IMREAD_COLOR)</span><br><span class="line">cv.imshow(&quot;opencv_demo&quot;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>如果出现</p><p><img src="https://pic1.zhimg.com/80/v2-153b395419d1671cd205ca3bd2eb0694_720w.jpg" alt="img"></p><p>读入的图片表明python3.5.4+opencv环境已经配好啦</p><p>接下来就可以进行我们的opencv的开发了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的配置是vs2015+opencv3.4.0。opencv3.4.0可以在&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>读写图片</title>
    <link href="http://example.com/jsblog/96b8a012.html"/>
    <id>http://example.com/jsblog/96b8a012.html</id>
    <published>2020-09-12T02:58:56.000Z</published>
    <updated>2020-09-12T03:00:14.172Z</updated>
    
    <content type="html"><![CDATA[<p>上一话我们已经把opencv的环境配置完成，那么我们接下来分析一下上一话的例子。</p><a id="more"></a><p><strong>图像读入：imread</strong></p><p>首先我们来看一下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat img = imread(&quot;D:\\opencv\\opencv\\sources\\samples\\data\\lena.jpg&quot;);</span><br><span class="line">imshow(&quot;lena image&quot;,img);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyWindow(&quot;lena image&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是使用c++来写的，而opencv就是机遇c++开发的，所以我们使用c++来对<strong>imread</strong>,<strong>imshow</strong>以及<strong>imwrite</strong>这三个API进行讲解。当然在使用c++调用opencv的API有两种方法，一种就是在前面引用opencv的命名空间，然后直接调用其API;二是使用域解析符（::）加上要调用的函数名称。在这个例子中我所使用的就是第一种方法。</p><p>接下来我们看一下imread函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat cv::imread(const string&amp; filename,int flags&#x3D;MREAD_COLOR);</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>**filename:**需要加载的文件</li><li>**flags:**是指加载图片时的标识，指定图片的类型</li></ul><p>Mat类型是一个矩阵类型，如果imread对文件无法解码，就会返回一个NULL，空的矩阵。</p><p>opencv支持的图片包含以下几种</p><ul><li>Windows bitmaps - *.bmp, *.dib (always supported)</li><li>JPEG files - *.jpeg, <em>.jpg, *.jpe (see the *Notes</em> section)</li><li>JPEG 2000 files - *.jp2 (see the <em>Notes</em> section)</li><li>Portable Network Graphics - *.png (see the <em>Notes</em> section)</li><li>WebP - *.webp (see the <em>Notes</em> section)</li><li>Portable image format - *.pbm, *.pgm, *.ppm (always supported)</li><li>Sun rasters - *.sr, *.ras (always supported)</li><li>TIFF files - <em>.tiff, *.tif (see the *Notes</em> section)</li></ul><p><strong>NOTE：</strong></p><p>imread这个函数读取图片是根据文件内容来读取，而不是根据文件的扩展名。</p><p><strong>imread的flags有以下几种：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMREAD_UNCHANGED            = -1, //返回包含alpha通道的加载图像</span><br><span class="line">   IMREAD_GRAYSCALE            = 0,  //返回一个灰度图像</span><br><span class="line">   IMREAD_COLOR                = 1,  //返回一个BGR通道的图像</span><br><span class="line">   IMREAD_ANYDEPTH             = 2,  //当输入具有相应的深度时返回16位/ 32位图像，否则将其转换为8位。.</span><br><span class="line">   IMREAD_ANYCOLOR             = 4,  //则以任何可能的颜色格式读取图像。</span><br><span class="line">   IMREAD_LOAD_GDAL            = 8,  //使用GDAL的驱动加载图像。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_2  = 16, //将图像转换为单通道灰度图像，图像大小减少1/2。</span><br><span class="line">   IMREAD_REDUCED_COLOR_2      = 17, //转换图像的3通道BGR彩色图像和图像的大小减少1/2。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_4  = 32, //将图像转换为单通道灰度图像，图像大小减少1/4。</span><br><span class="line">   IMREAD_REDUCED_COLOR_4      = 33, //转换图像的3通道BGR彩色图像和图像的大小减少1/4。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_8  = 64, //将图像转换为单通道灰度图像，图像大小减少1/8。</span><br><span class="line">   IMREAD_REDUCED_COLOR_8      = 65, //转换图像的3通道BGR色彩图像和图像大小减少1/8。</span><br><span class="line">   IMREAD_IGNORE_ORIENTATION   = 128 //不旋转图像根据EXIF的定位标志。</span><br></pre></td></tr></table></figure><p><strong>图像的显示：imshow</strong></p><p>imshow主要用于显示图像，将加载到内存中的图像显示出来</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void imshow(const string&amp; winname,InputArray mat);</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>第一个参数: const string&amp;类型的winname,将要显示的窗口标识名称</li><li>第二个参数:InputArray类型的mat，需要显示的图像</li></ul><p><strong>图像的保存：imwrite</strong></p><p>虽然在例子中没有使用imwrite但是有必要说明一下imwrite这个函数的使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool imwrite(const string&amp; filename,InputArray img,</span><br><span class="line">                             const vector&lt;int&gt;&amp; params=vector&lt;int&gt;());</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>第一个参数：const string&amp;类型的filename，要保存的文件名，要带上后缀例如”123.jpg”.</li><li>第二个参数：InputArray类型的img，一般填入一个Mat类型的图像数据</li><li>第三个参数：const std::vector&amp; params表示为特定格式保存的参数编码，它有一个默认值std::vector&lt; int &gt;()，所以一般情况下不用写。如果要填写，则有以下几个方面需要了解：</li></ul><ol><li>对于JPEG格式的图片，这个参数表示从0-100的图片质量（CV_IMWRITE_JPEG_QUALITY）,默认值是95.</li><li>对于PNG格式的图片，这个参数表示压缩级别（CV_IMWRITE_PNG_COMPRESSION）从0-9.较高的值意味着更小的尺寸和更长的压缩时间而默认值是3.</li><li>对于PPM，PGM或PBM格式的图片，这个参数表示一个二进制格式标志（CV_IMWRITE_PXM_BINARY），取值为0或1，而默认值为1.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一话我们已经把opencv的环境配置完成，那么我们接下来分析一下上一话的例子。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>色彩空间转换</title>
    <link href="http://example.com/jsblog/ba11d693.html"/>
    <id>http://example.com/jsblog/ba11d693.html</id>
    <published>2020-09-12T02:31:05.000Z</published>
    <updated>2020-09-12T02:58:13.148Z</updated>
    
    <content type="html"><![CDATA[<p>首先来了解一下opencv提供的API</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvtColor(InputArray src,OutputArray dst,int code,int dstCn=0);</span><br></pre></td></tr></table></figure><p><strong>paraemters:</strong></p><ul><li>第一个参数：InputArray类型的src,表示输入的图像矩阵</li><li>第二个参数：OutputArray类型的dst,表示输出的图像矩阵</li><li>第三个参数：int类型的code,表示颜色转换标识符</li><li>第四个参数目标图像的通道数，该参数为0时，目标图像根据源图像的通道数和具体操作自动决定</li></ul><p><strong>Note:</strong></p><p>第三个参数要根据图像的载入类型进行选择。</p><p>在BGR图像与XYZ图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2XYZ </span><br><span class="line">COLOR_RGB2XYZ </span><br><span class="line">COLOR_XYZ2BGR </span><br><span class="line">COLOR_XYZ2RGB</span><br></pre></td></tr></table></figure><h2 id="YCrCb颜色空间"><a href="#YCrCb颜色空间" class="headerlink" title="YCrCb颜色空间"></a><strong>YCrCb颜色空间</strong></h2><p>该颜色空间广泛的用于视频压缩和图像压缩方案，不能算是纯粹的颜色空间，因为它是BGR颜色空间的一种解码方式。 <strong>该颜色空间广泛的应用于MPEG和JPEG等视频和图像压缩方案。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y表示亮度 </span><br><span class="line">Cr : RGB空间R通道和Y差值 </span><br><span class="line">Cb: RGB空间B通道和Y差值</span><br></pre></td></tr></table></figure><p>在BGR图像与YCrCb图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2YCrCb</span><br><span class="line">COLOR_RGB2YCrCb </span><br><span class="line">COLOR_YCrCb2BGR </span><br><span class="line">COLOR_YCrCb2RGB</span><br></pre></td></tr></table></figure><h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>HSV颜色空间属于面向色度的颜色坐标系的一种，这种颜色模型<strong>接近于人类颜色感知的仿真模型</strong>，而在其他颜色模型中，例如RGB，一副图像被视为3中基色的叠加。</p><p>在BGR图像与YCrCb图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2HSV</span><br><span class="line">COLOR_RGB2HSV </span><br><span class="line">COLOR_HSV2BGR </span><br><span class="line">COLOR_HSV2RGB</span><br></pre></td></tr></table></figure><p><strong>GARY色彩空间</strong></p><p>gray图像色彩空间就是灰度图像。</p><p>在BGR图像与gray图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2GRAY</span><br><span class="line">COLOR_RGB2GRAY</span><br><span class="line">COLOR_GRAY2RGB </span><br><span class="line">COLOR_GRAY2BGR</span><br></pre></td></tr></table></figure><p><strong>HLS色彩空间</strong></p><p>HLS颜色空间，三个分量分别是色相（H）、亮度（L）、饱和度（S），这三个取值范围是</p><ul><li>0 &lt;= H &lt;= 360</li><li>0 &lt;= L &lt;= 1</li><li>0 &lt;= S &lt;= 1</li></ul><p>BGR与HLS图像之间的转换code如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2HLS</span><br><span class="line">COLOR_RGB2HLS</span><br><span class="line">COLOR_HLS2RGB </span><br><span class="line">COLOR_HLS2BGR</span><br></pre></td></tr></table></figure><p>YUV颜色模型中，U、V表示的是色度(Chrominance/Chroma)。YUV是欧洲电视系统所采用的颜色模型(属于PAL制式)，颜色被分为一个亮度信号和两个色差信号进行传输</p><p>BGR与YUV图像之间的转换code如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2YUV</span><br><span class="line">COLOR_RGB2YUV</span><br><span class="line">COLOR_YUV2RGB </span><br><span class="line">COLOR_YUV2BGR</span><br></pre></td></tr></table></figure><p>我们来看一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat srcImage = imread(&quot;E:\\vs2015\\imgs\\66.jpg&quot;);</span><br><span class="line">Mat hsvImage, YcrcbImage, HlsImage,grayImage,xyzImage,YuvImage;</span><br><span class="line">cvtColor(srcImage, xyzImage, COLOR_BGR2XYZ); //转换到XYZ</span><br><span class="line">cvtColor(srcImage,grayImage,COLOR_BGR2GRAY); //转换到灰度图像</span><br><span class="line">cvtColor(srcImage, HlsImage, COLOR_BGR2HLS); //转换到HLS色彩空间</span><br><span class="line">cvtColor(srcImage, YcrcbImage, COLOR_BGR2YCrCb); //转换到YCrCb色彩空间</span><br><span class="line">cvtColor(srcImage, hsvImage, COLOR_BGR2HSV);  //转换到HSV色彩空间</span><br><span class="line">cvtColor(srcImage, YuvImage, COLOR_BGR2YUV);</span><br><span class="line">//将图片显示出来</span><br><span class="line">imshow(&quot;input&quot;, srcImage);</span><br><span class="line">imshow(&quot;YUV&quot;,YuvImage);</span><br><span class="line">imshow(&quot;gray&quot;,grayImage);</span><br><span class="line">imshow(&quot;hsv&quot;, hsvImage);</span><br><span class="line">imshow(&quot;Ycrcb&quot;, YcrcbImage);</span><br><span class="line">imshow(&quot;hls&quot;, HlsImage);</span><br><span class="line">imshow(&quot;XYZ&quot;, xyzImage);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9a7249d28bc077c0f9e319c111729e01_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-b24f95bb1d9b3d17d25f0352c66311f7_720w.jpg" alt="img"></p><p><img src="https://picb.zhimg.com/80/v2-d05ce28660f6234fdf23c84585eb4711_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e309901516618e0d6bf2cd26bfea5bec_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ff58ae8c80971db00acccff137000700_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-242710cf960ac30737476cb06757c228_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-79e39bf12d1fe6a3616c21ad80a5c0ba_720w.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先来了解一下opencv提供的API&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV for MinGW</title>
    <link href="http://example.com/jsblog/9a6917e7.html"/>
    <id>http://example.com/jsblog/9a6917e7.html</id>
    <published>2020-09-12T02:29:24.000Z</published>
    <updated>2020-09-12T02:30:29.546Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个opencv的入门的小白来说，要学会如何如何去编译opencv。</p><p>当然在windows使用mingw-w64编译opencv会遇到一些坑。 </p><a id="more"></a><p>不过我们所遇到的坑，必定有前辈遇到过这种相同的问题，所以今天我就来说一下</p><p>如何使用开源的mingw-w64来编译opencv</p><p><strong>编译环境</strong></p><p>mingw版本：mingw-w64 5.4.0 (64 bit)</p><p>CMAKE ： cmake 3.11.4 (64 bit)</p><p>opencv : 3.4.4</p><p>(我也编译过4.0.0虽然也成功了，不过由于其使用的时候必须使用c++11来开发，所以我就放弃了，改用了3.4.4)</p><p><strong>编译过程：</strong></p><p>Step 1:</p><p>配置相应的编译环境，从<a href="https://link.zhihu.com/?target=https://sourceforge.net/projects/mingw-w64/">MinGW-w64 - for 32 and 64 bit Windows</a> 这个网站你可以下载适合你自己的mingw-w64的版本。下载好之后为mingw-w64配置环境变量。我将下载好的mingw x86_64-5.4.0-release-posix-sjlj-rt-v5-rev0.7z</p><p><img src="https://pic4.zhimg.com/80/v2-a83da9dbd0b147549f97e99be4251642_720w.jpg" alt="img"></p><p>也就是第一个，解压到了d盘下MinGW目录下，所以我在我的电脑上的配置环境为</p><p><img src="https://pic1.zhimg.com/80/v2-c2bde3ac4c42399a2631899e8c07de92_720w.jpg" alt="img"></p><p>环境变量为D:\MinGW\mingw\bin</p><p><img src="https://pic1.zhimg.com/80/v2-cb180653db250bb90902a6a087b06f59_720w.jpg" alt="img"></p><p>如果配置好了，可以验证一下，如果在dos下输入gcc -v出现</p><p><img src="https://picb.zhimg.com/80/v2-72e4295970adcf8fc1488ddbae307d7c_720w.jpg" alt="img"></p><p>则说明配置完成</p><p><strong>Step2.</strong></p><p>配置好gcc开发环境之后，你也可以使用gcc开发c程序或者c++程序。我们的目的是为了编译opencv这个计算机视觉库。所以第二步，配置cmake，你可以直接从 <a href="https://link.zhihu.com/?target=https://cmake.org/download/">https://cmake.org/download/</a> 这个网址直接下载相应的cmake工具，然后安装。安装的时候将cmake添加进环境变量。</p><p>Step3</p><p>将下载好的opencv3.4.4和opencv_contrib3.4.4解压。为了方便我将它们放在了同一个文件夹下，然后启动cmake-gui</p><p><img src="https://pic4.zhimg.com/80/v2-ec0f1bd0bd9e1e5b78933befa7b26fe6_720w.jpg" alt="img"></p><p>我将opencv放在了F盘，为了方便寻找我就在F盘新建了一个文件夹，source code 选择opencv-3.4.4,输出路径为F:/opencv/build</p><p>然后点击 configure</p><p><img src="https://pic3.zhimg.com/80/v2-87f2081ce6f5ef0a89126a6e7703ae19_720w.jpg" alt="img"></p><p>点击yes</p><p><img src="https://pic2.zhimg.com/80/v2-05aec86d816229393a75cf77e26f2991_720w.jpg" alt="img"></p><p>选择mingw makefiles。点击finnish,中间要下载一些东西，所以要保证有网络，有可能需要翻墙才能configure完成。</p><p><img src="https://pic4.zhimg.com/80/v2-9a0ea65e001cc6dd8c59805f634cd049_720w.jpg" alt="img"></p><p>其中 不勾选</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENABLE_PRECOMPILED_HEADERS</span><br><span class="line">WITH_MSMF</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-28c5958f47d4f42dc979c58e6c245a4a_720w.png" alt="img"></p><p>这一栏是配置opencv_contrib的modules。</p><p>勾选</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENABLE_CXX11</span><br></pre></td></tr></table></figure><p>除了配置以上的之外还要修改一些源代码</p><p>在opencv-3.4.4中的</p><p>modules/videoio/src/cap_dshow.cpp中的</p><p><img src="https://picb.zhimg.com/80/v2-8801099898f2836d6b803fcd0a2fdf6a_720w.png" alt="img"></p><p>include “cap_dshow.hpp”上一行添加</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NO_DSHOW_STRSAFE</span><br></pre></td></tr></table></figure><p>即：</p><p><img src="https://pic3.zhimg.com/80/v2-6ded081864bb8b58def07079b1081364_720w.jpg" alt="img"></p><p>然后configure ，完成之后，执行generate</p><p>generate完成之后就可以进行第四步。</p><p><strong>Step4</strong></p><p>在build目录下打开Dos窗口</p><p>输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make</span><br></pre></td></tr></table></figure><p>如果想加速编译可以在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make -j 4</span><br></pre></td></tr></table></figure><p><img src="https://picb.zhimg.com/80/v2-91ecbae494ea3225d4ea6b704ee2df54_720w.jpg" alt="img"></p><p>等到编译完成100%（根据自己的电脑性能选择线程）我选择12是为了加速编译</p><p>你可以在编译的时候看会书，估计要1个小时</p><p><img src="https://pic3.zhimg.com/80/v2-645c94ab02e32b51eb0c91bd1dfe0495_720w.jpg" alt="img"></p><p>就可以使用</p><p><img src="https://pic2.zhimg.com/80/v2-92d2c18a2abbb6ecf993f234f3045fac_720w.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make install</span><br></pre></td></tr></table></figure><p>直到安装完成</p><p><img src="https://picb.zhimg.com/80/v2-ab0adbf3c5c92d62505d296281567b05_720w.jpg" alt="img"></p><p>这样opencv库就编译完成，你可以在build文件夹中找到install这个文件夹，</p><p>我将install文件夹移动到了D盘下的MinGW文件下，然后配置相应的环境变量，以便于cmake工具能够找到opencv这个库（我个人的配置）</p><p>新建一个变量</p><p><img src="https://pic1.zhimg.com/80/v2-9f083be6602529b827ab4b6d5bfdcc35_720w.jpg" alt="img"></p><p>点击确定，然后编辑PATH变量</p><p><img src="https://pic3.zhimg.com/80/v2-24b781b3fdb990747c9c4d87551db7b0_720w.jpg" alt="img"></p><p>添加一项，因为我的是64位所以就是x64，如果是32位则其中x64换成x86</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%OpenCV_DIR%\x64\mingw\bin</span><br></pre></td></tr></table></figure><p>就可以使用cmake，和mingw来开发opencv应用程序了</p><p>在编译的时候可能会遇到其他vs_version.rc.obj无法生成的问题</p><p>根据自己的编译目录手动生成 vs_version.rc.obj</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windres E:\opencv\build\modules\core\vs_version.rc -O coff E:\opencv\build\modules\core\CMa</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个opencv的入门的小白来说，要学会如何如何去编译opencv。&lt;/p&gt;
&lt;p&gt;当然在windows使用mingw-w64编译opencv会遇到一些坑。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Thread 入门</title>
    <link href="http://example.com/jsblog/ac99a763.html"/>
    <id>http://example.com/jsblog/ac99a763.html</id>
    <published>2020-09-07T12:52:36.000Z</published>
    <updated>2020-09-07T12:54:32.005Z</updated>
    
    <content type="html"><![CDATA[<p>在c++11之前c++没有提供对并发编程提供语言级别的支持，而在c++11在增加了线程以及线程相关的类，很方便的支持并发编程，提高了代码的可移植性。</p><a id="more"></a><p>创建线程：使用std::thread类可以创建新的线程，可以使用std::this_thread::get_id() 查看当前线程的id.。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ <span class="keyword">this</span> thread id is ” &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">      t.join();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用join函数会阻塞主线程，直到线程函数执行结束，如果func有返回值，则返回值被忽略。而如果不想阻塞主线程，可以使用detach函数，但是detach之后，线程函数就被分离，无法与线程函数发生联系，也不知道线程函数会何时执行完。</p><p>当然，可以构造传入参数的线程如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ str = ” &lt;&lt; str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func,”test”)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不能复制，但是可以被转移，利用移动语义（std::move）将一个线程的资源转给另外一个线程。也可以使用std::bind以及lambda函数表达式构造新的线程。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ str = ” &lt;&lt; str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">([](<span class="built_in">std</span>::<span class="built_in">string</span> str)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>&#125;,”test”)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::bind(func,”test”))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::thread t2;</span><br><span class="line">    t2 = <span class="built_in">std</span>::move(t1); <span class="comment">//ok</span></span><br><span class="line">    t.join();</span><br><span class="line">    t1.join(); <span class="comment">// system_error</span></span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在c++11之前c++没有提供对并发编程提供语言级别的支持，而在c++11在增加了线程以及线程相关的类，很方便的支持并发编程，提高了代码的可移植性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>FileStorage</title>
    <link href="http://example.com/jsblog/5c7f6c43.html"/>
    <id>http://example.com/jsblog/5c7f6c43.html</id>
    <published>2020-09-07T12:18:24.000Z</published>
    <updated>2020-09-07T12:54:43.230Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV中可以使用FileStorage 对xml，yml等文本文件的读写。可扩展<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">标记语言</a>，<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>的子集，简称XML。是一种用于标记电子文件使其具有结构性的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436">标记语言</a>。YAML是一个可读性高，用来表达数据<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的格式。</p><a id="more"></a><p>首先看一下fileStorage的构造函数和析构函数：</p><p><strong>构造函数：</strong></p><p>FileStorage::FileStorage(const String&amp; filename,int flags,const String&amp; encoding= String());</p><p>filename: 文件名称</p><p>flags：文件的打开模式，主要有以下几种：</p><p>READ: 以读的形式打开</p><p>WRITE:以写的形式打开</p><p>APPEND:以追加的形式打开</p><p>MEMORY: 从source 中读取数据或者写入数据到缓存中（通过FileStorage::release返回）</p><p>FORMAT_MASK: 格式化数据的掩码</p><p>FORMAT_AUTO : 自动格式化数据</p><p>FORMAT_XML： 将文件按照xml方式读写</p><p>FORMAT_YAML: 将文件按照yaml方式读写</p><p>FORMAT_JSON 将文件按照JSON方式读写</p><p>enconding: 文件的编码格式</p><p><strong>析构函数：</strong></p><p>FileStorage::~FileStorage()</p><p><strong>几个重要的函数：</strong></p><p>FileStorage::release() ： 关闭文件</p><p>FileStorage::isOpened() ：判断文件是否打开</p><p>FileStorage::Open(const String&amp; filename,int flags,const String&amp; encoding= String()) 与构造函数一样，将文件按照指定的格式以及编码打开。</p><p>operator&gt;&gt; ： 重载运算符，将节点数据读入到某个变量中</p><p>operator&lt;&lt; : 将数据保存到某个节点中</p><p>operator[] : 取出某个节点的数据</p><p>以yaml文件为例</p><p>读写数据代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/opencv.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;test.yml&quot;</span>,FileStorage::WRITE)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> fps = <span class="number">5</span>;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;fps&quot;</span> &lt;&lt; fps;</span><br><span class="line">    Mat m = Mat::eye(<span class="number">2</span>,<span class="number">3</span>,CV_32F);</span><br><span class="line">    Mat m1 = Mat::eye(<span class="number">3</span>,<span class="number">2</span>,CV_32F);</span><br><span class="line">    Mat result = (m+<span class="number">1</span>).mul(m+<span class="number">3</span>);</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; result;</span><br><span class="line">    fs.release();</span><br><span class="line">    <span class="comment">//读出数据</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs2</span><span class="params">(<span class="string">&quot;test.yml&quot;</span>,FileStorage::READ)</span></span>;</span><br><span class="line">    Mat r;</span><br><span class="line">    fs2[<span class="string">&quot;result&quot;</span>] &gt;&gt; r;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r  &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fs2.release();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存在test.yml的数据如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML:1.0</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">fps:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">result:</span> <span class="type">!!opencv</span><span class="string">-matrix</span></span><br><span class="line">   <span class="attr">rows:</span> <span class="number">2</span></span><br><span class="line">   <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">   <span class="attr">dt:</span> <span class="string">f</span></span><br><span class="line">   <span class="attr">data:</span> [ <span class="number">8</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">8</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span> ]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenCV中可以使用FileStorage 对xml，yml等文本文件的读写。可扩展&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&quot;&gt;标记语言&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073&quot;&gt;标准通用标记语言&lt;/a&gt;的子集，简称XML。是一种用于标记电子文件使其具有结构性的&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436&quot;&gt;标记语言&lt;/a&gt;。YAML是一个可读性高，用来表达数据&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BA%8F%E5%88%97%E5%8C%96&quot;&gt;序列化&lt;/a&gt;的格式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>TCP 连接与断开</title>
    <link href="http://example.com/jsblog/6f96be2d.html"/>
    <id>http://example.com/jsblog/6f96be2d.html</id>
    <published>2020-09-05T23:01:33.000Z</published>
    <updated>2020-09-05T23:20:40.538Z</updated>
    
    <content type="html"><![CDATA[<p> 本文主要是介绍TCP协议的连接与断开的过程以及自己对于这些过程的理解。</p><a id="more"></a><p><img src="https://pic1.zhimg.com/80/v2-043ba89d07d63a8868f876a39b944205_720w.jpg" alt="img"></p><p>(1) 客户端：发送SYN报文请求连接 ，置发送序号为X</p><p>(2) 服务端：接收到客户端的请求连接报文，发送SYN-ACK报文给客户端，其中确认序号为X+1,发送序号为Y</p><p>(3) 客户端：发送acK报文，并置发送序号为X+1，并置确认序号为Y+1</p><p>此时连接建立起来，客户端和服务器端可以发送数据。</p><p>四次握手断开连接</p><p><img src="https://pic1.zhimg.com/80/v2-69a7e128d54c5d91eba89fda1d9ad296_720w.jpg" alt="img"></p><p>（1） 客户端(主动)：发送请求FIN报文，发送序号为u</p><p>（2） 服务端（被动）：发送ACK报文，序号为v,确认号为u+1;确认客户端断开，服务器不再接受该客户端发来的数据。这时候成为半关闭状态。</p><p>（3） 服务端：等待Close-wait时间后，服务端做好了关闭的准备，向客户端发送一个关闭连接的FIN-ACK报文，确认号为u+1,序号为w</p><p>（4） 客户端：发送ACK报文，确认号为w+1,序号为u+1，确认关闭连接.</p><p>客户端最后等待2MSL是因为报文的生存时间为MSL，如果服务器端没有收到客户端发来的确认报文，那么服务端会重新发送一次FIN报文请求断开。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</p><p><strong>PS: 图片来源于百度图片，侵删！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 本文主要是介绍TCP协议的连接与断开的过程以及自己对于这些过程的理解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>像素操作</title>
    <link href="http://example.com/jsblog/561fe8cb.html"/>
    <id>http://example.com/jsblog/561fe8cb.html</id>
    <published>2020-09-05T22:38:19.000Z</published>
    <updated>2020-09-05T23:19:07.812Z</updated>
    
    <content type="html"><![CDATA[<p>我们首先了解一下什么是像素，计算机中是如何存储图像，以及opencv是如何表示图像的。</p><p><strong>像素</strong>：</p><p>像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。可以将像素视为整个图像中不可分割的单位或者是元素，不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小</p><a id="more"></a><p><strong>计算机存储图像：</strong></p><p>图像文件存储的都是每一个像素对应的颜色值。</p><p>1、<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d-ryfLmhcLmyPWuHIBnAu90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1bdP1cvnH0d">位图文件</a>有两种存储像素数据的格式。16777216色（真彩色）的图像，一个像素的颜色可以用24位数据表示。256色的图像可以用调色板对颜色的信息进行编码，一个像素的值对应的是调色板的索引，而不是直接对应一个像素的颜色，调色板的索引映射为像素的颜色。</p><p>2、以一百万个像素，256种颜色的BMP文件在电脑上的存储为例。这个文件包括一个十四字节的文件首部，一个四十字节的信息首部，一个1024字节的颜色表，一兆字节的位图数据。文件首部的前两个字节由字符BM组成，还包括了文件长度和位图数据在文件中的起始位置。</p><p>3、文件的信息首部包含了图像的高、宽、颜色数等非图形数据。</p><p>这个图像共有一百万个像素，一个像素需要八位的颜色信息，文件的这一部分的长度是一百万个字节，字节排放的顺序是自左到右从图像的最下面那行开始，这个文件的总大小是1001078字节。</p><p><strong>opencv表示图像：</strong></p><p>opencv中很多<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/datastructure">数据结构</a>为了达到內存使用的最优化，通常都会用它最小上限的空间来分配变量，有的数据结构也会因为图像文件格式的关系而给予适当的变量，因此需要知道它们声明的空间大小来配置适当的变量。一</p><p>般标准的图片，为RGB格式它们的大小为8bits格式，范围为0~255,对一个int空间的类型来说实在是太小，整整浪费了24bits的空间,假设有个640<em>480的BMP文件空间存储內存,那整整浪费了640</em>480<em>3</em>(32-8)bits的內存空间,总共浪费了2.6MB!，也就是那<br>2.6MB内什么东西都没存储，如果今天以8bits的格式来存储则只使用到0.6MB的內存而已(640<em>480</em>3*(8)+54<br>bits)，因此，对于文件格式的对应是一件很重要的事.。</p><p>访问像素的三种方法：</p><ol><li>指针访问</li><li>迭代器iterator</li><li>动态地址计算</li></ol><p>首先我们来看一段代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">//指针操作访问像素</span><br><span class="line">void colorReduce(Mat&amp; img,int div=64)</span><br><span class="line">&#123;</span><br><span class="line">    int nl = img.rows;</span><br><span class="line">    int nc = img.cols*img.channels();</span><br><span class="line">    for(int i = 0;i &lt; nl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* data = img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for(int j = 0 ; j &lt; nc;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j]/div*div + div/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//迭代器模式</span><br><span class="line">void ColorReduce(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator it = img.begin&lt;Vec3b&gt;();</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator itend = img.end&lt;Vec3b&gt;();</span><br><span class="line">for (; it != itend; it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)[0] = (*it)[0] / div * div + div / 2;</span><br><span class="line">(*it)[1] = (*it)[1] / div * div + div / 2;</span><br><span class="line">(*it)[2] = (*it)[2] / div * div + div / 2;</span><br><span class="line">&#125;</span><br><span class="line">namedWindow(&quot;dst&quot;);</span><br><span class="line">imshow(&quot;dst&quot;, img);</span><br><span class="line">&#125;</span><br><span class="line">//动态地址计算</span><br><span class="line">void colorReduce2(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">    int cols = img.cols;</span><br><span class="line">    int rows = img.rows;</span><br><span class="line">    for(int i= 0;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[0] = img.at&lt;Vec3b&gt;(i,j)[0] / div * div +div /2;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[1] = img.at&lt;Vec3b&gt;(i,j)[1] / div * div +div /2;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[2] = img.at&lt;Vec3b&gt;(i,j)[2] / div * div +div /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    Mat image = imread(argv[1]);</span><br><span class="line">    imshow(&quot;input&quot;,image);</span><br><span class="line">    colorReduce2(image,64);</span><br><span class="line">    imshow(&quot;dst&quot;,image);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    destroyAllWindows();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针操作：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//指针操作访问像素</span><br><span class="line">void colorReduce(Mat&amp; img,int div=64)</span><br><span class="line">&#123;</span><br><span class="line">    int nl = img.rows;　// 行数</span><br><span class="line">    int nc = img.cols*img.channels();//列数ｘ通道数　＝　每一行像素的个数</span><br><span class="line">    for(int i = 0;i &lt; nl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">　　　　　//Mat类提供了ｐｔｒ函数可以得到任意行的首地址，ｐｔｒ是一个模板函数</span><br><span class="line">        uchar* data = img.ptr&lt;uchar&gt;(i);　//获取第ｉ行的首地址</span><br><span class="line">        for(int j = 0 ; j &lt; nc;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j]/div*div + div/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器操作：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//迭代器模式</span><br><span class="line">void ColorReduce(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator it = img.begin&lt;Vec3b&gt;();</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator itend = img.end&lt;Vec3b&gt;();</span><br><span class="line">for (; it != itend; it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)[0] = (*it)[0] / div * div + div / 2;</span><br><span class="line">(*it)[1] = (*it)[1] / div * div + div / 2;</span><br><span class="line">(*it)[2] = (*it)[2] / div * div + div / 2;</span><br><span class="line">&#125;</span><br><span class="line">namedWindow(&quot;dst&quot;);</span><br><span class="line">imshow(&quot;dst&quot;, img);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不熟悉迭代器模式，可以阅读与ＳＴＬ中迭代器相关的资料。</p><p><strong>动态地址计算：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//动态地址计算</span><br><span class="line">void colorReduce2(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">    int cols = img.cols;　//列数</span><br><span class="line">    int rows = img.rows;　//行数</span><br><span class="line">    for(int i= 0;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j &lt; cols;j++)</span><br><span class="line">        &#123;　　//处理Ｂ蓝色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[0] = img.at&lt;Vec3b&gt;(i,j)[0] / div * div +div /2;</span><br><span class="line">　　　　　　　//处理Ｇ绿色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[1] = img.at&lt;Vec3b&gt;(i,j)[1] / div * div +div /2;</span><br><span class="line">　　　　　　　//处理Ｒ红色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[2] = img.at&lt;Vec3b&gt;(i,j)[2] / div * div +div /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于彩色图像，每个像素由三个部分：蓝色通道，绿色通道，红色通道（ＢＧＲ）。因此对于一个包含彩色图像的Ｍａｔ，会返回一个８位数组组成的向量。ＯｐｅｎＣＶ将此向量定义为Vec3b，即由usigned char 组成的向量。其访问像素通用表达式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.at&lt;Vec3b&gt;(row,col)[channel] = value;</span><br></pre></td></tr></table></figure><p>其中索引值表示通道。</p><p>这就是访问像素的三种方法，我们看一下效果：</p><p><img src="https://pic3.zhimg.com/80/v2-e27989af32f67f200762d904263dec3a_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们首先了解一下什么是像素，计算机中是如何存储图像，以及opencv是如何表示图像的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;像素&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。可以将像素视为整个图像中不可分割的单位或者是元素，不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像腐蚀</title>
    <link href="http://example.com/jsblog/7525f478.html"/>
    <id>http://example.com/jsblog/7525f478.html</id>
    <published>2020-09-05T12:59:10.000Z</published>
    <updated>2020-09-05T23:18:32.233Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来了解一下什么是腐蚀，为什么要进行图像的腐蚀。</p><p>在了解腐蚀之前我们先来了解一下结构元素</p><p>结构元素的定义如下：</p><p><strong>设有两幅图象B，X。若X是被处理的对象，而B是用来处理X的，则称B为结构元素(structure element)，又被形象地称做刷子。结构元素通常都是一些比较小的图象。</strong></p><p>接下来我们看一下腐蚀的定义：</p><p><strong>在图像的形态学操作中腐蚀就是删除对象边界的某些点的像素</strong></p><a id="more"></a><p>腐蚀的作用：</p><ul><li>边缘检测</li><li>噪声过滤</li><li>形态骨架提取</li></ul><p>其 数学表达式为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst(x,y) = min src( x + x`,y+y`) 其中 （x`,y`）: element(x`,y`) != 0</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>对Z中的集合A和B，B对A进行腐蚀的整个过程如下：</p><p>⑴ 用结构元素B，扫描图像A的每一个像素</p><p>⑵ 用结构元素与其覆盖的二值图像做“与”操作</p><p>⑶ 如果都为1，结果图像的该像素为1。否则为0</p><p>腐蚀处理的结果是使原来的二值图像减小一圈</p><p><strong>代码：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat srcImage = cv::imread(&quot;32.jpg&quot;);//read the file</span><br><span class="line">if (srcImage.empty())</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; &quot;the file does not exits!&quot; &lt;&lt; std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">//get the structure element</span><br><span class="line">cv::Mat StructElement = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));</span><br><span class="line">//defination the result</span><br><span class="line">cv::Mat result;</span><br><span class="line">//erode the image</span><br><span class="line">cv::erode(srcImage, result, StructElement);</span><br><span class="line">//show the image</span><br><span class="line">cv::namedWindow(&quot;input&quot;,cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::namedWindow(&quot;output&quot;,cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::imshow(&quot;input&quot;,srcImage);</span><br><span class="line">cv::imshow(&quot;output&quot;,result);</span><br><span class="line">cv::waitKey(0);</span><br><span class="line">cv::destroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-530ca54b72ac02361e5075f4115f75df_720w.jpg" alt="img"></p><p>​                                                                            input</p><p><img src="https://pic3.zhimg.com/80/v2-4c349f4595afb42a203213fab02c2e54_720w.jpg" alt="img"></p><p>​                                                                        output</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先我们来了解一下什么是腐蚀，为什么要进行图像的腐蚀。&lt;/p&gt;
&lt;p&gt;在了解腐蚀之前我们先来了解一下结构元素&lt;/p&gt;
&lt;p&gt;结构元素的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设有两幅图象B，X。若X是被处理的对象，而B是用来处理X的，则称B为结构元素(structure element)，又被形象地称做刷子。结构元素通常都是一些比较小的图象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看一下腐蚀的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在图像的形态学操作中腐蚀就是删除对象边界的某些点的像素&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
