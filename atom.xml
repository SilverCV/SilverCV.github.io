<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-13T06:41:27.785Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>reduction</title>
    <link href="http://example.com/jsblog/b1e75468.html"/>
    <id>http://example.com/jsblog/b1e75468.html</id>
    <published>2020-09-13T06:38:43.000Z</published>
    <updated>2020-09-13T06:41:27.785Z</updated>
    
    <content type="html"><![CDATA[<p>图像缩放是指图像的尺寸变小或者变大的过程。<a id="more"></a></p><p>图像缩放实际上就是增加或者减少原图像数据的像素的个数。图像缩放可能会造成信息的丢失。需要选择合适的缩放方法进行操作。图像的缩放过程涉及到采样和插值。</p><p>一般有以下两种方法：</p><ol><li>基于等间隔提取图像像素的缩放</li></ol><p>基于等间隔提取图像像素的缩放是对原始图像进行均匀采样来完成的。对于原始图像像素数据<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img">,其图像大小为**<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img">,<strong>如果想要将这幅图像的大小改变为</strong><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img">**。使用等间隔采样，宽度缩放系数为：<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img">,高度缩放系数为：<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img">。对于图像，图像缩放在其水平方向的等间隔采样为<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="img">，在垂直方向上的等间隔采样为<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img">。若<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png" alt="img">就表示原图像要等比例缩放，否则原图像则会发生扭曲现象。缩放的矩阵表示如下：</p><p><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png" alt="img"></p><p>\2.  基于区域子块提取图像缩放</p><p>提取区域子块图像缩放是通过对原图像进行区域子块划分，然后提取子块中像素值作为采样像素用来作为目标图像的像素。提取子块的像素的方法通常是提取块像素中得中值或者计算块像素的平均值。对于子块的划分其实就是对于矩阵的划分，划分子块的方法有很多种，常用的方法就是根据缩放系数提取和自适应因子提取子块。例如对于src(x,y)为 4x4的矩阵，如果目标矩阵为2x2，那么可以按照矩阵的子块划分，然后求每个分块矩阵的均值或者矩阵中得中值作为目标矩阵的一个元素。原始矩阵如下：</p><p><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png" alt="img"></p><p>目标矩阵dst(x,y) 为：</p><p><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png" alt="img"></p><p>则A11 应为a11,a12,a21,a22的均值或者中值。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageReduction</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; src_,cv::Mat&amp; dst_,<span class="keyword">float</span> kx,<span class="keyword">float</span> ky)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src_ : the source image</span></span><br><span class="line"><span class="comment">    det_ : the destination  image</span></span><br><span class="line"><span class="comment">    kx   : the Scale factor in horizon</span></span><br><span class="line"><span class="comment">    ky   : the Scale factor in vertical</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> nRows = cvRound(src_.rows * kx);</span><br><span class="line">    <span class="keyword">int</span> nCols = cvRound(src_.cols * ky);</span><br><span class="line">    dst_ = cv::Mat(nRows,nCols,src_.type());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; nCols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((i+<span class="number">1</span>) / kx + <span class="number">0.5</span>) <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((j+<span class="number">1</span>) / ky + <span class="number">0.5</span>) <span class="number">-1</span>;</span><br><span class="line">            dst_.at&lt;cv::Vec3b&gt;(i,j) = src_.at&lt;cv::Vec3b&gt;(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cv::Vec3b <span class="title">AverOfMat</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; srcImage,cv::Point_&lt;<span class="keyword">int</span>&gt; left,cv::Point_&lt;<span class="keyword">int</span>&gt; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    srcImage: the source of Image</span></span><br><span class="line"><span class="comment">    lef      :  the left point of child block of source Image</span></span><br><span class="line"><span class="comment">    right    : the right point of child block of source Image</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//计算像素点的个数</span></span><br><span class="line">    <span class="keyword">int</span> nPixels = (right.x - left.x + <span class="number">1</span>) * (right.y - left.y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> temp0 = <span class="number">0</span>,temp1 = <span class="number">0</span>,temp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left.x;i&lt;= right.x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=left.y;j &lt;= right.y;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp0 += srcImage.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">0</span>];</span><br><span class="line">            temp1 += srcImage.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">1</span>];</span><br><span class="line">            temp2 += srcImage.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个通道求平均值</span></span><br><span class="line">    cv::Vec3b resVec;</span><br><span class="line">    resVec[<span class="number">0</span>] = temp0 / nPixels;</span><br><span class="line">    resVec[<span class="number">1</span>] = temp1 / nPixels;</span><br><span class="line">    resVec[<span class="number">2</span>] = temp2 / nPixels;</span><br><span class="line">    <span class="keyword">return</span> resVec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageReduction1</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; src_,cv::Mat&amp; dst_,<span class="keyword">float</span> kx,<span class="keyword">float</span> ky)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src_ : the source image</span></span><br><span class="line"><span class="comment">    det_ : the destination  image</span></span><br><span class="line"><span class="comment">    kx   : the Scale factor in horizon</span></span><br><span class="line"><span class="comment">    ky   : the Scale factor in vertical</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> nRows = cvRound(src_.rows * kx);</span><br><span class="line">    <span class="keyword">int</span> nCols = cvRound(src_.cols * ky);</span><br><span class="line">    dst_ = cv::Mat(nRows,nCols,src_.type());</span><br><span class="line">    <span class="comment">//图像子区域的左上角</span></span><br><span class="line">    <span class="keyword">int</span> leftRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LeftCol = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nRows;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; ((i + <span class="number">1</span>) / kx + <span class="number">0.5</span>) - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; nCols;++j)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; ((j + <span class="number">1</span>) / ky + <span class="number">0.5</span>) - <span class="number">1</span>;</span><br><span class="line">            dst_.at&lt;cv::Vec3b&gt;(i,j) = AverOfMat(src_,cv::Point_&lt;<span class="keyword">int</span>&gt;(leftRow,LeftCol),cv::Point_&lt;<span class="keyword">int</span>&gt;(x,y));</span><br><span class="line">            LeftCol = y + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       leftRow = x + <span class="number">1</span>;</span><br><span class="line">       LeftCol = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    cv::Mat dstImage2;</span><br><span class="line">    ImageReduction(srcImage,dstImage,<span class="number">0.4</span>,<span class="number">0.4</span>);</span><br><span class="line">    ImageReduction1(srcImage,dstImage2,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;src&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;dst1&quot;</span>,dstImage);</span><br><span class="line">     cv::imshow(<span class="string">&quot;dst2&quot;</span>,dstImage2);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入图像为：</p><p><img src="https://picb.zhimg.com/80/v2-4368c921c5dd35c8c6a46e4a133e6f72_720w.jpg" alt="img"></p><p>输出图像1（等间隔采样）：</p><p><img src="https://picb.zhimg.com/80/v2-d1259b02021a0d5b65aa3688a5aa3fbf_720w.jpg" alt="img"></p><p>输出图像2（基于区域子块采样）：</p><p><img src="https://pic3.zhimg.com/80/v2-502cbe18e90de4c7385e579d059e18ae_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像缩放是指图像的尺寸变小或者变大的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>translation</title>
    <link href="http://example.com/jsblog/b469456f.html"/>
    <id>http://example.com/jsblog/b469456f.html</id>
    <published>2020-09-13T01:09:02.000Z</published>
    <updated>2020-09-13T01:09:40.508Z</updated>
    
    <content type="html"><![CDATA[<p>图像的平移操作是将图像按照水平方向或者垂直方向平移。</p><a id="more"></a><p>图像的平移操作实际上是将所有像素按照x轴或者y轴放向移动。图像的平移变换分为：图像大小不改变的平移变换和图像大小改变的平移变换。图像大小不改变的平移变换可能导致部分图像信息丢失，而图像大小变化则拥有完整的图像信息。</p><p>对于图像的变换，其公式主要是：</p><p><img src="https://pic3.zhimg.com/80/v2-91c8b350a518ae14c2971fccfaed4d16_720w.png" alt="img"></p><p>目标坐标点（x1,y1）由（x,y）通过平移得到。</p><p>对于矩阵形式的变换，其变换矩阵如下：</p><p><img src="https://pic2.zhimg.com/80/v2-582df7b83782cfb8e71a506b6b560569_720w.jpg" alt="img"></p><p>对于目标图像，可以进行逆变换进行反向平移，变换矩阵如下：</p><p><img src="https://picb.zhimg.com/80/v2-fe5b42c12bc138f3a7da0b74e9db9bfd_720w.png" alt="img"></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不改变大小</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">ImageTranslation</span><span class="params">(cv::Mat src_,<span class="keyword">int</span> x_offset,<span class="keyword">int</span> y_offset,<span class="keyword">bool</span> IsResize = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src_       : srcImage</span></span><br><span class="line"><span class="comment">    x_offset  : translate x_offset in x axis</span></span><br><span class="line"><span class="comment">    y_offset  : translate y_offset in y axis</span></span><br><span class="line"><span class="comment">    IsResize  : whether or not to change the image size</span></span><br><span class="line"><span class="comment">    return    : dstImage</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> cols = src_.cols;</span><br><span class="line">    <span class="keyword">int</span> rows = src_.rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否改变原始图像的大小</span></span><br><span class="line">    <span class="keyword">if</span> (IsResize)</span><br><span class="line">    &#123;</span><br><span class="line">        rows = rows + <span class="built_in">std</span>::<span class="built_in">abs</span>(y_offset);</span><br><span class="line">        cols = cols + <span class="built_in">std</span>::<span class="built_in">abs</span>(x_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rows = rows;</span><br><span class="line">        cols = cols;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">dstImage</span><span class="params">(rows,cols,src_.type())</span></span>;</span><br><span class="line">    <span class="comment">//进行平移操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j - x_offset;</span><br><span class="line">            <span class="keyword">int</span> y = i - y_offset;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;=<span class="number">0</span> &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; x &lt; cols &amp;&amp; y &lt; rows) <span class="comment">//对于超出图像边界的不进行处理</span></span><br><span class="line">                dstImage.at&lt;cv::Vec3b&gt;(i,j) = src_.ptr&lt;cv::Vec3b&gt;(y)[x];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dstImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">int</span> x_offset = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> y_offset = <span class="number">10</span>;</span><br><span class="line">    cv::Mat dstImage = ImageTranslation(srcImage,x_offset,y_offset,<span class="literal">false</span>);</span><br><span class="line">    cv::Mat dstImage1 = ImageTranslation(srcImage,x_offset,y_offset,<span class="literal">true</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;input&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;output&quot;</span>,dstImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;output for resize&quot;</span>,dstImage1);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入图像：</p><p><img src="https://pic2.zhimg.com/80/v2-9560b0a0220ffebe7cd4508809cf86b6_720w.jpg" alt="img"></p><p><strong>输出图像</strong></p><p>不改变大小：</p><p><img src="https://pic1.zhimg.com/80/v2-022fb16ef4e72c0206ea8d0140eb73f9_720w.jpg" alt="img"></p><p>改变大小：</p><p><img src="https://picb.zhimg.com/80/v2-dc2cdddbad6ec34dfef4e1f242c845a7_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像的平移操作是将图像按照水平方向或者垂直方向平移。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>remap</title>
    <link href="http://example.com/jsblog/2524302a.html"/>
    <id>http://example.com/jsblog/2524302a.html</id>
    <published>2020-09-12T10:16:49.000Z</published>
    <updated>2020-09-12T11:09:08.593Z</updated>
    
    <content type="html"><![CDATA[<p>图像的坐标变换是通过原图像与目标图像之间建立一种变换关系。</p><a id="more"></a><p>图像的坐标映射也是图像的一种坐标变换。主要是对图像像素的变换。这种变换的关系可以下面公式表示:</p><p>​        dst(x,y) = src(mapx(x,y),mapy(x,y))</p><p>图像的坐标映射也分为正映射和反映射。</p><p>正映射就是从原图像变换到目标图像。</p><p>反映射是将目标图像变换到原始图像。</p><p>在opencv 中实现坐标变换的函数是remap,函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::remap</span><span class="params">(InputArray src,</span></span></span><br><span class="line"><span class="function"><span class="params">              OutputArray dst,</span></span></span><br><span class="line"><span class="function"><span class="params">              InputArray map1,</span></span></span><br><span class="line"><span class="function"><span class="params">              InputArray map2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> interpolation,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> Scalar&amp; borderValue = Scalar())</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><p>src : 原始图像；</p><p>dst : 目标图像，大小和map1的大小相同，数据类型和src的数据类型一样；</p><p>map1:表示（x,y）坐标点或者是x坐标，类型为CV_16SC2,CV_32FC1或者CV_32FC2；</p><p>map2: 表示y坐标，类型是CV_16UC1, CV_32FC1，当map1是（x,y）坐标时，map2可以为空；</p><p>Interpolation:表示插值算法，枚举类型主要。暂不支持INTER_AREA 插值算法。插值算法有一下几种：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INTER_NEAREST</td><td>最近邻插值</td></tr><tr><td>INTER_LINEAR</td><td>双线性插值</td></tr><tr><td>INTER_CUBIC</td><td>双三次插值</td></tr><tr><td>INTER_AREA</td><td>利用像素面积关系重采样。这可能是图像抽取的首选方法，因为它可以得到无云纹的结果。但当图像被放大时，它类似于最近邻法。</td></tr><tr><td>INTER_LANCZOS4</td><td>8x8邻域上的Lanczos插值</td></tr><tr><td>INTER_LINEAR_EXACT</td><td>位精确双线性插值</td></tr><tr><td>INTER_NEAREST_EXACT</td><td>位最近邻插值算法。在PIL,scikit-image和Matlab中效果和最近邻插值算法一样</td></tr><tr><td>INTER_MAX</td><td>插值算法掩码</td></tr><tr><td>WARP_FILL_OUTLIERS</td><td>标志，填充目标图像。如果目标图像的一部分是异常值，那么他们被设置为0</td></tr><tr><td>WARP_INVERSE_MAP</td><td>标志，逆变换</td></tr></tbody></table><p>borderMode: 边界插值类型；</p><p>borderValue: 表示边界插值数据。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">&quot;E:/CodeBlocks/data/butterfly.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt; <span class="string">&quot;fail to load image &quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">xMapArray</span><span class="params">(srcImage.size(),CV_32FC1)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">yMapArray</span><span class="params">(srcImage.size(),CV_32FC1)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">dstImage</span><span class="params">(srcImage.size(),xMapArray.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置变换x,y</span></span><br><span class="line">    <span class="keyword">int</span> rows = srcImage.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = srcImage.cols;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            xMapArray.at&lt;<span class="keyword">float</span>&gt;(i,j) = cols - j;</span><br><span class="line">            yMapArray.at&lt;<span class="keyword">float</span>&gt;(i,j) = rows - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行变换</span></span><br><span class="line">    cv::remap(srcImage,dstImage,xMapArray,yMapArray,cv::INTER_LINEAR,cv::BORDER_CONSTANT,cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;remap&quot;</span>,dstImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic1.zhimg.com/80/v2-31b782e5798a601b90893958eeb517c0_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-11b0b479a7af64c487829c95ee3c625f_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像的坐标变换是通过原图像与目标图像之间建立一种变换关系。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="http://example.com/jsblog/a541262a.html"/>
    <id>http://example.com/jsblog/a541262a.html</id>
    <published>2020-09-12T03:18:15.000Z</published>
    <updated>2020-09-12T04:16:02.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-spring-boot注解"><a href="#1-spring-boot注解" class="headerlink" title="1.spring boot注解"></a>1.spring boot注解</h2><h2 id="1-1-SpringBootApplication"><a href="#1-1-SpringBootApplication" class="headerlink" title="1.1 @SpringBootApplication"></a>1.1 @SpringBootApplication</h2><p>是spring的启动类</p><a id="more"></a><p>此注解等同于@Configuration+@EnableAutoConfiguration + @ComponentScan的组合</p><h2 id="1-2-SpringBootConfiguration"><a href="#1-2-SpringBootConfiguration" class="headerlink" title="1.2 @SpringBootConfiguration"></a><a href="mailto:5.2@SpringBootConfiguration">1.2 @SpringBootConfiguration</a></h2><p>@SpringBootCnfiguration 是@Configuration的派生注解，和@Configuration的功能意义，标注这个类是个配置类，不是@springbootConfiguration是spring boot的注解，而@configuration是spring的注解</p><h2 id="1-3-Configuration"><a href="#1-3-Configuration" class="headerlink" title="1.3 @Configuration"></a>1.3 @Configuration</h2><p>通过对bean对象的操作替代spring中xml文件</p><h2 id="1-4-EnableAutoConfiguration"><a href="#1-4-EnableAutoConfiguration" class="headerlink" title="1.4 @EnableAutoConfiguration"></a>1.4 @EnableAutoConfiguration</h2><p>Spring boot的自动配置，尝试根据你添加的jar依赖自动配置你的spring应用，是@AutoConfigurationPackage和@Import的组合</p><h2 id="1-5-AutoConfigurationPackage"><a href="#1-5-AutoConfigurationPackage" class="headerlink" title="1.5 @AutoConfigurationPackage"></a>1.5 @AutoConfigurationPackage</h2><p>自动注入启动类所在包下所有加了注解的类（@Controller,@Service等）以及配置类（@configuration）</p><h2 id="1-6-import"><a href="#1-6-import" class="headerlink" title="1.6 @import"></a><a href="mailto:5.6@import">1.6 @import</a></h2><p>直接导入普通类</p><p>导入实现的ImportSelector接口的类</p><p>导入实现的ImportBeanDefinitionRegister接口的类</p><h2 id="1-7-ComponentScan"><a href="#1-7-ComponentScan" class="headerlink" title="1.7@ComponentScan"></a><a href="mailto:1.7@ComponentScan">1.7@ComponentScan</a></h2><p>组件扫描，可以自动发现一些bean</p><h2 id="1-8-ConfigurationPropertiesScan"><a href="#1-8-ConfigurationPropertiesScan" class="headerlink" title="1.8 @ConfigurationPropertiesScan"></a>1.8 @ConfigurationPropertiesScan</h2><p>@ConfigurationPropertiesScan扫描配置属性。@EnableConfigurationProperties注解的作用是让使用@ConfigurationProperties的类生效</p><h2 id="Spring-boot常见注解"><a href="#Spring-boot常见注解" class="headerlink" title="Spring boot常见注解"></a>Spring boot常见注解</h2><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>@RestController相当于@Controller + @ResponseBody</p><p>使用@RestController注解Controller中的方法，Controller是无法返回到页面的，相当于在方法前添加了@ResponseBody注解，InternalResourceViewResolver不起作用，就没办法跳转传输数据。若返回数据，则为方法return的内容</p><h2 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h2><p>@GetMapping是@RequestMapping(method=RequestMethod.GET)的缩写</p><h2 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h2><p>@PostMapping是@RequestMapping(method=RequestMethod.POST)的缩写</p><h2 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a>@PutMapping</h2><p>@PutMapping是@RequestMapping(method=RequestMethod.PUT)的缩写</p><h2 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a>@DeleteMapping</h2><p>@DeleteMapping是@RequestMapping(method=RequestMethod.DELETE)的缩写</p><h2 id="Spring-Boot创建项目的三种方式"><a href="#Spring-Boot创建项目的三种方式" class="headerlink" title="Spring Boot创建项目的三种方式"></a>Spring Boot创建项目的三种方式</h2><h2 id="1通过官网创建"><a href="#1通过官网创建" class="headerlink" title="1通过官网创建"></a>1通过官网创建</h2><p><a href="https://link.zhihu.com/?target=https://start.spring.io">https://start.spring.io</a></p><h2 id="2-使用idea中spring-initalizer创建"><a href="#2-使用idea中spring-initalizer创建" class="headerlink" title="2.使用idea中spring initalizer创建"></a>2.使用idea中spring initalizer创建</h2><p>和1类似</p><h2 id="3-创建maven工程，修改pom文件"><a href="#3-创建maven工程，修改pom文件" class="headerlink" title="3.创建maven工程，修改pom文件"></a>3.创建maven工程，修改pom文件</h2><p>修改pom文件</p><h2 id="Spring-Boot结构"><a href="#Spring-Boot结构" class="headerlink" title="Spring Boot结构"></a>Spring Boot结构</h2><h2 id="1-POM文件"><a href="#1-POM文件" class="headerlink" title="1 POM文件"></a>1 POM文件</h2><h2 id="Sping-Boot整合Web技术"><a href="#Sping-Boot整合Web技术" class="headerlink" title="Sping Boot整合Web技术"></a>Sping Boot整合Web技术</h2><h2 id="整合servlet技术"><a href="#整合servlet技术" class="headerlink" title="整合servlet技术"></a>整合servlet技术</h2><h3 id="1-通过注解扫描完成整合servlet"><a href="#1-通过注解扫描完成整合servlet" class="headerlink" title="1 通过注解扫描完成整合servlet"></a>1 通过注解扫描完成整合servlet</h3><p>编写servlet类,在servlet中加入注解@WebServlet(name=””,urlpattern=””)</p><p>在启动弄类中加上注解@ServletComponentScan, @ServletComponentScan在spring boot启动时扫描@WebServlet注解，并将该类实例化</p><h3 id="2通过配置类"><a href="#2通过配置类" class="headerlink" title="2通过配置类"></a>2通过配置类</h3><p>1 编写servlet类，不需使用注解@WebServlet</p><p>创建servlet配置类，使用@Configuration注解，使用@Bean完成servlet的注册,如图</p><p><img src="https://picb.zhimg.com/80/v2-87cd4780b0ba71834909e1dc982d1b9f_720w.jpg" alt="img"></p><h2 id="整合filter"><a href="#整合filter" class="headerlink" title="整合filter"></a>整合filter</h2><h3 id="使用注解方式"><a href="#使用注解方式" class="headerlink" title="使用注解方式"></a>使用注解方式</h3><p>编写filter,使用@webfilter注解（是javax.servlet.*包下的filter）<br>在启动弄类中加上注解@ServletComponentScan, @ServletComponentScan在spring boot启动时扫描@WebServlet注解，并将该类实例化</p><h3 id="使用配置类"><a href="#使用配置类" class="headerlink" title="使用配置类"></a>使用配置类</h3><p>编写servlet类，不需使用注解@WebServlet</p><p>创建filter配置类，使用@Configuration注解，使用@Bean完成Filter的注册</p><p><img src="https://picb.zhimg.com/80/v2-66aa11ab51f73870487d9656d412be11_720w.jpg" alt="img"></p><h2 id="整合Listener"><a href="#整合Listener" class="headerlink" title="整合Listener"></a>整合Listener</h2><h3 id="通过注解扫描的方式"><a href="#通过注解扫描的方式" class="headerlink" title="通过注解扫描的方式"></a>通过注解扫描的方式</h3><p>编写listener,使用@weblistener</p><p>在启动弄类中加上注解@ServletComponentScan, @ServletComponentScan在spring boot启动时扫描@WebServlet注解，并将该类实例化</p><h3 id="通过配置类"><a href="#通过配置类" class="headerlink" title="通过配置类"></a>通过配置类</h3><p>编写servlet类，不需使用注解@WebListener</p><p>创建Listener配置类，使用@Configuration注解，使用@Bean完成ServletListener的注册</p><h2 id="Spring-boot访问静态资源"><a href="#Spring-boot访问静态资源" class="headerlink" title="Spring boot访问静态资源"></a>Spring boot访问静态资源</h2><h2 id="Static-目录"><a href="#Static-目录" class="headerlink" title="Static 目录"></a>Static 目录</h2><p>Spring boot通过static目录静态资源。静态资源存放的目录必须是static</p><h2 id="Templates目录"><a href="#Templates目录" class="headerlink" title="Templates目录"></a>Templates目录</h2><p>在Spring Boot中不推荐使用jsp作为视图层技术，而是默认使用Thymeleaf来做动态页面。Templates目录这是存放Thymeleaf的页面。</p><h2 id="默认存放目录"><a href="#默认存放目录" class="headerlink" title="默认存放目录"></a>默认存放目录</h2><p>/META-INF/resources/</p><p>/resources/</p><p>/static/</p><p>/public/</p><h2 id="自定义存放目录"><a href="#自定义存放目录" class="headerlink" title="自定义存放目录"></a>自定义存放目录</h2><p>在配置文件中修改<strong>spring.resources.static-locations</strong>多个目录使用逗号分隔如：</p><p><strong>spring.resources.static-locations = classpath:/static/,/public/</strong></p><h2 id="Spring-Boot整合JSP"><a href="#Spring-Boot整合JSP" class="headerlink" title="Spring Boot整合JSP"></a>Spring Boot整合JSP</h2><ol><li>创建webapp目录和在webapp中创建WEB-INF目录，在WEB-INF中创建jsp目录,修改pom文件添加jsp依赖</li></ol><p><img src="https://pic3.zhimg.com/80/v2-1b3b6dc80e95fb78e3687f3df32b1d93_720w.jpg" alt="img"></p><ol><li>将webapp标记为moudles中的Web</li><li>修改spring boot中配置视图层的目录</li></ol><p>Spring.mvc.view.prefix=/WEB-INF/jsp/ 保存jsp文件的文件目录</p><p>Spring.mvc.view.suffix=.jsp jsp文件的后缀名</p><p>在聚合项目中，无法找到jsp文件，需要制定工作目录。</p><h2 id="Spring-boot整合freemaker"><a href="#Spring-boot整合freemaker" class="headerlink" title="Spring boot整合freemaker"></a>Spring boot整合freemaker</h2><ol><li>创建项目</li><li>修改pom文件，添加freemake依赖</li></ol><p><img src="https://pic2.zhimg.com/80/v2-d99b437a6ee81b049d28d3a98d65908e_720w.jpg" alt="img"></p><h2 id="Spring-整合Thymeleaf"><a href="#Spring-整合Thymeleaf" class="headerlink" title="Spring 整合Thymeleaf"></a>Spring 整合Thymeleaf</h2><p>Thymeleaf的优点是它是基于HTML的，即使视图没有渲染成功，也是一个标准的HTML页面。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><img src="https://pic3.zhimg.com/80/v2-76d12ba43a8867db766d4768907db517_720w.jpg" alt="img"></p><h2 id="Thymeleaf基本使用"><a href="#Thymeleaf基本使用" class="headerlink" title="Thymeleaf基本使用"></a>Thymeleaf基本使用</h2><p>Thymeleaf基本语法</p><p>命名空间 <strong>xmlns:th=”<a href="https://link.zhihu.com/?target=http://www.thymeleaf.org">http://www.thymeleaf.org</a>”</strong></p><ol><li>字符串与变量输出</li></ol><p><strong>th:text</strong> 在页面中输出值</p><p><strong>th:value 可以一个值放入到input标签的value中 针对input标签</strong></p><ol><li>字符串操作</li></ol><p>使用内置对象</p><ol><li>引用内置对象需要使用#</li><li>大部分内置对象的名称都以s结尾。如：strings,numbers,dates<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#strings.isEmpty(key)&#125; 判断key是否为空串</span><br><span class="line"></span><br><span class="line">$&#123;#strings.contains(msg,T)&#125; 判断字符串msg中是否包含T子串</span><br></pre></td></tr></table></figure></li><li>条件判断</li></ol><p>th:if / th:switch和th:case</p><p>th:case = “*” 表示java中switch的default</p><ol><li>迭代</li></ol><p>th:each=”object : ${set}”</p><p><strong>th:each迭代Map</strong></p><ol><li>Thymeleaf的配置</li></ol><p>Spring.thymeleaf.cache=false #关闭页面缓存</p><p>Spring.thymeleaf.encoding=UTF-8设置页面编码</p><p>Spring.thymeleaf.mode=HTML5 #视图解析目标，若使用html5则需要加入此项</p><h2 id="SpringBoot整合JDBC"><a href="#SpringBoot整合JDBC" class="headerlink" title="SpringBoot整合JDBC"></a>SpringBoot整合JDBC</h2><p>添加依赖</p><p><img src="https://pic2.zhimg.com/80/v2-6ba31d0f200df586c67ecb24f3322796_720w.jpg" alt="img"></p><p>添加驱动</p><p><img src="https://pic2.zhimg.com/80/v2-b7b3db56388dced7de2a3247eb1fade9_720w.jpg" alt="img"></p><p>2配置数据源</p><p>添加druid数据源依赖</p><p><img src="https://pic4.zhimg.com/80/v2-c7efae6a949eceb420b3eef323234916_720w.jpg" alt="img"></p><p>使用@ConfigureProperties配置jdbc</p><p>@ConfigurePropertie 只能读取application.properties或者application.yml</p><p><img src="https://picb.zhimg.com/80/v2-d66e739ac6f33542b0a11ce804e0915e_720w.jpg" alt="img"></p><p>Properties文件中</p><p><img src="https://pic2.zhimg.com/80/v2-aac0ee5c56dcc18ddd98b688541b7ab7_720w.jpg" alt="img"></p><p>使用@EnableConfigurationProperties指定加载的类</p><p>也可以在配置类中使用构造方法和作为参数传递</p><p>可以将@ConfigurationProperties(prefix = “jdbc”)放在函数之前</p><p><img src="https://pic2.zhimg.com/80/v2-cc6ba857bdee8360d71b46009abedc7a_720w.jpg" alt="img"></p><p>Spring boot默认使用HikariDataSource数据源</p><p>Application.properties配置文件中配置</p><p><img src="https://pic3.zhimg.com/80/v2-4ae14603148ad173040ed53e5600943b_720w.jpg" alt="img"></p><p>更换数据源</p><p><img src="https://pic2.zhimg.com/80/v2-ba7455761f537b3972f9b10858c47ef6_720w.jpg" alt="img"></p><p>实现一个查询业务</p><p>Dao层</p><p><img src="https://pic3.zhimg.com/80/v2-3993c2981eaa9667e4fe0b709b69c2a9_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-317eb3116a689776aa7997d0a3db38d2_720w.jpg" alt="img"></p><p>Services层</p><p><img src="https://picb.zhimg.com/80/v2-d0245b3fe406e535f7ca427f444e2251_720w.jpg" alt="img"></p><p><img src="https://picb.zhimg.com/80/v2-97f81e51af3adbeb8a785ddfdec87dfb_720w.jpg" alt="img"></p><h2 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h2><p>添加mysql驱动和mybatis依赖</p><p><img src="https://pic1.zhimg.com/80/v2-b3bef1a89137f3d4728b17fc9ac1ce53_720w.jpg" alt="img"></p><p>配置maven的generator插件，添加依赖</p><p><img src="https://pic2.zhimg.com/80/v2-86de22dc79f48807c2f940a51e497c49_720w.jpg" alt="img"></p><p>指定配置 文件</p><p><img src="https://pic2.zhimg.com/80/v2-23458d940df9e06168cfbddf015c0761_720w.jpg" alt="img"></p><p>配置文件内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- context 是逆向工程的主要配置信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：起个名字 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--optional,指在创建class时，对注释进行控制--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--jdbc的数据库连接 wg_insert 为数据库名字--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/wg_insert?useUnicode=true<span class="symbol">&amp;amp;</span>characeterEncoding=utf-8<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;jsl123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--非必须，类型处理器，在数据库类型和java类型之间的转换控制--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 默认情况下数据库中的 decimal，bigInt 在 Java 对应是 sql 下的 BigDecimal 类 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 不是 double 和 long 类型 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- targetPackage：生成的实体类所在的包 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：生成的实体类所在的硬盘位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;cn.silver.springbootmybaits.Enties&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否允许子包 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否对modal添加构造函数 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;constructorBased&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 建立modal对象是否不可改变 即生成的modal对象不会有setter方法，只有构造方法 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;cn.silver.springbootmybaits.Mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;cn.silver.springbootmybaits.Dao&quot;</span> </span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- tableName是数据库中的表名，domainObjectName是生成的JAVA模型名，后面的参数不用改，要生成更多的表就在下面继续加table标签 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;movies&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Movies&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- tableName是数据库中的表名，domainObjectName是生成的JAVA模型名，后面的参数不用改，要生成更多的表就在下面继续加table标签 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;users&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Users&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;ratings&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Ratings&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用资源拷贝插件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--资源拷贝插件 mapper.xml不在resources夹中--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>在启动类上添加@MapperSan注解</p><p>@MapperScan(<strong>“cn.silver.springbootmybaits.Dao”</strong>)</p><p>扫描xml所在的包名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#扫描classpath 中mapper下的映射配置文件，当配置文件放在resources文件中</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"> <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line"> <span class="comment">#定义包的别名，在mapper.xml文件中可以直接使用Enties中的类型</span></span><br><span class="line"> <span class="attr">type-aliases-package:</span> <span class="string">cn.silver.springbootmybaits.Enties</span></span><br></pre></td></tr></table></figure><h2 id="Spring-boot异常处理和单元测试"><a href="#Spring-boot异常处理和单元测试" class="headerlink" title="Spring boot异常处理和单元测试"></a>Spring boot异常处理和单元测试</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li>自定义错误页面</li></ol><p>Spring boot默认的处理异常的机制：spring boot默认的已经提供了一套处理异常的机制，一旦程序中出现了异常springboot会向/error的url发送请求。在spring boot中提供一个名为BasicErrorController来处理/error请求，然后跳转到默认显示异常的页面展示异常信息。如果我们需要将所有的异常同一跳转到自定义的错误页面，需要在src/main/resouces/templates目录下创建error.html页面。注意：页面名称必须叫error</p><p><img src="https://pic2.zhimg.com/80/v2-82049c7f57b4dde6bf8d7dd0bbe3396a_720w.jpg" alt="img"></p><ol><li>通过@ExceptionHandler处理</li></ol><p><img src="https://pic1.zhimg.com/80/v2-b4abb3a2f52bd7a319fd34fabc739391_720w.jpg" alt="img"></p><p>通过注解对不同的错误进行处理</p><ol><li>通过@ControllerAdvice与@ExceptionHandler注解处理异常</li><li>创建全局异常处理类</li></ol><p><img src="https://pic4.zhimg.com/80/v2-55ef5c08f00bc7204e6d3082a8aea716_720w.jpg" alt="img"></p><ol><li>通过SimpleMappingExceptionResolver对象处理</li></ol><p>创建全局异常类</p><p><img src="https://pic2.zhimg.com/80/v2-5fe3b3933d3f840531ac09a27477bbb6_720w.jpg" alt="img"></p><ol><li>通过自定义HandlerExceptionResolver对象处理异常</li></ol><p>创建全局异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalHandler3</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line">            mv.setViewName(<span class="string">&quot;error5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException)&#123;</span><br><span class="line">            mv.setViewName(<span class="string">&quot;error6&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mv.addObject(<span class="string">&quot;err&quot;</span>,e.toString());</span><br><span class="line"> <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot整合Junit单元测试"><a href="#Spring-Boot整合Junit单元测试" class="headerlink" title="Spring Boot整合Junit单元测试"></a>Spring Boot整合Junit单元测试</h2><p>Spring boot 2.x使用Junit5作为测试平台</p><ol><li>修改pom文件添加Test依赖</li></ol><p><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-test</artifactId><scope>test</scope><exclusions><exclusion><groupId>org.junit.vintage</groupId><artifactId>junit-vintage-engine</artifactId></exclusion></exclusions></dependency></dependencies></p><p><img src="https://pic2.zhimg.com/80/v2-cdd9a57c472e0b8cd6aad3d5cfb7aec8_720w.jpg" alt="img"></p><p>排除提供junit3 和junit4测试</p><ol><li>编写测试代码</li></ol><p><img src="https://picb.zhimg.com/80/v2-869826cb8f86e4b3addb3421bc57be7a_720w.jpg" alt="img"></p><h2 id="Spring-Boot服务端数据校验"><a href="#Spring-Boot服务端数据校验" class="headerlink" title="Spring Boot服务端数据校验"></a>Spring Boot服务端数据校验</h2><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对数据校验"><a href="#对数据校验" class="headerlink" title="对数据校验"></a>对数据校验</h2><p>使用注解进行数据校验</p><p>@NotNull 对基本数据类型的对象类型做非空校验</p><p>@NotBlank 对对字符串类型做非空校验</p><p>@NotEmpty 对集合类型做非空校验</p><p>使用@Validated设置校验数据</p><p>自定义错误信息</p><p>@NotNull（message = “tips”） 对基本数据类型的对象类型做非空校验,message表示提示信息</p><p>在配置文件中自定义提示信息，使用Hiberaiter-validator框架</p><p>配置文件必须是ValidationMessages.properties</p><h2 id="Spring-boot-使用devtools进行热部署"><a href="#Spring-boot-使用devtools进行热部署" class="headerlink" title="Spring boot 使用devtools进行热部署"></a>Spring boot 使用devtools进行热部署</h2><p>添加Devtools依赖或者新建项目的时候选中devtools</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-spring-boot注解&quot;&gt;&lt;a href=&quot;#1-spring-boot注解&quot; class=&quot;headerlink&quot; title=&quot;1.spring boot注解&quot;&gt;&lt;/a&gt;1.spring boot注解&lt;/h2&gt;&lt;h2 id=&quot;1-1-SpringBootApplication&quot;&gt;&lt;a href=&quot;#1-1-SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;1.1 @SpringBootApplication&quot;&gt;&lt;/a&gt;1.1 @SpringBootApplication&lt;/h2&gt;&lt;p&gt;是spring的启动类&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>auto</title>
    <link href="http://example.com/jsblog/66ba25fa.html"/>
    <id>http://example.com/jsblog/66ba25fa.html</id>
    <published>2020-09-12T03:17:12.000Z</published>
    <updated>2020-09-12T04:04:07.417Z</updated>
    
    <content type="html"><![CDATA[<p>auto 类型推导。在c++98/03 代表具有自动存储期的局部变量。在c++11中auto是一个类型指示符，用来提示编译器对此类型的变量做类型的自动推导。</p><a id="more"></a><p>auto推导的两条规则：</p><p>(1）当不声明为指针或者引用时，auto的推导结果和初始化表达式将抛弃引用和cv限定符（const 和volatile限定符）。</p><p>(2）当声明为指针或者引用时，auto推导的结果将保持初始化表达式的cv属性</p><p>auto的限制：</p><p>(1) 不能用于函数参数的类型推导</p><p>(2) 不能用户非静态成员变量</p><p>(3) 无法定义数组</p><p>(4) 无法推导出模板参数</p><p>auto使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; testMap = &#123;&#123;<span class="number">1</span>, <span class="number">0.5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0.75</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0.9</span>&#125;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;::iterator it = testMap.begin();</span><br><span class="line">  <span class="keyword">for</span> (; it != testMap.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot; value =&quot;</span> &lt;&lt; (*it).second</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用auto</span></span><br><span class="line">  <span class="keyword">auto</span> itr = testMap.begin();</span><br><span class="line">  <span class="keyword">for</span> (; itr != testMap.end(); itr++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; (*itr).first &lt;&lt; <span class="string">&quot; value =&quot;</span> &lt;&lt; (*itr).second</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = 1 value =0.5</span><br><span class="line">key = 2 value =0.75</span><br><span class="line">key = 3 value =0.9</span><br><span class="line">key = 1 value =0.5</span><br><span class="line">key = 2 value =0.75</span><br><span class="line">key = 3 value =0.9</span><br></pre></td></tr></table></figure><p>当要使用的具体类型的名称过长时，可以使用auto进行推导简化代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;auto 类型推导。在c++98/03 代表具有自动存储期的局部变量。在c++11中auto是一个类型指示符，用来提示编译器对此类型的变量做类型的自动推导。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Decltype</title>
    <link href="http://example.com/jsblog/6e431fb1.html"/>
    <id>http://example.com/jsblog/6e431fb1.html</id>
    <published>2020-09-12T03:15:20.000Z</published>
    <updated>2020-09-12T03:23:06.624Z</updated>
    
    <content type="html"><![CDATA[<p>decltype : 获取表达式的类型。在编译时推导出一个表达式的类型，并且不会计算表达式的值</p><a id="more"></a><p>使用方式: decltype(expression)</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>; <span class="comment">// y -&gt;  int</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) z = x + y; <span class="comment">// z - &gt;  int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;<span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;<span class="comment">// p-&gt; const int *</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *pi = &amp;z; <span class="comment">// pi -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(pi) *pp = π<span class="comment">//pp -&gt; int**</span></span><br></pre></td></tr></table></figure><p>auto与decltype类似但是又不同，auto只能根据变量的初始化表达式推导出变量应该具有的类型。decltype将精确的推导出表达式定义的类型，不会舍弃和弃用cv限定符。</p><p>decltype(exp)推导规则:</p><ol><li>exp 是标识、类访问表达式，decltype(exp) 和exp的类型一致</li></ol><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) y = <span class="number">1</span>;<span class="comment">// y -&gt; volatile </span></span><br><span class="line"><span class="keyword">decltype</span>(Foo::Number) c = <span class="number">0</span>;           <span class="comment">// c -&gt; const int</span></span><br><span class="line">Foo foo;</span><br><span class="line"><span class="keyword">decltype</span>(Foo.x) d = <span class="number">0</span>;  <span class="comment">// d -&gt; int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span><span class="keyword">int</span> x;&#125;</span><br><span class="line">F f = F();</span><br><span class="line"><span class="keyword">decltype</span>(f.x) x = <span class="number">0</span>;                              <span class="comment">// x -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>((f.x)) e = x;                              <span class="comment">// e -&gt; const int</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>exp是函数调用，decltype(exp)和返回值的类型一致</p></li><li><p>其他情况，如果exp是一个左值，则decltype(exp)是exp类型的左值引用，否则和exp类型一致</p></li></ol><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(int_func()) a = <span class="number">0</span>; <span class="comment">//a -&gt; int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">int_func_l</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(int_func_l()) b = x;<span class="comment">// b -&gt; int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">int_func_rr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(int_func_rr()) c = <span class="number">0</span>;<span class="comment">// c -&gt; int&amp;&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a+b) z = x;<span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>( a+= b) y = z;<span class="comment">// y-&gt;int&amp;</span></span><br></pre></td></tr></table></figure><p>返回类型的后置语法使用 auto 和decltype</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line">auto func(T&amp; val) -&gt;decltype(foo(val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;decltype : 获取表达式的类型。在编译时推导出一个表达式的类型，并且不会计算表达式的值&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Num and String</title>
    <link href="http://example.com/jsblog/d56b4289.html"/>
    <id>http://example.com/jsblog/d56b4289.html</id>
    <published>2020-09-12T03:09:12.000Z</published>
    <updated>2020-09-12T03:23:06.627Z</updated>
    
    <content type="html"><![CDATA[<p>在使用C++进行字符串转换的时候总是忘记，以此记录一下系统函数。同时给出一个自己参考CJSon实现的一个转换函数</p><a id="more"></a><p>数值型转换为字符串 使用std::to_string函数，若是转换成wstring则使用to_wstring函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">int</span> value)</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> value)</span></span>;   </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>可能会导致std::bad_alloc异常。</p><p>将数值保存到char* buff中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%d”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%ld”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%lld”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%u”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%lu”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%llu”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%f”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%Lf”,value);</span><br></pre></td></tr></table></figure><p>字符串转换为数值：</p><p><strong>c语言：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int atoi(const char* str);</span><br><span class="line">long atol(const char* str);</span><br><span class="line">long long atoll(const char* str);</span><br><span class="line">double atof(const char* str);</span><br></pre></td></tr></table></figure><p><strong>C++:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">std::stoll</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">std::stoll</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">std::stold</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">std::stold</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str: 数值字符串</p><p>pos： 数字在字符串中的起始位置</p><p>base : 进制，默认为10进制数字</p><p>参考CJSON的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CharToNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>,sign = <span class="number">1</span>,expsign=<span class="number">1</span>,decimal = <span class="number">0</span>,exponent = <span class="number">0</span>,exponentSign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>,str++;   <span class="comment">//the opposite</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;0&#x27;</span>) str++;             <span class="comment">// is zero ?</span></span><br><span class="line">    <span class="keyword">if</span> (*str &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str&lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//is numbers</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res *<span class="number">10</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;.&#x27;</span> &amp;&amp; str[<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//decimal partition</span></span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res *<span class="number">10</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            decimal--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//exponent partition</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;e&#x27;</span> || *str==<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        <span class="keyword">if</span> (*str==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            str++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            exponentSign = <span class="number">-1</span>,str++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">           exponent =  exponent *<span class="number">10</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = sign * res * <span class="built_in">pow</span>(<span class="number">10.0</span>,(decimal + (exponentSign * exponent)));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用C++进行字符串转换的时候总是忘记，以此记录一下系统函数。同时给出一个自己参考CJSon实现的一个转换函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>select</title>
    <link href="http://example.com/jsblog/4bf2eac0.html"/>
    <id>http://example.com/jsblog/4bf2eac0.html</id>
    <published>2020-09-12T03:07:50.000Z</published>
    <updated>2020-09-12T03:53:37.986Z</updated>
    
    <content type="html"><![CDATA[<p>使用select函数实现I/O复用</p><a id="more"></a><p>Select函数允许进程指示内核等待多个事件中的一个发生，并只在或多个事件发生或经历一段指定时间后才唤醒。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *write_set,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure><p>返回：若有就绪描述符就绪就返回就绪数目，若超时返回0，错误发生返回-1</p><p>maxfdp1 : 指定待测试的描述符的个数，值是待测最大描述符加1，从0,1,2…到maxfdp1-1都会被测试</p><p>readset : 让内核测试读的描述符集合</p><p>writeset : 让内核测试写的描述符集合</p><p>exceptset : 让内核测试异常条件的描述符集合</p><p>对于fd_set的初始化可设置需要使用以下4个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;         <span class="comment">//清空文件描述符集合fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;   <span class="comment">//将指定的文件描述符fd加入文件描述符集合fdset</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>; <span class="comment">//将判断文件描述符fd是否在文件描述符集合fdset中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;   <span class="comment">//将指定的文件描述符fd从文件描述符集合fdset中清除</span></span><br></pre></td></tr></table></figure><p>Timeout : 是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> tv_sec; <span class="comment">//秒</span></span><br><span class="line">  <span class="keyword">long</span> tv_usec; <span class="comment">//毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>的类型，表示告知内核等待所指定的描述符中任何一个就绪可花多长时间。这个参数有以下三种情况：</p><p>1）永远等待下去：直到有一个描述符准备好I/O才返回，这时需要将此参数设置为NULL</p><p>2）等待一段时间：在有一个描述符准备好I/O时返回，但不能超过timeout中设置的秒数和毫秒数</p><p>3）根本不等待：检查描述符后立即返回，这就是轮询。需要将传入的timeout中的秒数和毫秒数都设置为0</p><p>Tcp服务端例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 40501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="comment">// 读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> noreadcn, readcn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  noreadcn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (noreadcn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((readcn = read(fd, buf, noreadcn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        readcn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readcn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;             <span class="comment">// EOF</span></span><br><span class="line">    noreadcn -= readcn;  <span class="comment">//读取的数据少于maxcn继续读</span></span><br><span class="line">    buf += readcn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - noreadcn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nowritecn, writecn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  nowritecn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (nowritecn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((writecn = write(fd, buf, nowritecn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        writecn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writecn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;               <span class="comment">// EOF</span></span><br><span class="line">    nowritecn -= writecn;  <span class="comment">//写入的数据少于maxcn继续写</span></span><br><span class="line">    buf += writecn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - nowritecn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, maxi, maxfd, listenfd, sockfd, connfd;</span><br><span class="line">  <span class="keyword">int</span> nready, client[FD_SETSIZE];</span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  fd_set rset, allset;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliAddr</span>, <span class="title">serverAddr</span>;</span></span><br><span class="line">  clilen = <span class="keyword">sizeof</span>(cliAddr);</span><br><span class="line">  bzero(&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">  bzero(&amp;cliAddr, clilen);</span><br><span class="line">  listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(PORT);</span><br><span class="line">  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(listenfd, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置 fd_set </span></span><br><span class="line">  maxfd = listenfd;</span><br><span class="line">  maxi = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">    client[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FD_ZERO(&amp;allset);           <span class="comment">//清空allset</span></span><br><span class="line">  FD_SET(listenfd, &amp;allset);  <span class="comment">// 讲listenfd 添加到allsetj集合中</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    rset = allset;  <span class="comment">//测试读集合</span></span><br><span class="line">    nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;  <span class="comment">//有新的连接请求</span></span><br><span class="line">      connfd = accept(listenfd, (struct sockaddr *)&amp;cliAddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123; <span class="comment">//将新的连接描述符保存</span></span><br><span class="line">        <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          client[i] = connfd;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == FD_SETSIZE) &#123;         <span class="comment">//达到最大</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      FD_SET(connfd, &amp;allset);</span><br><span class="line">      <span class="keyword">if</span> (connfd &gt; maxfd) maxfd = connfd;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; maxi) maxi = i;   <span class="comment">//最大的连接个数</span></span><br><span class="line">      --nready;</span><br><span class="line">      <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>) &#123;   <span class="comment">//没有可读的描述符</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;    <span class="comment">//检查所有的客户端传来的数据</span></span><br><span class="line">      <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;allset)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = readn(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">          close(sockfd);</span><br><span class="line">          FD_CLR(sockfd, &amp;allset);</span><br><span class="line">          client[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          writen(sockfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//没有可读的文件描述符</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 40501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="comment">// 读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> noreadcn, readcn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  noreadcn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (noreadcn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((readcn = read(fd, buf, noreadcn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        readcn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readcn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;             <span class="comment">// EOF</span></span><br><span class="line">    noreadcn -= readcn;  <span class="comment">//读取的数据少于maxcn继续读</span></span><br><span class="line">    buf += readcn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - noreadcn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nowritecn, writecn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  nowritecn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (nowritecn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((writecn = write(fd, buf, nowritecn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        writecn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writecn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;               <span class="comment">// EOF</span></span><br><span class="line">    nowritecn -= writecn;  <span class="comment">//写入的数据少于maxcn继续写</span></span><br><span class="line">    buf += writecn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - nowritecn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">  <span class="keyword">int</span> addresslen = <span class="keyword">sizeof</span>(serverAddr);</span><br><span class="line">  <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="keyword">char</span> mybuf[MAXLINE];</span><br><span class="line">  <span class="keyword">char</span> *buf = <span class="string">&quot;client\n&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> rc;</span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">  bzero(&amp;serverAddr, addresslen);</span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(PORT);</span><br><span class="line">  inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serverAddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  rc = connect(sockfd, (struct sockaddr *)&amp;serverAddr, addresslen);</span><br><span class="line">  <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//写入数据</span></span><br><span class="line">  writen(sockfd, (<span class="keyword">void</span> *)buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client send: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  bzero(mybuf, MAXLINE);</span><br><span class="line">  readn(sockfd, (<span class="keyword">void</span> *)mybuf, MAXLINE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;server read: %s\n&quot;</span>, mybuf);</span><br><span class="line">  close(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用select函数实现I/O复用&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>poll</title>
    <link href="http://example.com/jsblog/84bcfa45.html"/>
    <id>http://example.com/jsblog/84bcfa45.html</id>
    <published>2020-09-12T03:06:59.000Z</published>
    <updated>2020-09-12T03:53:08.264Z</updated>
    
    <content type="html"><![CDATA[<p>使用poll函数实现I/O复用. poll允许工作在任何描述符中，poll提供的功能与select函数类似。</p><a id="more"></a><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray,<span class="keyword">unsigned</span> <span class="keyword">long</span> nfds,<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>返回：若有就绪描述符则为其数目，若超时返回0，出错返回-1</p><p>第一个参数是指向一个结构体数组第一个元素的指针。每个元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> fd;                  <span class="comment">//需要检测的文件描述符</span></span><br><span class="line"> <span class="keyword">short</span> events;            <span class="comment">//请求的事件 </span></span><br><span class="line"> <span class="keyword">short</span> revents;           <span class="comment">//返回的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下表说明了能够作为events和revents的常量</p><p><img src="https://pic4.zhimg.com/80/v2-ffc0e68af82b0873a6794a4296e602eb_720w.jpg" alt="img"></p><p>结构体数组中元素的个数是由nfds参数指定。</p><p>timeout 参数指定poll函数返回前等待多长时间。它是一个指定应等待毫秒数的正值。取值如下表：</p><p>timeout值说明-1永远等待，直到有描述符就绪0立即返回，不阻塞进程&gt;0等待指定的毫秒数</p><p>使用poll函数建立的服务器端如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by silver on 2020/8/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 9873</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTQUE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 256</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd,confd,sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="keyword">int</span> maxcount = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">SerAddr</span>,<span class="title">Cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> Clilen = <span class="keyword">sizeof</span>(Cliaddr);</span><br><span class="line">    <span class="comment">//initializer</span></span><br><span class="line">    bzero(&amp;SerAddr,<span class="keyword">sizeof</span>(SerAddr));</span><br><span class="line">    bzero(&amp;Cliaddr,Clilen);</span><br><span class="line">    bzero(buf,MAXLINE);</span><br><span class="line">    listenfd = socket(AF_INET,SOCK_STREAM,IPPROTO_IP);</span><br><span class="line">    SerAddr.sin_family = AF_INET;</span><br><span class="line">    SerAddr.sin_port = htons(PORT);</span><br><span class="line">    SerAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,(struct sockaddr*)&amp;SerAddr,<span class="keyword">sizeof</span>(SerAddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd,LISTQUE) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; OPEN_MAX; count++) &#123;</span><br><span class="line">        client[count].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  n;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;server waiting....&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nready = poll(client,maxcount +<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) <span class="comment">// new client connection</span></span><br><span class="line">        &#123;</span><br><span class="line">            confd = accept(listenfd,(struct sockaddr*)&amp;Cliaddr,&amp;Clilen);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client address: %s\n&quot;</span>,inet_ntoa(Cliaddr.sin_addr));</span><br><span class="line">            <span class="keyword">if</span> (confd &lt; <span class="number">0</span>)&#123; perror(<span class="string">&quot;accept error&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (count = <span class="number">1</span>;  count&lt;OPEN_MAX ; count++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (client[count].fd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    client[count].fd = confd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == OPEN_MAX) &#123;<span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">            client[count].events = POLLRDNORM;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxcount) maxcount = count;</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//no more readable descriptions</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;=maxcount ; count++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[maxcount].fd) &lt; <span class="number">0</span>)&#123; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(client[count].revents &amp; (POLLRDNORM | POLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                n = read(sockfd,buf,MAXLINE);</span><br><span class="line">                <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        client[count].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    client[count].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    writen(sockfd,buf,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//no more readable descriptions</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用poll函数实现I/O复用. poll允许工作在任何描述符中，poll提供的功能与select函数类似。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>getsockopt and setsockopt</title>
    <link href="http://example.com/jsblog/1646cb2f.html"/>
    <id>http://example.com/jsblog/1646cb2f.html</id>
    <published>2020-09-12T03:04:35.000Z</published>
    <updated>2020-09-12T03:23:06.633Z</updated>
    
    <content type="html"><![CDATA[<p>了解一下 getsockopt 和 setsockopt</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：<br>sockfd: 必须是打开的套接字描述符;</p><p>level: 系统解释选项的代码或者是通用的套接字代码，或者是某个特定协议的代码(例如：IPv4、IPv6、TCP或者SCTP);</p><p>optname:选项名称</p><p>optval: 对于getsockopt()是讲选项当前值存放在 optval中，对于setsockopt()为系统设置新的选项值</p><p>optlen: 指定*optval的大小</p><p>结果：</p><p>函数执行成功返回0 出错返回-1</p><p>EBADF：sock不是有效的文件描述词<br>EFAULT：optval指向的内存并非有效的进程空间<br>EINVAL：在调用setsockopt()时，optlen无效<br>ENOPROTOOPT：指定的协议层不能识别选项<br>ENOTSOCK：sock描述的不是套接字</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 40501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="comment">// 读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> noreadcn, readcn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  noreadcn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (noreadcn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((readcn = read(fd, buf, noreadcn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        readcn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readcn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;            <span class="comment">// EOF</span></span><br><span class="line">    noreadcn -= readcn; <span class="comment">//读取的数据少于maxcn继续读</span></span><br><span class="line">    buf += readcn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - noreadcn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nowritecn, writecn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  nowritecn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (nowritecn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((writecn = write(fd, buf, nowritecn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        writecn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writecn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">    nowritecn -= writecn; <span class="comment">//写入的数据少于maxcn继续写</span></span><br><span class="line">    buf += writecn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - nowritecn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, Confd;</span><br><span class="line">  fd_set rset, allset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">  <span class="keyword">socklen_t</span> clilen = <span class="keyword">sizeof</span>(clilen);</span><br><span class="line">  bzero(&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">  bzero(&amp;cliaddr, clilen);</span><br><span class="line">  listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">int</span> *)&amp;reuse,</span><br><span class="line">                 <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;set socket fail&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(PORT);</span><br><span class="line">  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(listenfd, <span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Confd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">int</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (getsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">int</span> *)&amp;opt, &amp;optlen) &lt;</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;get sockopt fail&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; keep-alive : %d\n&quot;</span>, opt);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *buf = <span class="string">&quot;welcome to you&quot;</span>;</span><br><span class="line">    writen(Confd, (<span class="keyword">void</span> *)buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    shutdown(Confd, SHUT_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解一下 getsockopt 和 setsockopt&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV for Windows</title>
    <link href="http://example.com/jsblog/2116d0b5.html"/>
    <id>http://example.com/jsblog/2116d0b5.html</id>
    <published>2020-09-12T03:00:29.000Z</published>
    <updated>2020-09-12T03:40:20.657Z</updated>
    
    <content type="html"><![CDATA[<p>我的配置是vs2015+opencv3.4.0。</p><a id="more"></a><p>opencv3.4.0可以在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Releases - OpenCV library 官方网站下载，当然你也可以在  </span><br><span class="line">OpenCV GitHub进行下载，如果在GitHub下载，在Windows上你需要自己编译，使用vs2015或者cmake进行编译</span><br></pre></td></tr></table></figure><p>使用cmake编译的时候首先打开cmd然后进入<strong>opencv安装目录下的源代码目录下，</strong>使用如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=D:/opencv</span><br></pre></td></tr></table></figure><p>”-DCMAKE_INSTALL_PREFIX=D:/opencv“ 设置其安装目录为D盘opencv目录。</p><p>就拿我的配置环境来说：</p><p>我先在官网下载opencv3.4.0.exe文件然后解压到D盘，首先要配置好环境变量，打开<strong>控制面板</strong>找到<strong>系统</strong>（或者系统与安全）</p><p><img src="https://pic3.zhimg.com/80/v2-dec01822104fa1e0edc58bea8c506b78_720w.jpg" alt="img"></p><p>点击高级系统设置，然后选择环境变量</p><p><img src="https://pic2.zhimg.com/80/v2-d8e2412a9b2f5b4a39a4ca35402e35cc_720w.jpg" alt="img"></p><p>点击环境变量，然后找到<strong>path变量</strong></p><p><img src="https://pic2.zhimg.com/80/v2-2716ee22eb16b2bc7b6aec39e32472ad_720w.jpg" alt="img"></p><p>点击新建，然后将</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc14\bin</span><br><span class="line">D:\opencv\opencv\build\x64\vc15\bin</span><br></pre></td></tr></table></figure><p>加入环境变量（我的opencv配置是64位的，所以在vs2015创建项目学习opencv的时候</p><p><img src="https://pic3.zhimg.com/80/v2-b17d6291df112e3cf963f81545927747_720w.jpg" alt="img"></p><p>一定要把x86改成x64还有就是一定把debug改成release才能运行，其他版本的opencv不一定要把debug改成release）</p><p>添加好环境变量之后，就是修改vs2015的c++配置,首先新建一个<strong>win32控制台项目</strong>，然后</p><p><img src="https://pic3.zhimg.com/80/v2-f990d5b644dbce886cde0c9d83c7d6f6_720w.jpg" alt="img"></p><p>点击属性管理器，</p><p><img src="https://pic1.zhimg.com/80/v2-a55e65fa2b922270b83ef380a37365c4_720w.jpg" alt="img"></p><p>点击</p><p><img src="https://pic1.zhimg.com/80/v2-8dd9f2c7e64db07b1967b0104c8f8340_720w.jpg" alt="img"></p><p>进入属性设置</p><p><img src="https://pic2.zhimg.com/80/v2-55934bf0d09dff9b742f2788a9e1452e_720w.jpg" alt="img"></p><p>在包含目录将opencv解压目录下的build目录下的include添加进去，在链接器中选择输入</p><p><img src="https://pic4.zhimg.com/80/v2-817bd286ef6360b08cea8e23046bd7bb_720w.jpg" alt="img"></p><p>在输入中的附加依赖项将（在我的电脑上就是）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc14\lib\opencv_world340.lib</span><br><span class="line">D:\opencv\opencv\build\x64\vc14\lib\opencv_world340d.lib  opencv_world340d.lib代表debug版本</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc15\lib\opencv_world340.lib</span><br><span class="line">D:\opencv\opencv\build\x64\vc15\lib\opencv_world340d.lib  opencv_world340d.lib代表debug版本</span><br></pre></td></tr></table></figure><p>选择14还是15要看你的visual c++编译器版本。我们来测试一下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat img = imread(&quot;D:\\opencv\\opencv\\sources\\samples\\data\\lena.jpg&quot;);</span><br><span class="line">imshow(&quot;lena image&quot;,img);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyWindow(&quot;lena image&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-b58b2195ff3a74de0f816370e40330a2_720w.jpg" alt="img"></p><p>当出现这张图片的时候就可以进行opencv的开发。其他版本的配置也与此类似</p><p><strong>python:</strong></p><p>首先在</p><p><a href="https://link.zhihu.com/?target=https://www.python.org/">Welcome to Python.orgwww.python.org<img src="https://picb.zhimg.com/v2-ff06c339780f23112c1cbbbb284158ff_ipico.jpg" alt="图标"></a></p><p>首先在</p><p><a href="https://link.zhihu.com/?target=https://www.python.org/">https://www.python.org/</a></p><p>官网上下载python3.5.4由于我的电脑是64位的所以我选择的是python3.5.4</p><p><img src="https://pic3.zhimg.com/80/v2-c0257b899bd67be788689b6a0066dbd9_720w.jpg" alt="img"></p><p>这个版本，在安装的时候要要把python添加进入环境变量，要不然就需要自己配置环境变量</p><p>安装好之后打开cmd然后输入python,如果出现下图结果则安装完成。</p><p><img src="https://pic4.zhimg.com/80/v2-d485d17d55d51482e0684f142784d308_720w.jpg" alt="img"></p><p>要安装opencv首先要安装numpy这个时候可以使用pip来进行安装opencv。安装命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br><span class="line">pip install opencv_python</span><br><span class="line">pip install opencv-contrib-python // opencv的扩展包，里边有一些图像处理的算法</span><br></pre></td></tr></table></figure><p>我们看个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&quot;imgs/2.jpg&quot;,cv.IMREAD_COLOR)</span><br><span class="line">cv.imshow(&quot;opencv_demo&quot;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>如果出现</p><p><img src="https://pic1.zhimg.com/80/v2-153b395419d1671cd205ca3bd2eb0694_720w.jpg" alt="img"></p><p>读入的图片表明python3.5.4+opencv环境已经配好啦</p><p>接下来就可以进行我们的opencv的开发了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我的配置是vs2015+opencv3.4.0。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>读写图片</title>
    <link href="http://example.com/jsblog/96b8a012.html"/>
    <id>http://example.com/jsblog/96b8a012.html</id>
    <published>2020-09-12T02:58:56.000Z</published>
    <updated>2020-09-12T03:02:20.580Z</updated>
    
    <content type="html"><![CDATA[<p>上一话我们已经把opencv的环境配置完成，那么我们接下来分析一下上一话的例子。</p><a id="more"></a><p><strong>图像读入：imread</strong></p><p>首先我们来看一下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat img = imread(&quot;D:\\opencv\\opencv\\sources\\samples\\data\\lena.jpg&quot;);</span><br><span class="line">imshow(&quot;lena image&quot;,img);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyWindow(&quot;lena image&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是使用c++来写的，而opencv就是机遇c++开发的，所以我们使用c++来对<strong>imread</strong>,<strong>imshow</strong>以及<strong>imwrite</strong>这三个API进行讲解。当然在使用c++调用opencv的API有两种方法，一种就是在前面引用opencv的命名空间，然后直接调用其API;二是使用域解析符（::）加上要调用的函数名称。在这个例子中我所使用的就是第一种方法。</p><p>接下来我们看一下imread函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat cv::imread(const string&amp; filename,int flags&#x3D;MREAD_COLOR);</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>**filename:**需要加载的文件</li><li>**flags:**是指加载图片时的标识，指定图片的类型</li></ul><p>Mat类型是一个矩阵类型，如果imread对文件无法解码，就会返回一个NULL，空的矩阵。</p><p>opencv支持的图片包含以下几种</p><ul><li>Windows bitmaps - *.bmp, *.dib (always supported)</li><li>JPEG files - *.jpeg, <em>.jpg, *.jpe (see the *Notes</em> section)</li><li>JPEG 2000 files - *.jp2 (see the <em>Notes</em> section)</li><li>Portable Network Graphics - *.png (see the <em>Notes</em> section)</li><li>WebP - *.webp (see the <em>Notes</em> section)</li><li>Portable image format - *.pbm, *.pgm, *.ppm (always supported)</li><li>Sun rasters - *.sr, *.ras (always supported)</li><li>TIFF files - <em>.tiff, *.tif (see the *Notes</em> section)</li></ul><p><strong>NOTE：</strong></p><p>imread这个函数读取图片是根据文件内容来读取，而不是根据文件的扩展名。</p><p><strong>imread的flags有以下几种：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMREAD_UNCHANGED            = -1, //返回包含alpha通道的加载图像</span><br><span class="line">   IMREAD_GRAYSCALE            = 0,  //返回一个灰度图像</span><br><span class="line">   IMREAD_COLOR                = 1,  //返回一个BGR通道的图像</span><br><span class="line">   IMREAD_ANYDEPTH             = 2,  //当输入具有相应的深度时返回16位/ 32位图像，否则将其转换为8位。.</span><br><span class="line">   IMREAD_ANYCOLOR             = 4,  //则以任何可能的颜色格式读取图像。</span><br><span class="line">   IMREAD_LOAD_GDAL            = 8,  //使用GDAL的驱动加载图像。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_2  = 16, //将图像转换为单通道灰度图像，图像大小减少1/2。</span><br><span class="line">   IMREAD_REDUCED_COLOR_2      = 17, //转换图像的3通道BGR彩色图像和图像的大小减少1/2。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_4  = 32, //将图像转换为单通道灰度图像，图像大小减少1/4。</span><br><span class="line">   IMREAD_REDUCED_COLOR_4      = 33, //转换图像的3通道BGR彩色图像和图像的大小减少1/4。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_8  = 64, //将图像转换为单通道灰度图像，图像大小减少1/8。</span><br><span class="line">   IMREAD_REDUCED_COLOR_8      = 65, //转换图像的3通道BGR色彩图像和图像大小减少1/8。</span><br><span class="line">   IMREAD_IGNORE_ORIENTATION   = 128 //不旋转图像根据EXIF的定位标志。</span><br></pre></td></tr></table></figure><p><strong>图像的显示：imshow</strong></p><p>imshow主要用于显示图像，将加载到内存中的图像显示出来</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void imshow(const string&amp; winname,InputArray mat);</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>第一个参数: const string&amp;类型的winname,将要显示的窗口标识名称</li><li>第二个参数:InputArray类型的mat，需要显示的图像</li></ul><p><strong>图像的保存：imwrite</strong></p><p>虽然在例子中没有使用imwrite但是有必要说明一下imwrite这个函数的使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool imwrite(const string&amp; filename,InputArray img,</span><br><span class="line">                             const vector&lt;int&gt;&amp; params=vector&lt;int&gt;());</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>第一个参数：const string&amp;类型的filename，要保存的文件名，要带上后缀例如”123.jpg”.</li><li>第二个参数：InputArray类型的img，一般填入一个Mat类型的图像数据</li><li>第三个参数：const std::vector&amp; params表示为特定格式保存的参数编码，它有一个默认值std::vector&lt; int &gt;()，所以一般情况下不用写。如果要填写，则有以下几个方面需要了解：</li></ul><ol><li>对于JPEG格式的图片，这个参数表示从0-100的图片质量（CV_IMWRITE_JPEG_QUALITY）,默认值是95.</li><li>对于PNG格式的图片，这个参数表示压缩级别（CV_IMWRITE_PNG_COMPRESSION）从0-9.较高的值意味着更小的尺寸和更长的压缩时间而默认值是3.</li><li>对于PPM，PGM或PBM格式的图片，这个参数表示一个二进制格式标志（CV_IMWRITE_PXM_BINARY），取值为0或1，而默认值为1.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一话我们已经把opencv的环境配置完成，那么我们接下来分析一下上一话的例子。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>色彩空间转换</title>
    <link href="http://example.com/jsblog/ba11d693.html"/>
    <id>http://example.com/jsblog/ba11d693.html</id>
    <published>2020-09-12T02:31:05.000Z</published>
    <updated>2020-09-12T03:28:10.098Z</updated>
    
    <content type="html"><![CDATA[<p>首先来了解一下opencv提供的API</p><a id="more"></a><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvtColor(InputArray src,OutputArray dst,int code,int dstCn=0);</span><br></pre></td></tr></table></figure><p><strong>paraemters:</strong></p><ul><li>第一个参数：InputArray类型的src,表示输入的图像矩阵</li><li>第二个参数：OutputArray类型的dst,表示输出的图像矩阵</li><li>第三个参数：int类型的code,表示颜色转换标识符</li><li>第四个参数目标图像的通道数，该参数为0时，目标图像根据源图像的通道数和具体操作自动决定</li></ul><p><strong>Note:</strong></p><p>第三个参数要根据图像的载入类型进行选择。</p><p>在BGR图像与XYZ图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2XYZ </span><br><span class="line">COLOR_RGB2XYZ </span><br><span class="line">COLOR_XYZ2BGR </span><br><span class="line">COLOR_XYZ2RGB</span><br></pre></td></tr></table></figure><h2 id="YCrCb颜色空间"><a href="#YCrCb颜色空间" class="headerlink" title="YCrCb颜色空间"></a><strong>YCrCb颜色空间</strong></h2><p>该颜色空间广泛的用于视频压缩和图像压缩方案，不能算是纯粹的颜色空间，因为它是BGR颜色空间的一种解码方式。 <strong>该颜色空间广泛的应用于MPEG和JPEG等视频和图像压缩方案。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y表示亮度 </span><br><span class="line">Cr : RGB空间R通道和Y差值 </span><br><span class="line">Cb: RGB空间B通道和Y差值</span><br></pre></td></tr></table></figure><p>在BGR图像与YCrCb图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2YCrCb</span><br><span class="line">COLOR_RGB2YCrCb </span><br><span class="line">COLOR_YCrCb2BGR </span><br><span class="line">COLOR_YCrCb2RGB</span><br></pre></td></tr></table></figure><h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>HSV颜色空间属于面向色度的颜色坐标系的一种，这种颜色模型<strong>接近于人类颜色感知的仿真模型</strong>，而在其他颜色模型中，例如RGB，一副图像被视为3中基色的叠加。</p><p>在BGR图像与YCrCb图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2HSV</span><br><span class="line">COLOR_RGB2HSV </span><br><span class="line">COLOR_HSV2BGR </span><br><span class="line">COLOR_HSV2RGB</span><br></pre></td></tr></table></figure><p><strong>GARY色彩空间</strong></p><p>gray图像色彩空间就是灰度图像。</p><p>在BGR图像与gray图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2GRAY</span><br><span class="line">COLOR_RGB2GRAY</span><br><span class="line">COLOR_GRAY2RGB </span><br><span class="line">COLOR_GRAY2BGR</span><br></pre></td></tr></table></figure><p><strong>HLS色彩空间</strong></p><p>HLS颜色空间，三个分量分别是色相（H）、亮度（L）、饱和度（S），这三个取值范围是</p><ul><li>0 &lt;= H &lt;= 360</li><li>0 &lt;= L &lt;= 1</li><li>0 &lt;= S &lt;= 1</li></ul><p>BGR与HLS图像之间的转换code如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2HLS</span><br><span class="line">COLOR_RGB2HLS</span><br><span class="line">COLOR_HLS2RGB </span><br><span class="line">COLOR_HLS2BGR</span><br></pre></td></tr></table></figure><p>YUV颜色模型中，U、V表示的是色度(Chrominance/Chroma)。YUV是欧洲电视系统所采用的颜色模型(属于PAL制式)，颜色被分为一个亮度信号和两个色差信号进行传输</p><p>BGR与YUV图像之间的转换code如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2YUV</span><br><span class="line">COLOR_RGB2YUV</span><br><span class="line">COLOR_YUV2RGB </span><br><span class="line">COLOR_YUV2BGR</span><br></pre></td></tr></table></figure><p>我们来看一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat srcImage = imread(&quot;E:\\vs2015\\imgs\\66.jpg&quot;);</span><br><span class="line">Mat hsvImage, YcrcbImage, HlsImage,grayImage,xyzImage,YuvImage;</span><br><span class="line">cvtColor(srcImage, xyzImage, COLOR_BGR2XYZ); //转换到XYZ</span><br><span class="line">cvtColor(srcImage,grayImage,COLOR_BGR2GRAY); //转换到灰度图像</span><br><span class="line">cvtColor(srcImage, HlsImage, COLOR_BGR2HLS); //转换到HLS色彩空间</span><br><span class="line">cvtColor(srcImage, YcrcbImage, COLOR_BGR2YCrCb); //转换到YCrCb色彩空间</span><br><span class="line">cvtColor(srcImage, hsvImage, COLOR_BGR2HSV);  //转换到HSV色彩空间</span><br><span class="line">cvtColor(srcImage, YuvImage, COLOR_BGR2YUV);</span><br><span class="line">//将图片显示出来</span><br><span class="line">imshow(&quot;input&quot;, srcImage);</span><br><span class="line">imshow(&quot;YUV&quot;,YuvImage);</span><br><span class="line">imshow(&quot;gray&quot;,grayImage);</span><br><span class="line">imshow(&quot;hsv&quot;, hsvImage);</span><br><span class="line">imshow(&quot;Ycrcb&quot;, YcrcbImage);</span><br><span class="line">imshow(&quot;hls&quot;, HlsImage);</span><br><span class="line">imshow(&quot;XYZ&quot;, xyzImage);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9a7249d28bc077c0f9e319c111729e01_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-b24f95bb1d9b3d17d25f0352c66311f7_720w.jpg" alt="img"></p><p><img src="https://picb.zhimg.com/80/v2-d05ce28660f6234fdf23c84585eb4711_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e309901516618e0d6bf2cd26bfea5bec_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ff58ae8c80971db00acccff137000700_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-242710cf960ac30737476cb06757c228_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-79e39bf12d1fe6a3616c21ad80a5c0ba_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先来了解一下opencv提供的API&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV for MinGW</title>
    <link href="http://example.com/jsblog/9a6917e7.html"/>
    <id>http://example.com/jsblog/9a6917e7.html</id>
    <published>2020-09-12T02:29:24.000Z</published>
    <updated>2020-09-12T03:58:53.651Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个opencv的入门的小白来说，要学会如何如何去编译opencv。</p><p>当然在windows使用mingw-w64编译opencv会遇到一些坑。 </p><a id="more"></a><p>不过我们所遇到的坑，必定有前辈遇到过这种相同的问题，所以今天我就来说一下</p><p>如何使用开源的mingw-w64来编译opencv</p><p><strong>编译环境</strong></p><p>mingw版本：mingw-w64 5.4.0 (64 bit)</p><p>CMAKE ： cmake 3.11.4 (64 bit)</p><p>opencv : 3.4.4</p><p>(我也编译过4.0.0虽然也成功了，不过由于其使用的时候必须使用c++11来开发，所以我就放弃了，改用了3.4.4)</p><p><strong>编译过程：</strong></p><p>Step 1:</p><p>配置相应的编译环境，从<a href="https://link.zhihu.com/?target=https://sourceforge.net/projects/mingw-w64/">MinGW-w64 - for 32 and 64 bit Windows</a> 这个网站你可以下载适合你自己的mingw-w64的版本。下载好之后为mingw-w64配置环境变量。我将下载好的mingw x86_64-5.4.0-release-posix-sjlj-rt-v5-rev0.7z</p><p><img src="https://pic4.zhimg.com/80/v2-a83da9dbd0b147549f97e99be4251642_720w.jpg" alt="img"></p><p>也就是第一个，解压到了d盘下MinGW目录下，所以我在我的电脑上的配置环境为</p><p><img src="https://pic1.zhimg.com/80/v2-c2bde3ac4c42399a2631899e8c07de92_720w.jpg" alt="img"></p><p>环境变量为D:\MinGW\mingw\bin</p><p><img src="https://pic1.zhimg.com/80/v2-cb180653db250bb90902a6a087b06f59_720w.jpg" alt="img"></p><p>如果配置好了，可以验证一下，如果在dos下输入gcc -v出现</p><p><img src="https://picb.zhimg.com/80/v2-72e4295970adcf8fc1488ddbae307d7c_720w.jpg" alt="img"></p><p>则说明配置完成</p><p><strong>Step2.</strong></p><p>配置好gcc开发环境之后，你也可以使用gcc开发c程序或者c++程序。我们的目的是为了编译opencv这个计算机视觉库。所以第二步，配置cmake，你可以直接从 <a href="https://link.zhihu.com/?target=https://cmake.org/download/">https://cmake.org/download/</a> 这个网址直接下载相应的cmake工具，然后安装。安装的时候将cmake添加进环境变量。</p><p>Step3</p><p>将下载好的opencv3.4.4和opencv_contrib3.4.4解压。为了方便我将它们放在了同一个文件夹下，然后启动cmake-gui</p><p><img src="https://pic4.zhimg.com/80/v2-ec0f1bd0bd9e1e5b78933befa7b26fe6_720w.jpg" alt="img"></p><p>我将opencv放在了F盘，为了方便寻找我就在F盘新建了一个文件夹，source code 选择opencv-3.4.4,输出路径为F:/opencv/build</p><p>然后点击 configure</p><p><img src="https://pic3.zhimg.com/80/v2-87f2081ce6f5ef0a89126a6e7703ae19_720w.jpg" alt="img"></p><p>点击yes</p><p><img src="https://pic2.zhimg.com/80/v2-05aec86d816229393a75cf77e26f2991_720w.jpg" alt="img"></p><p>选择mingw makefiles。点击finnish,中间要下载一些东西，所以要保证有网络，有可能需要翻墙才能configure完成。</p><p><img src="https://pic4.zhimg.com/80/v2-9a0ea65e001cc6dd8c59805f634cd049_720w.jpg" alt="img"></p><p>其中 不勾选</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENABLE_PRECOMPILED_HEADERS</span><br><span class="line">WITH_MSMF</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-28c5958f47d4f42dc979c58e6c245a4a_720w.png" alt="img"></p><p>这一栏是配置opencv_contrib的modules。</p><p>勾选</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENABLE_CXX11</span><br></pre></td></tr></table></figure><p>除了配置以上的之外还要修改一些源代码</p><p>在opencv-3.4.4中的</p><p>modules/videoio/src/cap_dshow.cpp中的</p><p><img src="https://picb.zhimg.com/80/v2-8801099898f2836d6b803fcd0a2fdf6a_720w.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “cap_dshow.hpp”</span></span><br></pre></td></tr></table></figure><p>上一行添加</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NO_DSHOW_STRSAFE</span><br></pre></td></tr></table></figure><p>即：</p><p><img src="https://pic3.zhimg.com/80/v2-6ded081864bb8b58def07079b1081364_720w.jpg" alt="img"></p><p>然后configure ，完成之后，执行generate</p><p>generate完成之后就可以进行第四步。</p><p><strong>Step4</strong></p><p>在build目录下打开Dos窗口</p><p>输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make</span><br></pre></td></tr></table></figure><p>如果想加速编译可以在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make -j 4</span><br></pre></td></tr></table></figure><p><img src="https://picb.zhimg.com/80/v2-91ecbae494ea3225d4ea6b704ee2df54_720w.jpg" alt="img"></p><p>等到编译完成100%（根据自己的电脑性能选择线程）我选择12是为了加速编译</p><p>你可以在编译的时候看会书，估计要1个小时</p><p><img src="https://pic3.zhimg.com/80/v2-645c94ab02e32b51eb0c91bd1dfe0495_720w.jpg" alt="img"></p><p>就可以使用</p><p><img src="https://pic2.zhimg.com/80/v2-92d2c18a2abbb6ecf993f234f3045fac_720w.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make install</span><br></pre></td></tr></table></figure><p>直到安装完成</p><p><img src="https://picb.zhimg.com/80/v2-ab0adbf3c5c92d62505d296281567b05_720w.jpg" alt="img"></p><p>这样opencv库就编译完成，你可以在build文件夹中找到install这个文件夹，</p><p>我将install文件夹移动到了D盘下的MinGW文件下，然后配置相应的环境变量，以便于cmake工具能够找到opencv这个库（我个人的配置）</p><p>新建一个变量</p><p><img src="https://pic1.zhimg.com/80/v2-9f083be6602529b827ab4b6d5bfdcc35_720w.jpg" alt="img"></p><p>点击确定，然后编辑PATH变量</p><p><img src="https://pic3.zhimg.com/80/v2-24b781b3fdb990747c9c4d87551db7b0_720w.jpg" alt="img"></p><p>添加一项，因为我的是64位所以就是x64，如果是32位则其中x64换成x86</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%OpenCV_DIR%\x64\mingw\bin</span><br></pre></td></tr></table></figure><p>就可以使用cmake，和mingw来开发opencv应用程序了</p><p>在编译的时候可能会遇到其他vs_version.rc.obj无法生成的问题</p><p>根据自己的编译目录手动生成 vs_version.rc.obj</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windres E:\opencv\build\modules\core\vs_version.rc -O coff E:\opencv\build\modules\core\CMa</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个opencv的入门的小白来说，要学会如何如何去编译opencv。&lt;/p&gt;
&lt;p&gt;当然在windows使用mingw-w64编译opencv会遇到一些坑。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Thread 入门</title>
    <link href="http://example.com/jsblog/ac99a763.html"/>
    <id>http://example.com/jsblog/ac99a763.html</id>
    <published>2020-09-07T12:52:36.000Z</published>
    <updated>2020-09-12T03:22:55.279Z</updated>
    
    <content type="html"><![CDATA[<p>在c++11之前c++没有提供对并发编程提供语言级别的支持，而在c++11在增加了线程以及线程相关的类，很方便的支持并发编程，提高了代码的可移植性。</p><a id="more"></a><p>创建线程：使用std::thread类可以创建新的线程，可以使用std::this_thread::get_id() 查看当前线程的id.。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ <span class="keyword">this</span> thread id is ” &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">      t.join();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用join函数会阻塞主线程，直到线程函数执行结束，如果func有返回值，则返回值被忽略。而如果不想阻塞主线程，可以使用detach函数，但是detach之后，线程函数就被分离，无法与线程函数发生联系，也不知道线程函数会何时执行完。</p><p>当然，可以构造传入参数的线程如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ str = ” &lt;&lt; str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func,”test”)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不能复制，但是可以被转移，利用移动语义（std::move）将一个线程的资源转给另外一个线程。也可以使用std::bind以及lambda函数表达式构造新的线程。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ str = ” &lt;&lt; str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">([](<span class="built_in">std</span>::<span class="built_in">string</span> str)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>&#125;,”test”)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::bind(func,”test”))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::thread t2;</span><br><span class="line">    t2 = <span class="built_in">std</span>::move(t1); <span class="comment">//ok</span></span><br><span class="line">    t.join();</span><br><span class="line">    t1.join(); <span class="comment">// system_error</span></span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在c++11之前c++没有提供对并发编程提供语言级别的支持，而在c++11在增加了线程以及线程相关的类，很方便的支持并发编程，提高了代码的可移植性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>FileStorage</title>
    <link href="http://example.com/jsblog/5c7f6c43.html"/>
    <id>http://example.com/jsblog/5c7f6c43.html</id>
    <published>2020-09-07T12:18:24.000Z</published>
    <updated>2020-09-07T12:54:43.230Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV中可以使用FileStorage 对xml，yml等文本文件的读写。可扩展<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">标记语言</a>，<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>的子集，简称XML。是一种用于标记电子文件使其具有结构性的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436">标记语言</a>。YAML是一个可读性高，用来表达数据<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的格式。</p><a id="more"></a><p>首先看一下fileStorage的构造函数和析构函数：</p><p><strong>构造函数：</strong></p><p>FileStorage::FileStorage(const String&amp; filename,int flags,const String&amp; encoding= String());</p><p>filename: 文件名称</p><p>flags：文件的打开模式，主要有以下几种：</p><p>READ: 以读的形式打开</p><p>WRITE:以写的形式打开</p><p>APPEND:以追加的形式打开</p><p>MEMORY: 从source 中读取数据或者写入数据到缓存中（通过FileStorage::release返回）</p><p>FORMAT_MASK: 格式化数据的掩码</p><p>FORMAT_AUTO : 自动格式化数据</p><p>FORMAT_XML： 将文件按照xml方式读写</p><p>FORMAT_YAML: 将文件按照yaml方式读写</p><p>FORMAT_JSON 将文件按照JSON方式读写</p><p>enconding: 文件的编码格式</p><p><strong>析构函数：</strong></p><p>FileStorage::~FileStorage()</p><p><strong>几个重要的函数：</strong></p><p>FileStorage::release() ： 关闭文件</p><p>FileStorage::isOpened() ：判断文件是否打开</p><p>FileStorage::Open(const String&amp; filename,int flags,const String&amp; encoding= String()) 与构造函数一样，将文件按照指定的格式以及编码打开。</p><p>operator&gt;&gt; ： 重载运算符，将节点数据读入到某个变量中</p><p>operator&lt;&lt; : 将数据保存到某个节点中</p><p>operator[] : 取出某个节点的数据</p><p>以yaml文件为例</p><p>读写数据代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/opencv.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;test.yml&quot;</span>,FileStorage::WRITE)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> fps = <span class="number">5</span>;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;fps&quot;</span> &lt;&lt; fps;</span><br><span class="line">    Mat m = Mat::eye(<span class="number">2</span>,<span class="number">3</span>,CV_32F);</span><br><span class="line">    Mat m1 = Mat::eye(<span class="number">3</span>,<span class="number">2</span>,CV_32F);</span><br><span class="line">    Mat result = (m+<span class="number">1</span>).mul(m+<span class="number">3</span>);</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; result;</span><br><span class="line">    fs.release();</span><br><span class="line">    <span class="comment">//读出数据</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs2</span><span class="params">(<span class="string">&quot;test.yml&quot;</span>,FileStorage::READ)</span></span>;</span><br><span class="line">    Mat r;</span><br><span class="line">    fs2[<span class="string">&quot;result&quot;</span>] &gt;&gt; r;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r  &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fs2.release();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存在test.yml的数据如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML:1.0</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">fps:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">result:</span> <span class="type">!!opencv</span><span class="string">-matrix</span></span><br><span class="line">   <span class="attr">rows:</span> <span class="number">2</span></span><br><span class="line">   <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">   <span class="attr">dt:</span> <span class="string">f</span></span><br><span class="line">   <span class="attr">data:</span> [ <span class="number">8</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">8</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span> ]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenCV中可以使用FileStorage 对xml，yml等文本文件的读写。可扩展&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&quot;&gt;标记语言&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073&quot;&gt;标准通用标记语言&lt;/a&gt;的子集，简称XML。是一种用于标记电子文件使其具有结构性的&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436&quot;&gt;标记语言&lt;/a&gt;。YAML是一个可读性高，用来表达数据&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BA%8F%E5%88%97%E5%8C%96&quot;&gt;序列化&lt;/a&gt;的格式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>TCP 连接与断开</title>
    <link href="http://example.com/jsblog/6f96be2d.html"/>
    <id>http://example.com/jsblog/6f96be2d.html</id>
    <published>2020-09-05T23:01:33.000Z</published>
    <updated>2020-09-05T23:20:40.538Z</updated>
    
    <content type="html"><![CDATA[<p> 本文主要是介绍TCP协议的连接与断开的过程以及自己对于这些过程的理解。</p><a id="more"></a><p><img src="https://pic1.zhimg.com/80/v2-043ba89d07d63a8868f876a39b944205_720w.jpg" alt="img"></p><p>(1) 客户端：发送SYN报文请求连接 ，置发送序号为X</p><p>(2) 服务端：接收到客户端的请求连接报文，发送SYN-ACK报文给客户端，其中确认序号为X+1,发送序号为Y</p><p>(3) 客户端：发送acK报文，并置发送序号为X+1，并置确认序号为Y+1</p><p>此时连接建立起来，客户端和服务器端可以发送数据。</p><p>四次握手断开连接</p><p><img src="https://pic1.zhimg.com/80/v2-69a7e128d54c5d91eba89fda1d9ad296_720w.jpg" alt="img"></p><p>（1） 客户端(主动)：发送请求FIN报文，发送序号为u</p><p>（2） 服务端（被动）：发送ACK报文，序号为v,确认号为u+1;确认客户端断开，服务器不再接受该客户端发来的数据。这时候成为半关闭状态。</p><p>（3） 服务端：等待Close-wait时间后，服务端做好了关闭的准备，向客户端发送一个关闭连接的FIN-ACK报文，确认号为u+1,序号为w</p><p>（4） 客户端：发送ACK报文，确认号为w+1,序号为u+1，确认关闭连接.</p><p>客户端最后等待2MSL是因为报文的生存时间为MSL，如果服务器端没有收到客户端发来的确认报文，那么服务端会重新发送一次FIN报文请求断开。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</p><p><strong>PS: 图片来源于百度图片，侵删！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 本文主要是介绍TCP协议的连接与断开的过程以及自己对于这些过程的理解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>像素操作</title>
    <link href="http://example.com/jsblog/561fe8cb.html"/>
    <id>http://example.com/jsblog/561fe8cb.html</id>
    <published>2020-09-05T22:38:19.000Z</published>
    <updated>2020-09-05T23:19:07.812Z</updated>
    
    <content type="html"><![CDATA[<p>我们首先了解一下什么是像素，计算机中是如何存储图像，以及opencv是如何表示图像的。</p><p><strong>像素</strong>：</p><p>像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。可以将像素视为整个图像中不可分割的单位或者是元素，不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小</p><a id="more"></a><p><strong>计算机存储图像：</strong></p><p>图像文件存储的都是每一个像素对应的颜色值。</p><p>1、<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d-ryfLmhcLmyPWuHIBnAu90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1bdP1cvnH0d">位图文件</a>有两种存储像素数据的格式。16777216色（真彩色）的图像，一个像素的颜色可以用24位数据表示。256色的图像可以用调色板对颜色的信息进行编码，一个像素的值对应的是调色板的索引，而不是直接对应一个像素的颜色，调色板的索引映射为像素的颜色。</p><p>2、以一百万个像素，256种颜色的BMP文件在电脑上的存储为例。这个文件包括一个十四字节的文件首部，一个四十字节的信息首部，一个1024字节的颜色表，一兆字节的位图数据。文件首部的前两个字节由字符BM组成，还包括了文件长度和位图数据在文件中的起始位置。</p><p>3、文件的信息首部包含了图像的高、宽、颜色数等非图形数据。</p><p>这个图像共有一百万个像素，一个像素需要八位的颜色信息，文件的这一部分的长度是一百万个字节，字节排放的顺序是自左到右从图像的最下面那行开始，这个文件的总大小是1001078字节。</p><p><strong>opencv表示图像：</strong></p><p>opencv中很多<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/datastructure">数据结构</a>为了达到內存使用的最优化，通常都会用它最小上限的空间来分配变量，有的数据结构也会因为图像文件格式的关系而给予适当的变量，因此需要知道它们声明的空间大小来配置适当的变量。一</p><p>般标准的图片，为RGB格式它们的大小为8bits格式，范围为0~255,对一个int空间的类型来说实在是太小，整整浪费了24bits的空间,假设有个640<em>480的BMP文件空间存储內存,那整整浪费了640</em>480<em>3</em>(32-8)bits的內存空间,总共浪费了2.6MB!，也就是那<br>2.6MB内什么东西都没存储，如果今天以8bits的格式来存储则只使用到0.6MB的內存而已(640<em>480</em>3*(8)+54<br>bits)，因此，对于文件格式的对应是一件很重要的事.。</p><p>访问像素的三种方法：</p><ol><li>指针访问</li><li>迭代器iterator</li><li>动态地址计算</li></ol><p>首先我们来看一段代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">//指针操作访问像素</span><br><span class="line">void colorReduce(Mat&amp; img,int div=64)</span><br><span class="line">&#123;</span><br><span class="line">    int nl = img.rows;</span><br><span class="line">    int nc = img.cols*img.channels();</span><br><span class="line">    for(int i = 0;i &lt; nl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* data = img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for(int j = 0 ; j &lt; nc;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j]/div*div + div/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//迭代器模式</span><br><span class="line">void ColorReduce(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator it = img.begin&lt;Vec3b&gt;();</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator itend = img.end&lt;Vec3b&gt;();</span><br><span class="line">for (; it != itend; it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)[0] = (*it)[0] / div * div + div / 2;</span><br><span class="line">(*it)[1] = (*it)[1] / div * div + div / 2;</span><br><span class="line">(*it)[2] = (*it)[2] / div * div + div / 2;</span><br><span class="line">&#125;</span><br><span class="line">namedWindow(&quot;dst&quot;);</span><br><span class="line">imshow(&quot;dst&quot;, img);</span><br><span class="line">&#125;</span><br><span class="line">//动态地址计算</span><br><span class="line">void colorReduce2(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">    int cols = img.cols;</span><br><span class="line">    int rows = img.rows;</span><br><span class="line">    for(int i= 0;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[0] = img.at&lt;Vec3b&gt;(i,j)[0] / div * div +div /2;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[1] = img.at&lt;Vec3b&gt;(i,j)[1] / div * div +div /2;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[2] = img.at&lt;Vec3b&gt;(i,j)[2] / div * div +div /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    Mat image = imread(argv[1]);</span><br><span class="line">    imshow(&quot;input&quot;,image);</span><br><span class="line">    colorReduce2(image,64);</span><br><span class="line">    imshow(&quot;dst&quot;,image);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    destroyAllWindows();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针操作：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//指针操作访问像素</span><br><span class="line">void colorReduce(Mat&amp; img,int div=64)</span><br><span class="line">&#123;</span><br><span class="line">    int nl = img.rows;　// 行数</span><br><span class="line">    int nc = img.cols*img.channels();//列数ｘ通道数　＝　每一行像素的个数</span><br><span class="line">    for(int i = 0;i &lt; nl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">　　　　　//Mat类提供了ｐｔｒ函数可以得到任意行的首地址，ｐｔｒ是一个模板函数</span><br><span class="line">        uchar* data = img.ptr&lt;uchar&gt;(i);　//获取第ｉ行的首地址</span><br><span class="line">        for(int j = 0 ; j &lt; nc;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j]/div*div + div/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器操作：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//迭代器模式</span><br><span class="line">void ColorReduce(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator it = img.begin&lt;Vec3b&gt;();</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator itend = img.end&lt;Vec3b&gt;();</span><br><span class="line">for (; it != itend; it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)[0] = (*it)[0] / div * div + div / 2;</span><br><span class="line">(*it)[1] = (*it)[1] / div * div + div / 2;</span><br><span class="line">(*it)[2] = (*it)[2] / div * div + div / 2;</span><br><span class="line">&#125;</span><br><span class="line">namedWindow(&quot;dst&quot;);</span><br><span class="line">imshow(&quot;dst&quot;, img);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不熟悉迭代器模式，可以阅读与ＳＴＬ中迭代器相关的资料。</p><p><strong>动态地址计算：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//动态地址计算</span><br><span class="line">void colorReduce2(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">    int cols = img.cols;　//列数</span><br><span class="line">    int rows = img.rows;　//行数</span><br><span class="line">    for(int i= 0;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j &lt; cols;j++)</span><br><span class="line">        &#123;　　//处理Ｂ蓝色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[0] = img.at&lt;Vec3b&gt;(i,j)[0] / div * div +div /2;</span><br><span class="line">　　　　　　　//处理Ｇ绿色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[1] = img.at&lt;Vec3b&gt;(i,j)[1] / div * div +div /2;</span><br><span class="line">　　　　　　　//处理Ｒ红色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[2] = img.at&lt;Vec3b&gt;(i,j)[2] / div * div +div /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于彩色图像，每个像素由三个部分：蓝色通道，绿色通道，红色通道（ＢＧＲ）。因此对于一个包含彩色图像的Ｍａｔ，会返回一个８位数组组成的向量。ＯｐｅｎＣＶ将此向量定义为Vec3b，即由usigned char 组成的向量。其访问像素通用表达式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.at&lt;Vec3b&gt;(row,col)[channel] = value;</span><br></pre></td></tr></table></figure><p>其中索引值表示通道。</p><p>这就是访问像素的三种方法，我们看一下效果：</p><p><img src="https://pic3.zhimg.com/80/v2-e27989af32f67f200762d904263dec3a_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们首先了解一下什么是像素，计算机中是如何存储图像，以及opencv是如何表示图像的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;像素&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。可以将像素视为整个图像中不可分割的单位或者是元素，不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像腐蚀</title>
    <link href="http://example.com/jsblog/7525f478.html"/>
    <id>http://example.com/jsblog/7525f478.html</id>
    <published>2020-09-05T12:59:10.000Z</published>
    <updated>2020-09-12T03:39:05.807Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来了解一下什么是腐蚀，为什么要进行图像的腐蚀。</p><p>在了解腐蚀之前我们先来了解一下结构元素</p><a id="more"></a><p>结构元素的定义如下：</p><p><strong>设有两幅图象B，X。若X是被处理的对象，而B是用来处理X的，则称B为结构元素(structure element)，又被形象地称做刷子。结构元素通常都是一些比较小的图象。</strong></p><p>接下来我们看一下腐蚀的定义：</p><p><strong>在图像的形态学操作中腐蚀就是删除对象边界的某些点的像素</strong></p><p>腐蚀的作用：</p><ul><li>边缘检测</li><li>噪声过滤</li><li>形态骨架提取</li></ul><p>其 数学表达式为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst(x,y) = min src( x + x`,y+y`) 其中 （x`,y`）: element(x`,y`) != 0</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>对Z中的集合A和B，B对A进行腐蚀的整个过程如下：</p><p>⑴ 用结构元素B，扫描图像A的每一个像素</p><p>⑵ 用结构元素与其覆盖的二值图像做“与”操作</p><p>⑶ 如果都为1，结果图像的该像素为1。否则为0</p><p>腐蚀处理的结果是使原来的二值图像减小一圈</p><p><strong>代码：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat srcImage = cv::imread(&quot;32.jpg&quot;);//read the file</span><br><span class="line">if (srcImage.empty())</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; &quot;the file does not exits!&quot; &lt;&lt; std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">//get the structure element</span><br><span class="line">cv::Mat StructElement = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));</span><br><span class="line">//defination the result</span><br><span class="line">cv::Mat result;</span><br><span class="line">//erode the image</span><br><span class="line">cv::erode(srcImage, result, StructElement);</span><br><span class="line">//show the image</span><br><span class="line">cv::namedWindow(&quot;input&quot;,cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::namedWindow(&quot;output&quot;,cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::imshow(&quot;input&quot;,srcImage);</span><br><span class="line">cv::imshow(&quot;output&quot;,result);</span><br><span class="line">cv::waitKey(0);</span><br><span class="line">cv::destroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-530ca54b72ac02361e5075f4115f75df_720w.jpg" alt="img"></p><p>​                                                                            input</p><p><img src="https://pic3.zhimg.com/80/v2-4c349f4595afb42a203213fab02c2e54_720w.jpg" alt="img"></p><p>​                                                                        output</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先我们来了解一下什么是腐蚀，为什么要进行图像的腐蚀。&lt;/p&gt;
&lt;p&gt;在了解腐蚀之前我们先来了解一下结构元素&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
