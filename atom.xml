<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-05T00:57:48.728Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective</title>
    <link href="http://example.com/jsblog/eda39db2.html"/>
    <id>http://example.com/jsblog/eda39db2.html</id>
    <published>2020-10-05T00:56:26.000Z</published>
    <updated>2020-10-05T00:57:48.728Z</updated>
    
    <content type="html"><![CDATA[<p>Effective C++</p><a id="more"></a><h3 id="1-把C-当作一个语言联邦，守则按照你使用c-的那部分而定"><a href="#1-把C-当作一个语言联邦，守则按照你使用c-的那部分而定" class="headerlink" title="1 把C++当作一个语言联邦，守则按照你使用c++的那部分而定:"></a>1 把C++当作一个语言联邦，守则按照你使用c++的那部分而定:</h3><p>​    1.C,Object-oriented C++,Template C++,STL</p><h3 id="2-尽量以const-enum-inline-替换-define"><a href="#2-尽量以const-enum-inline-替换-define" class="headerlink" title="2. 尽量以const,enum,inline 替换#define"></a>2. 尽量以const,enum,inline 替换#define</h3><p>​    1.单纯变量最好以const对象或者enum替换#define;</p><p>​    2.对于形似函数的宏（macros）,inline替换#define;</p><h3 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3.尽可能使用const"></a>3.尽可能使用const</h3><p>​    1.使用const可以帮助编译器找出错误用法，const可以施加于任何作用域内的对象;</p><p>​    2.编译器强制实施bitwise constness,但你应该使用“概念上的常量性“;</p><p>​    3.当const和non-const成员函数有着实质上的等价的时候，令non-const版本调用const版本，可以避免重复，使用const_cast移除const限制符.</p><h3 id="4-确定对象在被使用前就被初始化"><a href="#4-确定对象在被使用前就被初始化" class="headerlink" title="4.确定对象在被使用前就被初始化"></a>4.确定对象在被使用前就被初始化</h3><p>​    1.为内置对象进行手动初始化，因为C++不保证初始化他们;</p><p>​    2.构造函数最好使用成员初始化列表，而不要在构造函数中使用赋值操作。初始化列列出的成员变量，其排列次序应该和它们在类中的排列次序一样；</p><p>​    3.为避免“跨编译单元之初始化序列”问题，以local static对象代替non-local static对象.</p><h3 id="5了解c-默默编写并调用了哪些函数"><a href="#5了解c-默默编写并调用了哪些函数" class="headerlink" title="5了解c++默默编写并调用了哪些函数"></a>5了解c++默默编写并调用了哪些函数</h3><p>编译器可以暗自为class创建defalut构造函数，copy构造函数，copy assignment操作符以及析构函数</p><h3 id="6-若是不想使用编译器自动生成的函数，就该拒绝"><a href="#6-若是不想使用编译器自动生成的函数，就该拒绝" class="headerlink" title="6.若是不想使用编译器自动生成的函数，就该拒绝"></a>6.若是不想使用编译器自动生成的函数，就该拒绝</h3><p>​    不想让编译器自动提供函数，可将相应的成员函数声明为private并且不予实现。</p><h3 id="7-为多态类型基类声明virtual析构函数"><a href="#7-为多态类型基类声明virtual析构函数" class="headerlink" title="7. 为多态类型基类声明virtual析构函数"></a>7. 为多态类型基类声明virtual析构函数</h3><p>多态基类应该声明一个virtual函数。如果class带有任何virtual函数，它就应该有一个virtual析构函数</p><p>如果class不是作为基类，或不具有多态性质，那么就不应该声明virtual析构函数</p><h3 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8.别让异常逃离析构函数"></a>8.别让异常逃离析构函数</h3><h3 id="9-绝不在析构函数和构造函数中调用virtual函数"><a href="#9-绝不在析构函数和构造函数中调用virtual函数" class="headerlink" title="9.绝不在析构函数和构造函数中调用virtual函数"></a>9.绝不在析构函数和构造函数中调用virtual函数</h3><h3 id="10令operator-返回一个reference-to-this"><a href="#10令operator-返回一个reference-to-this" class="headerlink" title="10令operator= 返回一个reference to *this"></a>10令operator= 返回一个reference to *this</h3><h3 id="11在operator-中处理“自我赋值“"><a href="#11在operator-中处理“自我赋值“" class="headerlink" title="11在operator= 中处理“自我赋值“"></a>11在operator= 中处理“自我赋值“</h3><h3 id="12复制对象时勿忘其每一个成分"><a href="#12复制对象时勿忘其每一个成分" class="headerlink" title="12复制对象时勿忘其每一个成分"></a>12复制对象时勿忘其每一个成分</h3><h3 id="13使用对象管理资源"><a href="#13使用对象管理资源" class="headerlink" title="13使用对象管理资源"></a>13使用对象管理资源</h3><h3 id="14在资源管理类中小心copy函数"><a href="#14在资源管理类中小心copy函数" class="headerlink" title="14在资源管理类中小心copy函数"></a>14在资源管理类中小心copy函数</h3><h3 id="15在资源管理类中提供对原始资源的访问"><a href="#15在资源管理类中提供对原始资源的访问" class="headerlink" title="15在资源管理类中提供对原始资源的访问:"></a>15在资源管理类中提供对原始资源的访问:</h3><h3 id="16成对使用new和delete时要采取相同的形式："><a href="#16成对使用new和delete时要采取相同的形式：" class="headerlink" title="16成对使用new和delete时要采取相同的形式："></a>16成对使用new和delete时要采取相同的形式：</h3><p>如果在new中使用[]，则必须在对应的delete使用[],如果在new中没有使用[],则一定不要在delete中使用[]</p><h3 id="17以独立语句将newed对象置入智能指针"><a href="#17以独立语句将newed对象置入智能指针" class="headerlink" title="17以独立语句将newed对象置入智能指针"></a>17以独立语句将newed对象置入智能指针</h3><h3 id="18-让接口容易被使用而不易被误用"><a href="#18-让接口容易被使用而不易被误用" class="headerlink" title="18 让接口容易被使用而不易被误用"></a>18 让接口容易被使用而不易被误用</h3><h3 id="19-设计class犹如设计type"><a href="#19-设计class犹如设计type" class="headerlink" title="19 设计class犹如设计type"></a>19 设计class犹如设计type</h3><h3 id="20-尽量以pass-by-reference-const-代替pass-by-value"><a href="#20-尽量以pass-by-reference-const-代替pass-by-value" class="headerlink" title="20 尽量以pass by reference const 代替pass by value"></a>20 尽量以pass by reference const 代替pass by value</h3><p>对于内置类型以及STL的迭代器和函数对象不适用</p><h3 id="21必须返回对象时，别妄想返回其reference"><a href="#21必须返回对象时，别妄想返回其reference" class="headerlink" title="21必须返回对象时，别妄想返回其reference"></a>21必须返回对象时，别妄想返回其reference</h3><h3 id="22-将成员变量声明为private"><a href="#22-将成员变量声明为private" class="headerlink" title="22 将成员变量声明为private"></a>22 将成员变量声明为private</h3><h3 id="23-宁以non-member、non-friend替换member函数"><a href="#23-宁以non-member、non-friend替换member函数" class="headerlink" title="23 宁以non-member、non-friend替换member函数"></a>23 宁以non-member、non-friend替换member函数</h3><h3 id="24-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24 若所有参数皆需类型转换，请为此采用non-member函数"></a>24 若所有参数皆需类型转换，请为此采用non-member函数</h3><h3 id="25-实现一个不抛出异常的swap函数"><a href="#25-实现一个不抛出异常的swap函数" class="headerlink" title="25 实现一个不抛出异常的swap函数"></a>25 实现一个不抛出异常的swap函数</h3><h3 id="26-尽可能延后变量定义的时间"><a href="#26-尽可能延后变量定义的时间" class="headerlink" title="26 尽可能延后变量定义的时间"></a>26 尽可能延后变量定义的时间</h3><h3 id="27-尽量少做转型动作"><a href="#27-尽量少做转型动作" class="headerlink" title="27 尽量少做转型动作"></a>27 尽量少做转型动作</h3><h3 id="28-避免返回handles指向对象内部成分"><a href="#28-避免返回handles指向对象内部成分" class="headerlink" title="28 避免返回handles指向对象内部成分"></a>28 避免返回handles指向对象内部成分</h3><h3 id="29-为异常安全努力是值得的"><a href="#29-为异常安全努力是值得的" class="headerlink" title="29 为异常安全努力是值得的"></a>29 为异常安全努力是值得的</h3><h3 id="30-彻底了解inline的里里外外"><a href="#30-彻底了解inline的里里外外" class="headerlink" title="30 彻底了解inline的里里外外"></a>30 彻底了解inline的里里外外</h3><h3 id="31-将文件间的编译依存关系降到最低"><a href="#31-将文件间的编译依存关系降到最低" class="headerlink" title="31 将文件间的编译依存关系降到最低"></a>31 将文件间的编译依存关系降到最低</h3><h3 id="32-确定你的public继承塑模出is-a关系"><a href="#32-确定你的public继承塑模出is-a关系" class="headerlink" title="32 确定你的public继承塑模出is-a关系"></a>32 确定你的public继承塑模出is-a关系</h3><h3 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33 避免遮掩继承而来的名称"></a>33 避免遮掩继承而来的名称</h3><h3 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34 区分接口继承和实现继承"></a>34 区分接口继承和实现继承</h3><h3 id="35-考虑virtual函数以外的其他选择"><a href="#35-考虑virtual函数以外的其他选择" class="headerlink" title="35 考虑virtual函数以外的其他选择"></a>35 考虑virtual函数以外的其他选择</h3><h3 id="36-绝不重新定义继承而来的non-virtual函数"><a href="#36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36 绝不重新定义继承而来的non-virtual函数"></a>36 绝不重新定义继承而来的non-virtual函数</h3><h3 id="37-绝不重新定义继承而来的缺省参数值"><a href="#37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="37 绝不重新定义继承而来的缺省参数值"></a>37 绝不重新定义继承而来的缺省参数值</h3><h3 id="38-通过复合塑模出has-a或“根据某物实现出”"><a href="#38-通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="38 通过复合塑模出has-a或“根据某物实现出”"></a>38 通过复合塑模出has-a或“根据某物实现出”</h3><h3 id="39-明智而审慎地使用private继承"><a href="#39-明智而审慎地使用private继承" class="headerlink" title="39 明智而审慎地使用private继承"></a>39 明智而审慎地使用private继承</h3><h3 id="40-明智而审慎地使用多重继承"><a href="#40-明智而审慎地使用多重继承" class="headerlink" title="40 明智而审慎地使用多重继承"></a>40 明智而审慎地使用多重继承</h3><h3 id="41-了解隐式接口和编译期多态"><a href="#41-了解隐式接口和编译期多态" class="headerlink" title="41 了解隐式接口和编译期多态"></a>41 了解隐式接口和编译期多态</h3><h3 id="42-了解typename的双重意义"><a href="#42-了解typename的双重意义" class="headerlink" title="42 了解typename的双重意义"></a>42 了解typename的双重意义</h3><h3 id="43-学习处理模板化基类的名称"><a href="#43-学习处理模板化基类的名称" class="headerlink" title="43 学习处理模板化基类的名称"></a>43 学习处理模板化基类的名称</h3><h3 id="44-将与参数无关的代码抽离"><a href="#44-将与参数无关的代码抽离" class="headerlink" title="44 将与参数无关的代码抽离"></a>44 将与参数无关的代码抽离</h3><h3 id="45-运用成员函数模板接受所有兼容类型"><a href="#45-运用成员函数模板接受所有兼容类型" class="headerlink" title="45 运用成员函数模板接受所有兼容类型"></a>45 运用成员函数模板接受所有兼容类型</h3><h3 id="46-需要类型转换时请为模板定义非成员函数"><a href="#46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="46 需要类型转换时请为模板定义非成员函数"></a>46 需要类型转换时请为模板定义非成员函数</h3><h3 id="47-使用traits-classes表现类型信息"><a href="#47-使用traits-classes表现类型信息" class="headerlink" title="47 使用traits classes表现类型信息"></a>47 使用traits classes表现类型信息</h3><h3 id="48-认识template元编程"><a href="#48-认识template元编程" class="headerlink" title="48 认识template元编程"></a>48 认识template元编程</h3><h3 id="49-了解new-handler的行为"><a href="#49-了解new-handler的行为" class="headerlink" title="49 了解new-handler的行为"></a>49 了解new-handler的行为</h3><h3 id="50-了解delete和new的合理替换时机"><a href="#50-了解delete和new的合理替换时机" class="headerlink" title="50 了解delete和new的合理替换时机"></a>50 了解delete和new的合理替换时机</h3><h3 id="51-编写new和delete时需要固守的常规"><a href="#51-编写new和delete时需要固守的常规" class="headerlink" title="51 编写new和delete时需要固守的常规"></a>51 编写new和delete时需要固守的常规</h3><h3 id="52-写了placement-new也要写placement-delete"><a href="#52-写了placement-new也要写placement-delete" class="headerlink" title="52 写了placement new也要写placement delete"></a>52 写了placement new也要写placement delete</h3><h3 id="53-不要忽略编译器的警告"><a href="#53-不要忽略编译器的警告" class="headerlink" title="53 不要忽略编译器的警告"></a>53 不要忽略编译器的警告</h3><h3 id="54-让自己熟悉标准库程序"><a href="#54-让自己熟悉标准库程序" class="headerlink" title="54 让自己熟悉标准库程序"></a>54 让自己熟悉标准库程序</h3><h3 id="55-让自己熟悉Boost"><a href="#55-让自己熟悉Boost" class="headerlink" title="55 让自己熟悉Boost"></a>55 让自己熟悉Boost</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Effective C++&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Hist</title>
    <link href="http://example.com/jsblog/6b98c071.html"/>
    <id>http://example.com/jsblog/6b98c071.html</id>
    <published>2020-09-22T14:13:06.000Z</published>
    <updated>2020-09-22T14:16:15.479Z</updated>
    
    <content type="html"><![CDATA[<p>图像直方图包含图像的丰富的信息，反应了图像像素的概率分布情况。<a id="more"></a>对于灰度图像f(x,y),</p><p><img src="https://www.zhihu.com/equation?tex=r_%7Bk%7D" alt="[公式]"> 表示灰度级k出现的频率，则灰度级k像素点出现的概率为：</p><p><img src="https://pic1.zhimg.com/80/v2-b81167a1a249d4f2355588771accddc0_720w.jpg" alt="img"></p><p>其中N是所有的灰度级数，r是图像中得所有像素数，对概率分布 <img src="https://www.zhihu.com/equation?tex=p(k)" alt="[公式]"> 进行累计求和便得到累计归一化直方图 ：</p><p><img src="https://pic1.zhimg.com/80/v2-9189dcb38e96e65677f6acbadf60414b_720w.png" alt="img"></p><p>灰度直方图用来描述各个灰度级像素个数出现的频率，灰度直方图的横坐标为灰度级数，从坐标则表示该灰度级出现的频率。对于灰度级范围在[0,N-1]的图像，直方图可表示为 <img src="https://www.zhihu.com/equation?tex=H(r_%7Bk%7D)=S_%7Bk%7D" alt="[公式]"> ,对于灰度图像，其256级灰度图像可以变换到0-255。opencv中提供了一个计算灰度级直方图的函数，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="keyword">void</span> <span class="title">cv::calcHist</span><span class="params">(<span class="keyword">const</span> Mat *images,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> nimages,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">int</span>* channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                     InputArray mask,</span></span></span><br><span class="line"><span class="function"><span class="params">                     OutputArray hist,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> dims,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">int</span>* histSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">float</span>* ranges,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">bool</span> uniform = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">bool</span> accumulate =<span class="literal">false</span>)</span></span></span><br><span class="line">2）void cv::calcHist(const Mat *images,</span><br><span class="line">                     <span class="keyword">int</span> nimages,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">int</span>* channels,</span><br><span class="line">                     InputArray mask,</span><br><span class="line">                     SparseMat&amp; hist,</span><br><span class="line">                     <span class="keyword">int</span> dims,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">int</span>* histSize,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">float</span>* ranges,</span><br><span class="line">                     <span class="keyword">bool</span> uniform = <span class="literal">true</span>,</span><br><span class="line">                     <span class="keyword">bool</span> accumulate =<span class="literal">false</span>)</span><br><span class="line"><span class="number">3</span>）<span class="keyword">void</span> cv::calcHist(InputArrayOfArrays Images,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; channels,</span><br><span class="line">                     InputArray mask,</span><br><span class="line">                     OutputArray hist,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; histSize,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ranges,</span><br><span class="line">                     <span class="keyword">bool</span> accumulate = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>参数说明：<br>images : 表示图像列表，这些图像必须有相同的深度信息CV_8U,CV_16U或者CV_32F,并且这些图像的大小相同，这些图像可以有任意的通道数量。</p><p>nimages : 表示输入源的图像个数；</p><p>channels : 表示需要统计的图像通道索引</p><p>mask:可选掩码，如果图像不为空，则此参数必须为8位且和图像大小相同，掩码中的非零元素标记需要在直方图中计算的数组元素；</p><p>hist :输出计算得到的直方图，是一个密集或者稀疏矩阵；</p><p>dims:输出的直方图的维度，灰度为1，彩色为3，在opencv中最大为32即CV_MAX_DIMS;</p><p>histSize:直方图横坐标的区间数，支出直方图每一维大小的数组</p><p>ranges:用于住处直方图中得每一个bin的上下界的浮动范围数组的数组，对于均匀直方图而言，该数组只有两个元素；</p><p>uniform: 直方图是否均匀的标志；</p><p>accumulate: 累计标志，用于标志是否清除开始计算时直方图累计的标志。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理图像</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; bgr_channels;</span><br><span class="line">    cv::split(srcImage,bgr_channels);</span><br><span class="line">    <span class="comment">//定义直方图参数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> channels[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> histSize[<span class="number">1</span>] = &#123;<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> preranges[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> *ranges[<span class="number">1</span>] = &#123;preranges&#125;;</span><br><span class="line">    cv::MatND b_hist,g_hist,r_hist;</span><br><span class="line">    <span class="comment">//calchist</span></span><br><span class="line">    cv::calcHist(&amp;bgr_channels[<span class="number">0</span>],<span class="number">1</span>,channels,cv::Mat(),b_hist,<span class="number">1</span>,histSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::calcHist(&amp;bgr_channels[<span class="number">1</span>],<span class="number">1</span>,channels,cv::Mat(),g_hist,<span class="number">1</span>,histSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::calcHist(&amp;bgr_channels[<span class="number">2</span>],<span class="number">1</span>,channels,cv::Mat(),r_hist,<span class="number">1</span>,histSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//画出直方图</span></span><br><span class="line">    <span class="keyword">int</span> hist_w = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> hist_h = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> nHistSize = <span class="number">256</span>;</span><br><span class="line">    <span class="comment">//ranges</span></span><br><span class="line">    <span class="keyword">int</span> bin_w = cvRound((<span class="keyword">double</span>)hist_w/nHistSize);</span><br><span class="line">    <span class="function">cv::Mat <span class="title">histImage</span><span class="params">(hist_w,hist_h,CV_8UC3,cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">    cv::normalize(b_hist,b_hist,<span class="number">0</span>,histImage.rows,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line">    cv::normalize(g_hist,g_hist,<span class="number">0</span>,histImage.rows,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line">    cv::normalize(r_hist,r_hist,<span class="number">0</span>,histImage.rows,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line">    <span class="comment">//dims</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; nHistSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::line(histImage,cv::Point(bin_w*(i<span class="number">-1</span>),hist_h - cvRound(b_hist.at&lt;<span class="keyword">float</span>&gt;(i<span class="number">-1</span>))),</span><br><span class="line">                  cv::Point(bin_w*(i),hist_h - cvRound(b_hist.at&lt;<span class="keyword">float</span>&gt;(i))),</span><br><span class="line">                  cv::Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">        cv::line(histImage,cv::Point(bin_w*(i<span class="number">-1</span>),hist_h - cvRound(g_hist.at&lt;<span class="keyword">float</span>&gt;(i<span class="number">-1</span>))),</span><br><span class="line">                  cv::Point(bin_w*(i),hist_h - cvRound(g_hist.at&lt;<span class="keyword">float</span>&gt;(i))),</span><br><span class="line">                  cv::Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">        cv::line(histImage,cv::Point(bin_w*(i<span class="number">-1</span>),hist_h - cvRound(r_hist.at&lt;<span class="keyword">float</span>&gt;(i<span class="number">-1</span>))),</span><br><span class="line">                  cv::Point(bin_w*(i),hist_h - cvRound(r_hist.at&lt;<span class="keyword">float</span>&gt;(i))),</span><br><span class="line">                  cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::imshow(<span class="string">&quot;hist&quot;</span>,histImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://pic1.zhimg.com/80/v2-9b9695c19de8b1e38f4b8bb3b6fd592b_720w.jpg" alt="img"></p><p><img src="https://picb.zhimg.com/80/v2-7c4814becd4d7892e7d46c9e8f82bf2e_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像直方图包含图像的丰富的信息，反应了图像像素的概率分布情况。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>仿射变换</title>
    <link href="http://example.com/jsblog/ff4ee780.html"/>
    <id>http://example.com/jsblog/ff4ee780.html</id>
    <published>2020-09-14T12:58:36.000Z</published>
    <updated>2020-09-14T12:59:26.405Z</updated>
    
    <content type="html"><![CDATA[<p>图像的仿射变换是将图像的二维坐标从一个直角坐标系中变换到另外一个直角坐标系中的二维坐标的过程。<a id="more"></a>图像的仿射变换是一种线性的变换，可以表示为矩阵相乘。仿射变换主要用来实现图像的缩放，平移，旋转以及翻转，剪切等几何操作。</p><p>假设在空间中图像的原始坐标为（x,y）经过仿射变换后的目标坐标为（x’,y’），常见的变换形式有以下几种：</p><p>缩放：</p><p><img src="https://pic1.zhimg.com/80/v2-81c3239ee1cf1317c4c4f95d89f45dbc_720w.png" alt="img"></p><p>平移：</p><p><img src="https://pic3.zhimg.com/80/v2-2c6d07b030b2d87b9092bf1d43b51cdb_720w.png" alt="img"></p><p>翻转：</p><p><img src="https://pic2.zhimg.com/80/v2-91bc5a6285c820828fb8de61e126d057_720w.png" alt="img"></p><p>旋转：</p><p><img src="https://pic1.zhimg.com/80/v2-1990168441045f086faf437fc007b764_720w.jpg" alt="img"></p><p>所有的仿射变换都是一种线性的变换，都可以使用矩阵的形式来表达，对于图像的平移变换都可以使用下面矩阵乘法的形式表示：</p><p><img src="https://pic3.zhimg.com/80/v2-dc8d53a22aae8fcaaea09a12c73716ad_720w.jpg" alt="img"></p><p>在opencv中构造变换矩阵通常是构造成2x3的矩阵即：</p><p><img src="https://pic2.zhimg.com/80/v2-05efd5703d3aa1783007722a9771996b_720w.jpg" alt="img"></p><p>对于平移操作构造的矩阵为：</p><p><img src="https://pic3.zhimg.com/80/v2-fbc4c860ce42defa58de5106154c867e_720w.png" alt="img"></p><p>对于缩放而言，水平缩放因子为a,竖直缩放因子为b,则M矩阵为：</p><p><img src="https://picb.zhimg.com/80/v2-464400236aeecac42e6e58473dde0a78_720w.png" alt="img"></p><p>对于旋转而言，旋转角为θ时，则M矩阵为：</p><p><img src="https://pic1.zhimg.com/80/v2-c6bd1b2149c602dbbbbf373812ff5dca_720w.jpg" alt="img"></p><p>在看代码之前首先看一下warpAffine函数，函数原型如下：</p><p>Cv::warpAffine(InputArray src,</p><p>OutputArray dst,</p><p>InputArray M,</p><p>Size dsize,</p><p>int flas =INTER_LINEAR,</p><p>int borderMode = BORDER_CONSTANT,</p><p>const Scalar&amp; borderValue = Scalar()</p><p>);</p><p>其使用的公式是</p><p><img src="https://pic4.zhimg.com/80/v2-722f53e6d3c192a9f16d52db131e7caa_720w.png" alt="img"></p><p>其参数：</p><p>src : 输入图像</p><p>dst : 输出图像，大小类型和src一样</p><p>M ：2x3大小的变换矩阵</p><p>dsize : 输出图像的大小</p><p>flags : 插值算法标志，如果结合使用WARO_INVERSE_MAP，表示仿射变换逆运算即（dst-&gt;src）</p><p>borderMode: 边界插值类型</p><p>borderValue :表示边界插值数据。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cv::Mat <span class="title">getRotationMatrix</span><span class="params">(cv::Point center,<span class="keyword">double</span> angle,<span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    center : the center point of transform</span></span><br><span class="line"><span class="comment">    angle  : the angle of rotation</span></span><br><span class="line"><span class="comment">    scake  : the scale of zoom</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    angle *= CV_PI / <span class="number">180</span> ;<span class="comment">//angle to rad</span></span><br><span class="line">    <span class="keyword">double</span> alpha = scale * <span class="built_in">cos</span>(angle);</span><br><span class="line">    <span class="keyword">double</span> beta =  scale * <span class="built_in">sin</span>(angle);</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">Matrix</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>,CV_64F)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> *m = (<span class="keyword">double</span>*)Matrix.data;</span><br><span class="line">    m[<span class="number">0</span>] = alpha;</span><br><span class="line">    m[<span class="number">1</span>] = beta;</span><br><span class="line">    m[<span class="number">2</span>] = (<span class="number">1</span> - alpha) * center.x - beta * center.y;</span><br><span class="line">    m[<span class="number">3</span>] = -beta;</span><br><span class="line">    m[<span class="number">4</span>] = alpha;</span><br><span class="line">    m[<span class="number">5</span>] = beta * center.x + (<span class="number">1</span>-alpha) * center.y;</span><br><span class="line">    <span class="keyword">return</span> Matrix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Point <span class="title">center</span><span class="params">(srcImage.rows/<span class="number">2</span>,srcImage.cols / <span class="number">2</span>)</span></span>;</span><br><span class="line">    cv::Mat Mask = getRotationMatrix(center,<span class="number">60</span>,<span class="number">1.0</span>);</span><br><span class="line">    <span class="function">cv::Mat <span class="title">dstImage</span><span class="params">(srcImage.size() ,srcImage.type())</span></span>;</span><br><span class="line">    cv::warpAffine(srcImage,dstImage,Mask,dstImage.size());</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;dst&quot;</span>,dstImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入图像为：</p><p><img src="https://pic3.zhimg.com/80/v2-357dcb4e264811372436c2f3dfc2bf2c_720w.jpg" alt="img"></p><p>输出图像为：</p><p><img src="https://pic2.zhimg.com/80/v2-e4b8598c7dd6c00d66bed4d94add7650_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像的仿射变换是将图像的二维坐标从一个直角坐标系中变换到另外一个直角坐标系中的二维坐标的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>rotation</title>
    <link href="http://example.com/jsblog/297c98f1.html"/>
    <id>http://example.com/jsblog/297c98f1.html</id>
    <published>2020-09-13T13:53:56.000Z</published>
    <updated>2020-09-13T13:56:22.474Z</updated>
    
    <content type="html"><![CDATA[<p>图像旋转是指图像按照某一点转动一定的角度的过程，旋转过程中图像的原始大小并不改变。<a id="more"></a></p><p>图像旋转后图像的对称轴以及中心坐标原点都有可能会发生变化，因此需要对图像旋转中得坐标进行相应的变换。图像的坐标系是由X轴水平向右，Y轴竖直向下构成。</p><p>假设图像旋转中心的坐标为（Cx,Cy）,原始图像数据的坐标为（x,y）,旋转后目标图像的坐标为（x1,y1）。变换后的坐标形式是X轴正方向水平向右，y轴正方向竖直向上。在进行旋转之前要把坐标原点由图像的左上方变换到旋转中心。旋转坐标的矩阵形式为：</p><p><img src="https://pic3.zhimg.com/80/v2-43ecb0899b4151ffe00ad8f71dd763f6_720w.jpg" alt="img"></p><p>在极坐标情况下，顺时针旋转θ，根据坐标变换公式可得：</p><p><img src="https://picb.zhimg.com/80/v2-a36d9c463df6c848b34f07ba52b67673_720w.png" alt="img"></p><p>矩阵表达形式为：</p><p><img src="https://pic2.zhimg.com/80/v2-efec0fc330cdacd05c4c55fa9174e10c_720w.jpg" alt="img"></p><p>在旋转完成之后，需要将旋转中心的坐标变换到以左上角为原点的坐标系中。在变换之前要找到变换后图像的极值点，这些极值点用来确定图像的尺寸大小。找到了这些极值点也需要用来完成旋转中心的坐标变换。假设这些极值点中最上方的极值点为Ymax,最下方的极值点为Ymin,水平方向最左边的极值点为Xmin,最右边的极值点为Xmax。则旋转中心变换到原坐标系中得坐标变换矩阵形式如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9972153d3c06ac736d366b24f6f7890c_720w.jpg" alt="img"></p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cos</span>;</span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageRotation</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; srcImage,cv::Mat&amp; dstImage,<span class="keyword">double</span> angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    srcImage : Input Image</span></span><br><span class="line"><span class="comment">    dstImage : output Image</span></span><br><span class="line"><span class="comment">    angle    : the angle of rotation</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//step1 将角度转换为弧度</span></span><br><span class="line">    <span class="keyword">double</span> alpha = angle * CV_PI / <span class="number">180</span>;</span><br><span class="line">    <span class="comment">//构造旋转矩阵</span></span><br><span class="line">    <span class="keyword">float</span> rotationMat[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="built_in">cos</span>(alpha),-<span class="built_in">sin</span>(alpha),<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="built_in">sin</span>(alpha),<span class="built_in">cos</span>(alpha),<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//计算各个顶点的位置</span></span><br><span class="line">    <span class="keyword">int</span> nSrcRows = srcImage.rows;</span><br><span class="line">    <span class="keyword">int</span> nSrcCols = srcImage.cols;</span><br><span class="line">    <span class="keyword">float</span> x1 = nSrcCols * rotationMat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">float</span> y1 = nSrcCols * rotationMat[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">float</span> x2 = nSrcCols * rotationMat[<span class="number">0</span>][<span class="number">0</span>] + nSrcRows * rotationMat[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">float</span> y2 = nSrcCols * rotationMat[<span class="number">1</span>][<span class="number">0</span>] + nSrcRows * rotationMat[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">float</span> x3 = nSrcRows * rotationMat[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">float</span> y3 = nSrcRows * rotationMat[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//求极值点</span></span><br><span class="line">    <span class="keyword">float</span> xmin = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(<span class="built_in">std</span>::min(<span class="number">0.0f</span>,x1),x2),x3);</span><br><span class="line">    <span class="keyword">float</span> xmax = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(<span class="built_in">std</span>::max(<span class="number">0.0f</span>,x1),x2),x3);</span><br><span class="line">    <span class="keyword">float</span> ymin = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(<span class="built_in">std</span>::min(<span class="number">0.0f</span>,y1),y2),y3);</span><br><span class="line">    <span class="keyword">float</span> ymax = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(<span class="built_in">std</span>::max(<span class="number">0.0f</span>,y1),y2),y3);</span><br><span class="line">    <span class="comment">//计算目标图像的大小</span></span><br><span class="line">    <span class="keyword">int</span> nRows = cvRound(ymax - ymin);</span><br><span class="line">    <span class="keyword">int</span> nCols = cvRound(xmax - xmin);</span><br><span class="line">    dstImage.create(nRows,nCols,srcImage.type());</span><br><span class="line">    <span class="comment">//计算旋转后的像素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; nCols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (j + xmin) * rotationMat[<span class="number">0</span>][<span class="number">0</span>] - (i + ymin) * rotationMat[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> y = -(j + xmin) * rotationMat[<span class="number">1</span>][<span class="number">0</span>] + (i + ymin) * rotationMat[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; nSrcCols &amp;&amp; y &lt; nSrcRows)</span><br><span class="line">            &#123;</span><br><span class="line">                dstImage.at&lt;cv::Vec3b&gt;(i,j) = srcImage.at&lt;cv::Vec3b&gt;(y,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    ImageRotation(srcImage,dstImage,<span class="number">60</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;src&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;dst1&quot;</span>,dstImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入图像：</p><p><img src="https://pic4.zhimg.com/80/v2-9afaa9adc1b18dc13ad0a3d635049d2f_720w.jpg" alt="img"></p><p>输出图像（旋转60°）：</p><p><img src="https://picb.zhimg.com/80/v2-35a41444e401bfb8a475f38aab2580a6_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像旋转是指图像按照某一点转动一定的角度的过程，旋转过程中图像的原始大小并不改变。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>reduction</title>
    <link href="http://example.com/jsblog/b1e75468.html"/>
    <id>http://example.com/jsblog/b1e75468.html</id>
    <published>2020-09-13T06:38:43.000Z</published>
    <updated>2020-09-13T06:41:41.415Z</updated>
    
    <content type="html"><![CDATA[<p>图像缩放是指图像的尺寸变小或者变大的过程。<a id="more"></a></p><p>图像缩放实际上就是增加或者减少原图像数据的像素的个数。图像缩放可能会造成信息的丢失。需要选择合适的缩放方法进行操作。图像的缩放过程涉及到采样和插值。</p><p>一般有以下两种方法：</p><ol><li>基于等间隔提取图像像素的缩放</li></ol><p>基于等间隔提取图像像素的缩放是对原始图像进行均匀采样来完成的。对于原始图像像素数据<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img">,其图像大小为**<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img">,<strong>如果想要将这幅图像的大小改变为</strong><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img">**。使用等间隔采样，宽度缩放系数为：<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img">,高度缩放系数为：<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img">。对于图像，图像缩放在其水平方向的等间隔采样为<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="img">，在垂直方向上的等间隔采样为<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img">。若<img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png" alt="img">就表示原图像要等比例缩放，否则原图像则会发生扭曲现象。缩放的矩阵表示如下：</p><p><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png" alt="img"></p><p>\2.  基于区域子块提取图像缩放</p><p>提取区域子块图像缩放是通过对原图像进行区域子块划分，然后提取子块中像素值作为采样像素用来作为目标图像的像素。提取子块的像素的方法通常是提取块像素中得中值或者计算块像素的平均值。对于子块的划分其实就是对于矩阵的划分，划分子块的方法有很多种，常用的方法就是根据缩放系数提取和自适应因子提取子块。例如对于src(x,y)为 4x4的矩阵，如果目标矩阵为2x2，那么可以按照矩阵的子块划分，然后求每个分块矩阵的均值或者矩阵中得中值作为目标矩阵的一个元素。原始矩阵如下：</p><p><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png" alt="img"></p><p>目标矩阵dst(x,y) 为：</p><p><img src="file:///C:/Users/JSL/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png" alt="img"></p><p>则A11 应为a11,a12,a21,a22的均值或者中值。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    argc : the size of argv[]</span></span><br><span class="line"><span class="comment">    argv : the parameters of comdline</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageReduction</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; src_,cv::Mat&amp; dst_,<span class="keyword">float</span> kx,<span class="keyword">float</span> ky)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src_ : the source image</span></span><br><span class="line"><span class="comment">    det_ : the destination  image</span></span><br><span class="line"><span class="comment">    kx   : the Scale factor in horizon</span></span><br><span class="line"><span class="comment">    ky   : the Scale factor in vertical</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> nRows = cvRound(src_.rows * kx);</span><br><span class="line">    <span class="keyword">int</span> nCols = cvRound(src_.cols * ky);</span><br><span class="line">    dst_ = cv::Mat(nRows,nCols,src_.type());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; nCols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((i+<span class="number">1</span>) / kx + <span class="number">0.5</span>) <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((j+<span class="number">1</span>) / ky + <span class="number">0.5</span>) <span class="number">-1</span>;</span><br><span class="line">            dst_.at&lt;cv::Vec3b&gt;(i,j) = src_.at&lt;cv::Vec3b&gt;(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cv::Vec3b <span class="title">AverOfMat</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; srcImage,cv::Point_&lt;<span class="keyword">int</span>&gt; left,cv::Point_&lt;<span class="keyword">int</span>&gt; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    srcImage: the source of Image</span></span><br><span class="line"><span class="comment">    lef      :  the left point of child block of source Image</span></span><br><span class="line"><span class="comment">    right    : the right point of child block of source Image</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//计算像素点的个数</span></span><br><span class="line">    <span class="keyword">int</span> nPixels = (right.x - left.x + <span class="number">1</span>) * (right.y - left.y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> temp0 = <span class="number">0</span>,temp1 = <span class="number">0</span>,temp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left.x;i&lt;= right.x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=left.y;j &lt;= right.y;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp0 += srcImage.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">0</span>];</span><br><span class="line">            temp1 += srcImage.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">1</span>];</span><br><span class="line">            temp2 += srcImage.at&lt;cv::Vec3b&gt;(i,j)[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个通道求平均值</span></span><br><span class="line">    cv::Vec3b resVec;</span><br><span class="line">    resVec[<span class="number">0</span>] = temp0 / nPixels;</span><br><span class="line">    resVec[<span class="number">1</span>] = temp1 / nPixels;</span><br><span class="line">    resVec[<span class="number">2</span>] = temp2 / nPixels;</span><br><span class="line">    <span class="keyword">return</span> resVec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageReduction1</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; src_,cv::Mat&amp; dst_,<span class="keyword">float</span> kx,<span class="keyword">float</span> ky)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src_ : the source image</span></span><br><span class="line"><span class="comment">    det_ : the destination  image</span></span><br><span class="line"><span class="comment">    kx   : the Scale factor in horizon</span></span><br><span class="line"><span class="comment">    ky   : the Scale factor in vertical</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> nRows = cvRound(src_.rows * kx);</span><br><span class="line">    <span class="keyword">int</span> nCols = cvRound(src_.cols * ky);</span><br><span class="line">    dst_ = cv::Mat(nRows,nCols,src_.type());</span><br><span class="line">    <span class="comment">//图像子区域的左上角</span></span><br><span class="line">    <span class="keyword">int</span> leftRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LeftCol = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nRows;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; ((i + <span class="number">1</span>) / kx + <span class="number">0.5</span>) - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; nCols;++j)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; ((j + <span class="number">1</span>) / ky + <span class="number">0.5</span>) - <span class="number">1</span>;</span><br><span class="line">            dst_.at&lt;cv::Vec3b&gt;(i,j) = AverOfMat(src_,cv::Point_&lt;<span class="keyword">int</span>&gt;(leftRow,LeftCol),cv::Point_&lt;<span class="keyword">int</span>&gt;(x,y));</span><br><span class="line">            LeftCol = y + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       leftRow = x + <span class="number">1</span>;</span><br><span class="line">       LeftCol = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ImageFilePath = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(ImageFilePath);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat dstImage;</span><br><span class="line">    cv::Mat dstImage2;</span><br><span class="line">    ImageReduction(srcImage,dstImage,<span class="number">0.4</span>,<span class="number">0.4</span>);</span><br><span class="line">    ImageReduction1(srcImage,dstImage2,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;src&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;dst1&quot;</span>,dstImage);</span><br><span class="line">     cv::imshow(<span class="string">&quot;dst2&quot;</span>,dstImage2);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入图像为：</p><p><img src="https://picb.zhimg.com/80/v2-4368c921c5dd35c8c6a46e4a133e6f72_720w.jpg" alt="img"></p><p>输出图像1（等间隔采样）：</p><p><img src="https://picb.zhimg.com/80/v2-d1259b02021a0d5b65aa3688a5aa3fbf_720w.jpg" alt="img"></p><p>输出图像2（基于区域子块采样）：</p><p><img src="https://pic3.zhimg.com/80/v2-502cbe18e90de4c7385e579d059e18ae_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像缩放是指图像的尺寸变小或者变大的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>translation</title>
    <link href="http://example.com/jsblog/b469456f.html"/>
    <id>http://example.com/jsblog/b469456f.html</id>
    <published>2020-09-13T01:09:02.000Z</published>
    <updated>2020-09-13T01:09:40.508Z</updated>
    
    <content type="html"><![CDATA[<p>图像的平移操作是将图像按照水平方向或者垂直方向平移。</p><a id="more"></a><p>图像的平移操作实际上是将所有像素按照x轴或者y轴放向移动。图像的平移变换分为：图像大小不改变的平移变换和图像大小改变的平移变换。图像大小不改变的平移变换可能导致部分图像信息丢失，而图像大小变化则拥有完整的图像信息。</p><p>对于图像的变换，其公式主要是：</p><p><img src="https://pic3.zhimg.com/80/v2-91c8b350a518ae14c2971fccfaed4d16_720w.png" alt="img"></p><p>目标坐标点（x1,y1）由（x,y）通过平移得到。</p><p>对于矩阵形式的变换，其变换矩阵如下：</p><p><img src="https://pic2.zhimg.com/80/v2-582df7b83782cfb8e71a506b6b560569_720w.jpg" alt="img"></p><p>对于目标图像，可以进行逆变换进行反向平移，变换矩阵如下：</p><p><img src="https://picb.zhimg.com/80/v2-fe5b42c12bc138f3a7da0b74e9db9bfd_720w.png" alt="img"></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="comment">//使用CommandLineParser对输入的参数进行分析，获取输入的图片路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetFileName</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key = &#123;</span><br><span class="line">    <span class="string">&quot;&#123;help h usage? || usage information&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;@picture || input picture&#125;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc,argv,key)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (parser.has(<span class="string">&quot;help&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printMessage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有输入图片路径</span></span><br><span class="line">    <span class="keyword">if</span> (!parser.check())</span><br><span class="line">    &#123;</span><br><span class="line">        parser.printErrors();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = parser.get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不改变大小</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">ImageTranslation</span><span class="params">(cv::Mat src_,<span class="keyword">int</span> x_offset,<span class="keyword">int</span> y_offset,<span class="keyword">bool</span> IsResize = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src_       : srcImage</span></span><br><span class="line"><span class="comment">    x_offset  : translate x_offset in x axis</span></span><br><span class="line"><span class="comment">    y_offset  : translate y_offset in y axis</span></span><br><span class="line"><span class="comment">    IsResize  : whether or not to change the image size</span></span><br><span class="line"><span class="comment">    return    : dstImage</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> cols = src_.cols;</span><br><span class="line">    <span class="keyword">int</span> rows = src_.rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否改变原始图像的大小</span></span><br><span class="line">    <span class="keyword">if</span> (IsResize)</span><br><span class="line">    &#123;</span><br><span class="line">        rows = rows + <span class="built_in">std</span>::<span class="built_in">abs</span>(y_offset);</span><br><span class="line">        cols = cols + <span class="built_in">std</span>::<span class="built_in">abs</span>(x_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rows = rows;</span><br><span class="line">        cols = cols;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">dstImage</span><span class="params">(rows,cols,src_.type())</span></span>;</span><br><span class="line">    <span class="comment">//进行平移操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j - x_offset;</span><br><span class="line">            <span class="keyword">int</span> y = i - y_offset;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;=<span class="number">0</span> &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; x &lt; cols &amp;&amp; y &lt; rows) <span class="comment">//对于超出图像边界的不进行处理</span></span><br><span class="line">                dstImage.at&lt;cv::Vec3b&gt;(i,j) = src_.ptr&lt;cv::Vec3b&gt;(y)[x];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dstImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fileName = GetFileName(argc,argv);</span><br><span class="line">    cv::Mat srcImage = cv::imread(fileName);</span><br><span class="line">    <span class="keyword">int</span> x_offset = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> y_offset = <span class="number">10</span>;</span><br><span class="line">    cv::Mat dstImage = ImageTranslation(srcImage,x_offset,y_offset,<span class="literal">false</span>);</span><br><span class="line">    cv::Mat dstImage1 = ImageTranslation(srcImage,x_offset,y_offset,<span class="literal">true</span>);</span><br><span class="line">    cv::imshow(<span class="string">&quot;input&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;output&quot;</span>,dstImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;output for resize&quot;</span>,dstImage1);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入图像：</p><p><img src="https://pic2.zhimg.com/80/v2-9560b0a0220ffebe7cd4508809cf86b6_720w.jpg" alt="img"></p><p><strong>输出图像</strong></p><p>不改变大小：</p><p><img src="https://pic1.zhimg.com/80/v2-022fb16ef4e72c0206ea8d0140eb73f9_720w.jpg" alt="img"></p><p>改变大小：</p><p><img src="https://picb.zhimg.com/80/v2-dc2cdddbad6ec34dfef4e1f242c845a7_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像的平移操作是将图像按照水平方向或者垂直方向平移。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>remap</title>
    <link href="http://example.com/jsblog/2524302a.html"/>
    <id>http://example.com/jsblog/2524302a.html</id>
    <published>2020-09-12T10:16:49.000Z</published>
    <updated>2020-09-12T11:09:08.593Z</updated>
    
    <content type="html"><![CDATA[<p>图像的坐标变换是通过原图像与目标图像之间建立一种变换关系。</p><a id="more"></a><p>图像的坐标映射也是图像的一种坐标变换。主要是对图像像素的变换。这种变换的关系可以下面公式表示:</p><p>​        dst(x,y) = src(mapx(x,y),mapy(x,y))</p><p>图像的坐标映射也分为正映射和反映射。</p><p>正映射就是从原图像变换到目标图像。</p><p>反映射是将目标图像变换到原始图像。</p><p>在opencv 中实现坐标变换的函数是remap,函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::remap</span><span class="params">(InputArray src,</span></span></span><br><span class="line"><span class="function"><span class="params">              OutputArray dst,</span></span></span><br><span class="line"><span class="function"><span class="params">              InputArray map1,</span></span></span><br><span class="line"><span class="function"><span class="params">              InputArray map2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> interpolation,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> Scalar&amp; borderValue = Scalar())</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><p>src : 原始图像；</p><p>dst : 目标图像，大小和map1的大小相同，数据类型和src的数据类型一样；</p><p>map1:表示（x,y）坐标点或者是x坐标，类型为CV_16SC2,CV_32FC1或者CV_32FC2；</p><p>map2: 表示y坐标，类型是CV_16UC1, CV_32FC1，当map1是（x,y）坐标时，map2可以为空；</p><p>Interpolation:表示插值算法，枚举类型主要。暂不支持INTER_AREA 插值算法。插值算法有一下几种：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INTER_NEAREST</td><td>最近邻插值</td></tr><tr><td>INTER_LINEAR</td><td>双线性插值</td></tr><tr><td>INTER_CUBIC</td><td>双三次插值</td></tr><tr><td>INTER_AREA</td><td>利用像素面积关系重采样。这可能是图像抽取的首选方法，因为它可以得到无云纹的结果。但当图像被放大时，它类似于最近邻法。</td></tr><tr><td>INTER_LANCZOS4</td><td>8x8邻域上的Lanczos插值</td></tr><tr><td>INTER_LINEAR_EXACT</td><td>位精确双线性插值</td></tr><tr><td>INTER_NEAREST_EXACT</td><td>位最近邻插值算法。在PIL,scikit-image和Matlab中效果和最近邻插值算法一样</td></tr><tr><td>INTER_MAX</td><td>插值算法掩码</td></tr><tr><td>WARP_FILL_OUTLIERS</td><td>标志，填充目标图像。如果目标图像的一部分是异常值，那么他们被设置为0</td></tr><tr><td>WARP_INVERSE_MAP</td><td>标志，逆变换</td></tr></tbody></table><p>borderMode: 边界插值类型；</p><p>borderValue: 表示边界插值数据。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">&quot;E:/CodeBlocks/data/butterfly.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (srcImage.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt; <span class="string">&quot;fail to load image &quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">xMapArray</span><span class="params">(srcImage.size(),CV_32FC1)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">yMapArray</span><span class="params">(srcImage.size(),CV_32FC1)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">dstImage</span><span class="params">(srcImage.size(),xMapArray.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置变换x,y</span></span><br><span class="line">    <span class="keyword">int</span> rows = srcImage.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = srcImage.cols;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            xMapArray.at&lt;<span class="keyword">float</span>&gt;(i,j) = cols - j;</span><br><span class="line">            yMapArray.at&lt;<span class="keyword">float</span>&gt;(i,j) = rows - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行变换</span></span><br><span class="line">    cv::remap(srcImage,dstImage,xMapArray,yMapArray,cv::INTER_LINEAR,cv::BORDER_CONSTANT,cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;remap&quot;</span>,dstImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic1.zhimg.com/80/v2-31b782e5798a601b90893958eeb517c0_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-11b0b479a7af64c487829c95ee3c625f_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像的坐标变换是通过原图像与目标图像之间建立一种变换关系。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="http://example.com/jsblog/a541262a.html"/>
    <id>http://example.com/jsblog/a541262a.html</id>
    <published>2020-09-12T03:18:15.000Z</published>
    <updated>2020-09-12T04:16:02.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-spring-boot注解"><a href="#1-spring-boot注解" class="headerlink" title="1.spring boot注解"></a>1.spring boot注解</h2><h2 id="1-1-SpringBootApplication"><a href="#1-1-SpringBootApplication" class="headerlink" title="1.1 @SpringBootApplication"></a>1.1 @SpringBootApplication</h2><p>是spring的启动类</p><a id="more"></a><p>此注解等同于@Configuration+@EnableAutoConfiguration + @ComponentScan的组合</p><h2 id="1-2-SpringBootConfiguration"><a href="#1-2-SpringBootConfiguration" class="headerlink" title="1.2 @SpringBootConfiguration"></a><a href="mailto:5.2@SpringBootConfiguration">1.2 @SpringBootConfiguration</a></h2><p>@SpringBootCnfiguration 是@Configuration的派生注解，和@Configuration的功能意义，标注这个类是个配置类，不是@springbootConfiguration是spring boot的注解，而@configuration是spring的注解</p><h2 id="1-3-Configuration"><a href="#1-3-Configuration" class="headerlink" title="1.3 @Configuration"></a>1.3 @Configuration</h2><p>通过对bean对象的操作替代spring中xml文件</p><h2 id="1-4-EnableAutoConfiguration"><a href="#1-4-EnableAutoConfiguration" class="headerlink" title="1.4 @EnableAutoConfiguration"></a>1.4 @EnableAutoConfiguration</h2><p>Spring boot的自动配置，尝试根据你添加的jar依赖自动配置你的spring应用，是@AutoConfigurationPackage和@Import的组合</p><h2 id="1-5-AutoConfigurationPackage"><a href="#1-5-AutoConfigurationPackage" class="headerlink" title="1.5 @AutoConfigurationPackage"></a>1.5 @AutoConfigurationPackage</h2><p>自动注入启动类所在包下所有加了注解的类（@Controller,@Service等）以及配置类（@configuration）</p><h2 id="1-6-import"><a href="#1-6-import" class="headerlink" title="1.6 @import"></a><a href="mailto:5.6@import">1.6 @import</a></h2><p>直接导入普通类</p><p>导入实现的ImportSelector接口的类</p><p>导入实现的ImportBeanDefinitionRegister接口的类</p><h2 id="1-7-ComponentScan"><a href="#1-7-ComponentScan" class="headerlink" title="1.7@ComponentScan"></a><a href="mailto:1.7@ComponentScan">1.7@ComponentScan</a></h2><p>组件扫描，可以自动发现一些bean</p><h2 id="1-8-ConfigurationPropertiesScan"><a href="#1-8-ConfigurationPropertiesScan" class="headerlink" title="1.8 @ConfigurationPropertiesScan"></a>1.8 @ConfigurationPropertiesScan</h2><p>@ConfigurationPropertiesScan扫描配置属性。@EnableConfigurationProperties注解的作用是让使用@ConfigurationProperties的类生效</p><h2 id="Spring-boot常见注解"><a href="#Spring-boot常见注解" class="headerlink" title="Spring boot常见注解"></a>Spring boot常见注解</h2><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>@RestController相当于@Controller + @ResponseBody</p><p>使用@RestController注解Controller中的方法，Controller是无法返回到页面的，相当于在方法前添加了@ResponseBody注解，InternalResourceViewResolver不起作用，就没办法跳转传输数据。若返回数据，则为方法return的内容</p><h2 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h2><p>@GetMapping是@RequestMapping(method=RequestMethod.GET)的缩写</p><h2 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h2><p>@PostMapping是@RequestMapping(method=RequestMethod.POST)的缩写</p><h2 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a>@PutMapping</h2><p>@PutMapping是@RequestMapping(method=RequestMethod.PUT)的缩写</p><h2 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a>@DeleteMapping</h2><p>@DeleteMapping是@RequestMapping(method=RequestMethod.DELETE)的缩写</p><h2 id="Spring-Boot创建项目的三种方式"><a href="#Spring-Boot创建项目的三种方式" class="headerlink" title="Spring Boot创建项目的三种方式"></a>Spring Boot创建项目的三种方式</h2><h2 id="1通过官网创建"><a href="#1通过官网创建" class="headerlink" title="1通过官网创建"></a>1通过官网创建</h2><p><a href="https://link.zhihu.com/?target=https://start.spring.io">https://start.spring.io</a></p><h2 id="2-使用idea中spring-initalizer创建"><a href="#2-使用idea中spring-initalizer创建" class="headerlink" title="2.使用idea中spring initalizer创建"></a>2.使用idea中spring initalizer创建</h2><p>和1类似</p><h2 id="3-创建maven工程，修改pom文件"><a href="#3-创建maven工程，修改pom文件" class="headerlink" title="3.创建maven工程，修改pom文件"></a>3.创建maven工程，修改pom文件</h2><p>修改pom文件</p><h2 id="Spring-Boot结构"><a href="#Spring-Boot结构" class="headerlink" title="Spring Boot结构"></a>Spring Boot结构</h2><h2 id="1-POM文件"><a href="#1-POM文件" class="headerlink" title="1 POM文件"></a>1 POM文件</h2><h2 id="Sping-Boot整合Web技术"><a href="#Sping-Boot整合Web技术" class="headerlink" title="Sping Boot整合Web技术"></a>Sping Boot整合Web技术</h2><h2 id="整合servlet技术"><a href="#整合servlet技术" class="headerlink" title="整合servlet技术"></a>整合servlet技术</h2><h3 id="1-通过注解扫描完成整合servlet"><a href="#1-通过注解扫描完成整合servlet" class="headerlink" title="1 通过注解扫描完成整合servlet"></a>1 通过注解扫描完成整合servlet</h3><p>编写servlet类,在servlet中加入注解@WebServlet(name=””,urlpattern=””)</p><p>在启动弄类中加上注解@ServletComponentScan, @ServletComponentScan在spring boot启动时扫描@WebServlet注解，并将该类实例化</p><h3 id="2通过配置类"><a href="#2通过配置类" class="headerlink" title="2通过配置类"></a>2通过配置类</h3><p>1 编写servlet类，不需使用注解@WebServlet</p><p>创建servlet配置类，使用@Configuration注解，使用@Bean完成servlet的注册,如图</p><p><img src="https://picb.zhimg.com/80/v2-87cd4780b0ba71834909e1dc982d1b9f_720w.jpg" alt="img"></p><h2 id="整合filter"><a href="#整合filter" class="headerlink" title="整合filter"></a>整合filter</h2><h3 id="使用注解方式"><a href="#使用注解方式" class="headerlink" title="使用注解方式"></a>使用注解方式</h3><p>编写filter,使用@webfilter注解（是javax.servlet.*包下的filter）<br>在启动弄类中加上注解@ServletComponentScan, @ServletComponentScan在spring boot启动时扫描@WebServlet注解，并将该类实例化</p><h3 id="使用配置类"><a href="#使用配置类" class="headerlink" title="使用配置类"></a>使用配置类</h3><p>编写servlet类，不需使用注解@WebServlet</p><p>创建filter配置类，使用@Configuration注解，使用@Bean完成Filter的注册</p><p><img src="https://picb.zhimg.com/80/v2-66aa11ab51f73870487d9656d412be11_720w.jpg" alt="img"></p><h2 id="整合Listener"><a href="#整合Listener" class="headerlink" title="整合Listener"></a>整合Listener</h2><h3 id="通过注解扫描的方式"><a href="#通过注解扫描的方式" class="headerlink" title="通过注解扫描的方式"></a>通过注解扫描的方式</h3><p>编写listener,使用@weblistener</p><p>在启动弄类中加上注解@ServletComponentScan, @ServletComponentScan在spring boot启动时扫描@WebServlet注解，并将该类实例化</p><h3 id="通过配置类"><a href="#通过配置类" class="headerlink" title="通过配置类"></a>通过配置类</h3><p>编写servlet类，不需使用注解@WebListener</p><p>创建Listener配置类，使用@Configuration注解，使用@Bean完成ServletListener的注册</p><h2 id="Spring-boot访问静态资源"><a href="#Spring-boot访问静态资源" class="headerlink" title="Spring boot访问静态资源"></a>Spring boot访问静态资源</h2><h2 id="Static-目录"><a href="#Static-目录" class="headerlink" title="Static 目录"></a>Static 目录</h2><p>Spring boot通过static目录静态资源。静态资源存放的目录必须是static</p><h2 id="Templates目录"><a href="#Templates目录" class="headerlink" title="Templates目录"></a>Templates目录</h2><p>在Spring Boot中不推荐使用jsp作为视图层技术，而是默认使用Thymeleaf来做动态页面。Templates目录这是存放Thymeleaf的页面。</p><h2 id="默认存放目录"><a href="#默认存放目录" class="headerlink" title="默认存放目录"></a>默认存放目录</h2><p>/META-INF/resources/</p><p>/resources/</p><p>/static/</p><p>/public/</p><h2 id="自定义存放目录"><a href="#自定义存放目录" class="headerlink" title="自定义存放目录"></a>自定义存放目录</h2><p>在配置文件中修改<strong>spring.resources.static-locations</strong>多个目录使用逗号分隔如：</p><p><strong>spring.resources.static-locations = classpath:/static/,/public/</strong></p><h2 id="Spring-Boot整合JSP"><a href="#Spring-Boot整合JSP" class="headerlink" title="Spring Boot整合JSP"></a>Spring Boot整合JSP</h2><ol><li>创建webapp目录和在webapp中创建WEB-INF目录，在WEB-INF中创建jsp目录,修改pom文件添加jsp依赖</li></ol><p><img src="https://pic3.zhimg.com/80/v2-1b3b6dc80e95fb78e3687f3df32b1d93_720w.jpg" alt="img"></p><ol><li>将webapp标记为moudles中的Web</li><li>修改spring boot中配置视图层的目录</li></ol><p>Spring.mvc.view.prefix=/WEB-INF/jsp/ 保存jsp文件的文件目录</p><p>Spring.mvc.view.suffix=.jsp jsp文件的后缀名</p><p>在聚合项目中，无法找到jsp文件，需要制定工作目录。</p><h2 id="Spring-boot整合freemaker"><a href="#Spring-boot整合freemaker" class="headerlink" title="Spring boot整合freemaker"></a>Spring boot整合freemaker</h2><ol><li>创建项目</li><li>修改pom文件，添加freemake依赖</li></ol><p><img src="https://pic2.zhimg.com/80/v2-d99b437a6ee81b049d28d3a98d65908e_720w.jpg" alt="img"></p><h2 id="Spring-整合Thymeleaf"><a href="#Spring-整合Thymeleaf" class="headerlink" title="Spring 整合Thymeleaf"></a>Spring 整合Thymeleaf</h2><p>Thymeleaf的优点是它是基于HTML的，即使视图没有渲染成功，也是一个标准的HTML页面。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><img src="https://pic3.zhimg.com/80/v2-76d12ba43a8867db766d4768907db517_720w.jpg" alt="img"></p><h2 id="Thymeleaf基本使用"><a href="#Thymeleaf基本使用" class="headerlink" title="Thymeleaf基本使用"></a>Thymeleaf基本使用</h2><p>Thymeleaf基本语法</p><p>命名空间 <strong>xmlns:th=”<a href="https://link.zhihu.com/?target=http://www.thymeleaf.org">http://www.thymeleaf.org</a>”</strong></p><ol><li>字符串与变量输出</li></ol><p><strong>th:text</strong> 在页面中输出值</p><p><strong>th:value 可以一个值放入到input标签的value中 针对input标签</strong></p><ol><li>字符串操作</li></ol><p>使用内置对象</p><ol><li>引用内置对象需要使用#</li><li>大部分内置对象的名称都以s结尾。如：strings,numbers,dates<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#strings.isEmpty(key)&#125; 判断key是否为空串</span><br><span class="line"></span><br><span class="line">$&#123;#strings.contains(msg,T)&#125; 判断字符串msg中是否包含T子串</span><br></pre></td></tr></table></figure></li><li>条件判断</li></ol><p>th:if / th:switch和th:case</p><p>th:case = “*” 表示java中switch的default</p><ol><li>迭代</li></ol><p>th:each=”object : ${set}”</p><p><strong>th:each迭代Map</strong></p><ol><li>Thymeleaf的配置</li></ol><p>Spring.thymeleaf.cache=false #关闭页面缓存</p><p>Spring.thymeleaf.encoding=UTF-8设置页面编码</p><p>Spring.thymeleaf.mode=HTML5 #视图解析目标，若使用html5则需要加入此项</p><h2 id="SpringBoot整合JDBC"><a href="#SpringBoot整合JDBC" class="headerlink" title="SpringBoot整合JDBC"></a>SpringBoot整合JDBC</h2><p>添加依赖</p><p><img src="https://pic2.zhimg.com/80/v2-6ba31d0f200df586c67ecb24f3322796_720w.jpg" alt="img"></p><p>添加驱动</p><p><img src="https://pic2.zhimg.com/80/v2-b7b3db56388dced7de2a3247eb1fade9_720w.jpg" alt="img"></p><p>2配置数据源</p><p>添加druid数据源依赖</p><p><img src="https://pic4.zhimg.com/80/v2-c7efae6a949eceb420b3eef323234916_720w.jpg" alt="img"></p><p>使用@ConfigureProperties配置jdbc</p><p>@ConfigurePropertie 只能读取application.properties或者application.yml</p><p><img src="https://picb.zhimg.com/80/v2-d66e739ac6f33542b0a11ce804e0915e_720w.jpg" alt="img"></p><p>Properties文件中</p><p><img src="https://pic2.zhimg.com/80/v2-aac0ee5c56dcc18ddd98b688541b7ab7_720w.jpg" alt="img"></p><p>使用@EnableConfigurationProperties指定加载的类</p><p>也可以在配置类中使用构造方法和作为参数传递</p><p>可以将@ConfigurationProperties(prefix = “jdbc”)放在函数之前</p><p><img src="https://pic2.zhimg.com/80/v2-cc6ba857bdee8360d71b46009abedc7a_720w.jpg" alt="img"></p><p>Spring boot默认使用HikariDataSource数据源</p><p>Application.properties配置文件中配置</p><p><img src="https://pic3.zhimg.com/80/v2-4ae14603148ad173040ed53e5600943b_720w.jpg" alt="img"></p><p>更换数据源</p><p><img src="https://pic2.zhimg.com/80/v2-ba7455761f537b3972f9b10858c47ef6_720w.jpg" alt="img"></p><p>实现一个查询业务</p><p>Dao层</p><p><img src="https://pic3.zhimg.com/80/v2-3993c2981eaa9667e4fe0b709b69c2a9_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-317eb3116a689776aa7997d0a3db38d2_720w.jpg" alt="img"></p><p>Services层</p><p><img src="https://picb.zhimg.com/80/v2-d0245b3fe406e535f7ca427f444e2251_720w.jpg" alt="img"></p><p><img src="https://picb.zhimg.com/80/v2-97f81e51af3adbeb8a785ddfdec87dfb_720w.jpg" alt="img"></p><h2 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h2><p>添加mysql驱动和mybatis依赖</p><p><img src="https://pic1.zhimg.com/80/v2-b3bef1a89137f3d4728b17fc9ac1ce53_720w.jpg" alt="img"></p><p>配置maven的generator插件，添加依赖</p><p><img src="https://pic2.zhimg.com/80/v2-86de22dc79f48807c2f940a51e497c49_720w.jpg" alt="img"></p><p>指定配置 文件</p><p><img src="https://pic2.zhimg.com/80/v2-23458d940df9e06168cfbddf015c0761_720w.jpg" alt="img"></p><p>配置文件内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- context 是逆向工程的主要配置信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：起个名字 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--optional,指在创建class时，对注释进行控制--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--jdbc的数据库连接 wg_insert 为数据库名字--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/wg_insert?useUnicode=true<span class="symbol">&amp;amp;</span>characeterEncoding=utf-8<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;jsl123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--非必须，类型处理器，在数据库类型和java类型之间的转换控制--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 默认情况下数据库中的 decimal，bigInt 在 Java 对应是 sql 下的 BigDecimal 类 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 不是 double 和 long 类型 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- targetPackage：生成的实体类所在的包 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：生成的实体类所在的硬盘位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;cn.silver.springbootmybaits.Enties&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否允许子包 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否对modal添加构造函数 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;constructorBased&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 建立modal对象是否不可改变 即生成的modal对象不会有setter方法，只有构造方法 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;cn.silver.springbootmybaits.Mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;cn.silver.springbootmybaits.Dao&quot;</span> </span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- tableName是数据库中的表名，domainObjectName是生成的JAVA模型名，后面的参数不用改，要生成更多的表就在下面继续加table标签 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;movies&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Movies&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- tableName是数据库中的表名，domainObjectName是生成的JAVA模型名，后面的参数不用改，要生成更多的表就在下面继续加table标签 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;users&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Users&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;ratings&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Ratings&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用资源拷贝插件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--资源拷贝插件 mapper.xml不在resources夹中--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>在启动类上添加@MapperSan注解</p><p>@MapperScan(<strong>“cn.silver.springbootmybaits.Dao”</strong>)</p><p>扫描xml所在的包名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#扫描classpath 中mapper下的映射配置文件，当配置文件放在resources文件中</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"> <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line"> <span class="comment">#定义包的别名，在mapper.xml文件中可以直接使用Enties中的类型</span></span><br><span class="line"> <span class="attr">type-aliases-package:</span> <span class="string">cn.silver.springbootmybaits.Enties</span></span><br></pre></td></tr></table></figure><h2 id="Spring-boot异常处理和单元测试"><a href="#Spring-boot异常处理和单元测试" class="headerlink" title="Spring boot异常处理和单元测试"></a>Spring boot异常处理和单元测试</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li>自定义错误页面</li></ol><p>Spring boot默认的处理异常的机制：spring boot默认的已经提供了一套处理异常的机制，一旦程序中出现了异常springboot会向/error的url发送请求。在spring boot中提供一个名为BasicErrorController来处理/error请求，然后跳转到默认显示异常的页面展示异常信息。如果我们需要将所有的异常同一跳转到自定义的错误页面，需要在src/main/resouces/templates目录下创建error.html页面。注意：页面名称必须叫error</p><p><img src="https://pic2.zhimg.com/80/v2-82049c7f57b4dde6bf8d7dd0bbe3396a_720w.jpg" alt="img"></p><ol><li>通过@ExceptionHandler处理</li></ol><p><img src="https://pic1.zhimg.com/80/v2-b4abb3a2f52bd7a319fd34fabc739391_720w.jpg" alt="img"></p><p>通过注解对不同的错误进行处理</p><ol><li>通过@ControllerAdvice与@ExceptionHandler注解处理异常</li><li>创建全局异常处理类</li></ol><p><img src="https://pic4.zhimg.com/80/v2-55ef5c08f00bc7204e6d3082a8aea716_720w.jpg" alt="img"></p><ol><li>通过SimpleMappingExceptionResolver对象处理</li></ol><p>创建全局异常类</p><p><img src="https://pic2.zhimg.com/80/v2-5fe3b3933d3f840531ac09a27477bbb6_720w.jpg" alt="img"></p><ol><li>通过自定义HandlerExceptionResolver对象处理异常</li></ol><p>创建全局异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalHandler3</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line">            mv.setViewName(<span class="string">&quot;error5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException)&#123;</span><br><span class="line">            mv.setViewName(<span class="string">&quot;error6&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mv.addObject(<span class="string">&quot;err&quot;</span>,e.toString());</span><br><span class="line"> <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot整合Junit单元测试"><a href="#Spring-Boot整合Junit单元测试" class="headerlink" title="Spring Boot整合Junit单元测试"></a>Spring Boot整合Junit单元测试</h2><p>Spring boot 2.x使用Junit5作为测试平台</p><ol><li>修改pom文件添加Test依赖</li></ol><p><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-test</artifactId><scope>test</scope><exclusions><exclusion><groupId>org.junit.vintage</groupId><artifactId>junit-vintage-engine</artifactId></exclusion></exclusions></dependency></dependencies></p><p><img src="https://pic2.zhimg.com/80/v2-cdd9a57c472e0b8cd6aad3d5cfb7aec8_720w.jpg" alt="img"></p><p>排除提供junit3 和junit4测试</p><ol><li>编写测试代码</li></ol><p><img src="https://picb.zhimg.com/80/v2-869826cb8f86e4b3addb3421bc57be7a_720w.jpg" alt="img"></p><h2 id="Spring-Boot服务端数据校验"><a href="#Spring-Boot服务端数据校验" class="headerlink" title="Spring Boot服务端数据校验"></a>Spring Boot服务端数据校验</h2><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对数据校验"><a href="#对数据校验" class="headerlink" title="对数据校验"></a>对数据校验</h2><p>使用注解进行数据校验</p><p>@NotNull 对基本数据类型的对象类型做非空校验</p><p>@NotBlank 对对字符串类型做非空校验</p><p>@NotEmpty 对集合类型做非空校验</p><p>使用@Validated设置校验数据</p><p>自定义错误信息</p><p>@NotNull（message = “tips”） 对基本数据类型的对象类型做非空校验,message表示提示信息</p><p>在配置文件中自定义提示信息，使用Hiberaiter-validator框架</p><p>配置文件必须是ValidationMessages.properties</p><h2 id="Spring-boot-使用devtools进行热部署"><a href="#Spring-boot-使用devtools进行热部署" class="headerlink" title="Spring boot 使用devtools进行热部署"></a>Spring boot 使用devtools进行热部署</h2><p>添加Devtools依赖或者新建项目的时候选中devtools</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-spring-boot注解&quot;&gt;&lt;a href=&quot;#1-spring-boot注解&quot; class=&quot;headerlink&quot; title=&quot;1.spring boot注解&quot;&gt;&lt;/a&gt;1.spring boot注解&lt;/h2&gt;&lt;h2 id=&quot;1-1-SpringBootApplication&quot;&gt;&lt;a href=&quot;#1-1-SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;1.1 @SpringBootApplication&quot;&gt;&lt;/a&gt;1.1 @SpringBootApplication&lt;/h2&gt;&lt;p&gt;是spring的启动类&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>auto</title>
    <link href="http://example.com/jsblog/66ba25fa.html"/>
    <id>http://example.com/jsblog/66ba25fa.html</id>
    <published>2020-09-12T03:17:12.000Z</published>
    <updated>2020-09-12T04:04:07.417Z</updated>
    
    <content type="html"><![CDATA[<p>auto 类型推导。在c++98/03 代表具有自动存储期的局部变量。在c++11中auto是一个类型指示符，用来提示编译器对此类型的变量做类型的自动推导。</p><a id="more"></a><p>auto推导的两条规则：</p><p>(1）当不声明为指针或者引用时，auto的推导结果和初始化表达式将抛弃引用和cv限定符（const 和volatile限定符）。</p><p>(2）当声明为指针或者引用时，auto推导的结果将保持初始化表达式的cv属性</p><p>auto的限制：</p><p>(1) 不能用于函数参数的类型推导</p><p>(2) 不能用户非静态成员变量</p><p>(3) 无法定义数组</p><p>(4) 无法推导出模板参数</p><p>auto使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; testMap = &#123;&#123;<span class="number">1</span>, <span class="number">0.5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0.75</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0.9</span>&#125;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;::iterator it = testMap.begin();</span><br><span class="line">  <span class="keyword">for</span> (; it != testMap.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot; value =&quot;</span> &lt;&lt; (*it).second</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用auto</span></span><br><span class="line">  <span class="keyword">auto</span> itr = testMap.begin();</span><br><span class="line">  <span class="keyword">for</span> (; itr != testMap.end(); itr++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; (*itr).first &lt;&lt; <span class="string">&quot; value =&quot;</span> &lt;&lt; (*itr).second</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = 1 value =0.5</span><br><span class="line">key = 2 value =0.75</span><br><span class="line">key = 3 value =0.9</span><br><span class="line">key = 1 value =0.5</span><br><span class="line">key = 2 value =0.75</span><br><span class="line">key = 3 value =0.9</span><br></pre></td></tr></table></figure><p>当要使用的具体类型的名称过长时，可以使用auto进行推导简化代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;auto 类型推导。在c++98/03 代表具有自动存储期的局部变量。在c++11中auto是一个类型指示符，用来提示编译器对此类型的变量做类型的自动推导。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Decltype</title>
    <link href="http://example.com/jsblog/6e431fb1.html"/>
    <id>http://example.com/jsblog/6e431fb1.html</id>
    <published>2020-09-12T03:15:20.000Z</published>
    <updated>2020-09-12T03:23:06.624Z</updated>
    
    <content type="html"><![CDATA[<p>decltype : 获取表达式的类型。在编译时推导出一个表达式的类型，并且不会计算表达式的值</p><a id="more"></a><p>使用方式: decltype(expression)</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>; <span class="comment">// y -&gt;  int</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) z = x + y; <span class="comment">// z - &gt;  int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;<span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;<span class="comment">// p-&gt; const int *</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *pi = &amp;z; <span class="comment">// pi -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(pi) *pp = π<span class="comment">//pp -&gt; int**</span></span><br></pre></td></tr></table></figure><p>auto与decltype类似但是又不同，auto只能根据变量的初始化表达式推导出变量应该具有的类型。decltype将精确的推导出表达式定义的类型，不会舍弃和弃用cv限定符。</p><p>decltype(exp)推导规则:</p><ol><li>exp 是标识、类访问表达式，decltype(exp) 和exp的类型一致</li></ol><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x</span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) y = <span class="number">1</span>;<span class="comment">// y -&gt; volatile </span></span><br><span class="line"><span class="keyword">decltype</span>(Foo::Number) c = <span class="number">0</span>;           <span class="comment">// c -&gt; const int</span></span><br><span class="line">Foo foo;</span><br><span class="line"><span class="keyword">decltype</span>(Foo.x) d = <span class="number">0</span>;  <span class="comment">// d -&gt; int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span><span class="keyword">int</span> x;&#125;</span><br><span class="line">F f = F();</span><br><span class="line"><span class="keyword">decltype</span>(f.x) x = <span class="number">0</span>;                              <span class="comment">// x -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>((f.x)) e = x;                              <span class="comment">// e -&gt; const int</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>exp是函数调用，decltype(exp)和返回值的类型一致</p></li><li><p>其他情况，如果exp是一个左值，则decltype(exp)是exp类型的左值引用，否则和exp类型一致</p></li></ol><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(int_func()) a = <span class="number">0</span>; <span class="comment">//a -&gt; int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">int_func_l</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(int_func_l()) b = x;<span class="comment">// b -&gt; int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">int_func_rr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(int_func_rr()) c = <span class="number">0</span>;<span class="comment">// c -&gt; int&amp;&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a+b) z = x;<span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>( a+= b) y = z;<span class="comment">// y-&gt;int&amp;</span></span><br></pre></td></tr></table></figure><p>返回类型的后置语法使用 auto 和decltype</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line">auto func(T&amp; val) -&gt;decltype(foo(val))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;decltype : 获取表达式的类型。在编译时推导出一个表达式的类型，并且不会计算表达式的值&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Num and String</title>
    <link href="http://example.com/jsblog/d56b4289.html"/>
    <id>http://example.com/jsblog/d56b4289.html</id>
    <published>2020-09-12T03:09:12.000Z</published>
    <updated>2020-09-12T03:23:06.627Z</updated>
    
    <content type="html"><![CDATA[<p>在使用C++进行字符串转换的时候总是忘记，以此记录一下系统函数。同时给出一个自己参考CJSon实现的一个转换函数</p><a id="more"></a><p>数值型转换为字符串 使用std::to_string函数，若是转换成wstring则使用to_wstring函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">int</span> value)</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> value)</span></span>;   </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>可能会导致std::bad_alloc异常。</p><p>将数值保存到char* buff中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%d”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%ld”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%lld”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%u”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%lu”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%llu”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%f”,value);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">sprintf</span>(buf,”%Lf”,value);</span><br></pre></td></tr></table></figure><p>字符串转换为数值：</p><p><strong>c语言：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int atoi(const char* str);</span><br><span class="line">long atol(const char* str);</span><br><span class="line">long long atoll(const char* str);</span><br><span class="line">double atof(const char* str);</span><br></pre></td></tr></table></figure><p><strong>C++:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">std::stoll</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">std::stoll</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stoul</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoull</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">std::stold</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">std::stold</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; str,<span class="built_in">std</span>::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str: 数值字符串</p><p>pos： 数字在字符串中的起始位置</p><p>base : 进制，默认为10进制数字</p><p>参考CJSON的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CharToNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>,sign = <span class="number">1</span>,expsign=<span class="number">1</span>,decimal = <span class="number">0</span>,exponent = <span class="number">0</span>,exponentSign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>,str++;   <span class="comment">//the opposite</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;0&#x27;</span>) str++;             <span class="comment">// is zero ?</span></span><br><span class="line">    <span class="keyword">if</span> (*str &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str&lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//is numbers</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res *<span class="number">10</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;.&#x27;</span> &amp;&amp; str[<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//decimal partition</span></span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res *<span class="number">10</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            decimal--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//exponent partition</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;e&#x27;</span> || *str==<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        <span class="keyword">if</span> (*str==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            str++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            exponentSign = <span class="number">-1</span>,str++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">           exponent =  exponent *<span class="number">10</span> + (*str++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = sign * res * <span class="built_in">pow</span>(<span class="number">10.0</span>,(decimal + (exponentSign * exponent)));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用C++进行字符串转换的时候总是忘记，以此记录一下系统函数。同时给出一个自己参考CJSon实现的一个转换函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>select</title>
    <link href="http://example.com/jsblog/4bf2eac0.html"/>
    <id>http://example.com/jsblog/4bf2eac0.html</id>
    <published>2020-09-12T03:07:50.000Z</published>
    <updated>2020-09-12T03:53:37.986Z</updated>
    
    <content type="html"><![CDATA[<p>使用select函数实现I/O复用</p><a id="more"></a><p>Select函数允许进程指示内核等待多个事件中的一个发生，并只在或多个事件发生或经历一段指定时间后才唤醒。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *write_set,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure><p>返回：若有就绪描述符就绪就返回就绪数目，若超时返回0，错误发生返回-1</p><p>maxfdp1 : 指定待测试的描述符的个数，值是待测最大描述符加1，从0,1,2…到maxfdp1-1都会被测试</p><p>readset : 让内核测试读的描述符集合</p><p>writeset : 让内核测试写的描述符集合</p><p>exceptset : 让内核测试异常条件的描述符集合</p><p>对于fd_set的初始化可设置需要使用以下4个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;         <span class="comment">//清空文件描述符集合fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;   <span class="comment">//将指定的文件描述符fd加入文件描述符集合fdset</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>; <span class="comment">//将判断文件描述符fd是否在文件描述符集合fdset中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;   <span class="comment">//将指定的文件描述符fd从文件描述符集合fdset中清除</span></span><br></pre></td></tr></table></figure><p>Timeout : 是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> tv_sec; <span class="comment">//秒</span></span><br><span class="line">  <span class="keyword">long</span> tv_usec; <span class="comment">//毫秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>的类型，表示告知内核等待所指定的描述符中任何一个就绪可花多长时间。这个参数有以下三种情况：</p><p>1）永远等待下去：直到有一个描述符准备好I/O才返回，这时需要将此参数设置为NULL</p><p>2）等待一段时间：在有一个描述符准备好I/O时返回，但不能超过timeout中设置的秒数和毫秒数</p><p>3）根本不等待：检查描述符后立即返回，这就是轮询。需要将传入的timeout中的秒数和毫秒数都设置为0</p><p>Tcp服务端例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 40501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="comment">// 读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> noreadcn, readcn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  noreadcn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (noreadcn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((readcn = read(fd, buf, noreadcn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        readcn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readcn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;             <span class="comment">// EOF</span></span><br><span class="line">    noreadcn -= readcn;  <span class="comment">//读取的数据少于maxcn继续读</span></span><br><span class="line">    buf += readcn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - noreadcn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nowritecn, writecn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  nowritecn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (nowritecn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((writecn = write(fd, buf, nowritecn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        writecn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writecn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;               <span class="comment">// EOF</span></span><br><span class="line">    nowritecn -= writecn;  <span class="comment">//写入的数据少于maxcn继续写</span></span><br><span class="line">    buf += writecn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - nowritecn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, maxi, maxfd, listenfd, sockfd, connfd;</span><br><span class="line">  <span class="keyword">int</span> nready, client[FD_SETSIZE];</span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  fd_set rset, allset;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliAddr</span>, <span class="title">serverAddr</span>;</span></span><br><span class="line">  clilen = <span class="keyword">sizeof</span>(cliAddr);</span><br><span class="line">  bzero(&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">  bzero(&amp;cliAddr, clilen);</span><br><span class="line">  listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(PORT);</span><br><span class="line">  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(listenfd, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置 fd_set </span></span><br><span class="line">  maxfd = listenfd;</span><br><span class="line">  maxi = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">    client[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FD_ZERO(&amp;allset);           <span class="comment">//清空allset</span></span><br><span class="line">  FD_SET(listenfd, &amp;allset);  <span class="comment">// 讲listenfd 添加到allsetj集合中</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    rset = allset;  <span class="comment">//测试读集合</span></span><br><span class="line">    nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;  <span class="comment">//有新的连接请求</span></span><br><span class="line">      connfd = accept(listenfd, (struct sockaddr *)&amp;cliAddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123; <span class="comment">//将新的连接描述符保存</span></span><br><span class="line">        <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          client[i] = connfd;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == FD_SETSIZE) &#123;         <span class="comment">//达到最大</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      FD_SET(connfd, &amp;allset);</span><br><span class="line">      <span class="keyword">if</span> (connfd &gt; maxfd) maxfd = connfd;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; maxi) maxi = i;   <span class="comment">//最大的连接个数</span></span><br><span class="line">      --nready;</span><br><span class="line">      <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>) &#123;   <span class="comment">//没有可读的描述符</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;    <span class="comment">//检查所有的客户端传来的数据</span></span><br><span class="line">      <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;allset)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = readn(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">          close(sockfd);</span><br><span class="line">          FD_CLR(sockfd, &amp;allset);</span><br><span class="line">          client[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          writen(sockfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//没有可读的文件描述符</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 40501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="comment">// 读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> noreadcn, readcn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  noreadcn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (noreadcn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((readcn = read(fd, buf, noreadcn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        readcn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readcn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;             <span class="comment">// EOF</span></span><br><span class="line">    noreadcn -= readcn;  <span class="comment">//读取的数据少于maxcn继续读</span></span><br><span class="line">    buf += readcn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - noreadcn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nowritecn, writecn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  nowritecn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (nowritecn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((writecn = write(fd, buf, nowritecn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        writecn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writecn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;               <span class="comment">// EOF</span></span><br><span class="line">    nowritecn -= writecn;  <span class="comment">//写入的数据少于maxcn继续写</span></span><br><span class="line">    buf += writecn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - nowritecn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">  <span class="keyword">int</span> addresslen = <span class="keyword">sizeof</span>(serverAddr);</span><br><span class="line">  <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="keyword">char</span> mybuf[MAXLINE];</span><br><span class="line">  <span class="keyword">char</span> *buf = <span class="string">&quot;client\n&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> rc;</span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">  bzero(&amp;serverAddr, addresslen);</span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(PORT);</span><br><span class="line">  inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serverAddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  rc = connect(sockfd, (struct sockaddr *)&amp;serverAddr, addresslen);</span><br><span class="line">  <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//写入数据</span></span><br><span class="line">  writen(sockfd, (<span class="keyword">void</span> *)buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client send: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  bzero(mybuf, MAXLINE);</span><br><span class="line">  readn(sockfd, (<span class="keyword">void</span> *)mybuf, MAXLINE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;server read: %s\n&quot;</span>, mybuf);</span><br><span class="line">  close(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用select函数实现I/O复用&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>poll</title>
    <link href="http://example.com/jsblog/84bcfa45.html"/>
    <id>http://example.com/jsblog/84bcfa45.html</id>
    <published>2020-09-12T03:06:59.000Z</published>
    <updated>2020-09-12T03:53:08.264Z</updated>
    
    <content type="html"><![CDATA[<p>使用poll函数实现I/O复用. poll允许工作在任何描述符中，poll提供的功能与select函数类似。</p><a id="more"></a><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray,<span class="keyword">unsigned</span> <span class="keyword">long</span> nfds,<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>返回：若有就绪描述符则为其数目，若超时返回0，出错返回-1</p><p>第一个参数是指向一个结构体数组第一个元素的指针。每个元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> fd;                  <span class="comment">//需要检测的文件描述符</span></span><br><span class="line"> <span class="keyword">short</span> events;            <span class="comment">//请求的事件 </span></span><br><span class="line"> <span class="keyword">short</span> revents;           <span class="comment">//返回的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下表说明了能够作为events和revents的常量</p><p><img src="https://pic4.zhimg.com/80/v2-ffc0e68af82b0873a6794a4296e602eb_720w.jpg" alt="img"></p><p>结构体数组中元素的个数是由nfds参数指定。</p><p>timeout 参数指定poll函数返回前等待多长时间。它是一个指定应等待毫秒数的正值。取值如下表：</p><p>timeout值说明-1永远等待，直到有描述符就绪0立即返回，不阻塞进程&gt;0等待指定的毫秒数</p><p>使用poll函数建立的服务器端如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by silver on 2020/8/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 9873</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTQUE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 256</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd,confd,sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="keyword">int</span> maxcount = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">SerAddr</span>,<span class="title">Cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> Clilen = <span class="keyword">sizeof</span>(Cliaddr);</span><br><span class="line">    <span class="comment">//initializer</span></span><br><span class="line">    bzero(&amp;SerAddr,<span class="keyword">sizeof</span>(SerAddr));</span><br><span class="line">    bzero(&amp;Cliaddr,Clilen);</span><br><span class="line">    bzero(buf,MAXLINE);</span><br><span class="line">    listenfd = socket(AF_INET,SOCK_STREAM,IPPROTO_IP);</span><br><span class="line">    SerAddr.sin_family = AF_INET;</span><br><span class="line">    SerAddr.sin_port = htons(PORT);</span><br><span class="line">    SerAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,(struct sockaddr*)&amp;SerAddr,<span class="keyword">sizeof</span>(SerAddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd,LISTQUE) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; OPEN_MAX; count++) &#123;</span><br><span class="line">        client[count].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  n;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;server waiting....&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nready = poll(client,maxcount +<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) <span class="comment">// new client connection</span></span><br><span class="line">        &#123;</span><br><span class="line">            confd = accept(listenfd,(struct sockaddr*)&amp;Cliaddr,&amp;Clilen);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client address: %s\n&quot;</span>,inet_ntoa(Cliaddr.sin_addr));</span><br><span class="line">            <span class="keyword">if</span> (confd &lt; <span class="number">0</span>)&#123; perror(<span class="string">&quot;accept error&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (count = <span class="number">1</span>;  count&lt;OPEN_MAX ; count++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (client[count].fd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    client[count].fd = confd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == OPEN_MAX) &#123;<span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">            client[count].events = POLLRDNORM;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxcount) maxcount = count;</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//no more readable descriptions</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;=maxcount ; count++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[maxcount].fd) &lt; <span class="number">0</span>)&#123; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(client[count].revents &amp; (POLLRDNORM | POLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                n = read(sockfd,buf,MAXLINE);</span><br><span class="line">                <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        client[count].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    client[count].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    writen(sockfd,buf,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//no more readable descriptions</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用poll函数实现I/O复用. poll允许工作在任何描述符中，poll提供的功能与select函数类似。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>getsockopt and setsockopt</title>
    <link href="http://example.com/jsblog/1646cb2f.html"/>
    <id>http://example.com/jsblog/1646cb2f.html</id>
    <published>2020-09-12T03:04:35.000Z</published>
    <updated>2020-09-12T03:23:06.633Z</updated>
    
    <content type="html"><![CDATA[<p>了解一下 getsockopt 和 setsockopt</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：<br>sockfd: 必须是打开的套接字描述符;</p><p>level: 系统解释选项的代码或者是通用的套接字代码，或者是某个特定协议的代码(例如：IPv4、IPv6、TCP或者SCTP);</p><p>optname:选项名称</p><p>optval: 对于getsockopt()是讲选项当前值存放在 optval中，对于setsockopt()为系统设置新的选项值</p><p>optlen: 指定*optval的大小</p><p>结果：</p><p>函数执行成功返回0 出错返回-1</p><p>EBADF：sock不是有效的文件描述词<br>EFAULT：optval指向的内存并非有效的进程空间<br>EINVAL：在调用setsockopt()时，optlen无效<br>ENOPROTOOPT：指定的协议层不能识别选项<br>ENOTSOCK：sock描述的不是套接字</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 40501</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="comment">// 读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> noreadcn, readcn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  noreadcn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (noreadcn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((readcn = read(fd, buf, noreadcn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        readcn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readcn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;            <span class="comment">// EOF</span></span><br><span class="line">    noreadcn -= readcn; <span class="comment">//读取的数据少于maxcn继续读</span></span><br><span class="line">    buf += readcn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - noreadcn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> maxcn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nowritecn, writecn;</span><br><span class="line">  <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ptr;</span><br><span class="line">  nowritecn = maxcn;</span><br><span class="line">  <span class="keyword">while</span> (nowritecn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((writecn = write(fd, buf, nowritecn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中断错误&quot;</span>);</span><br><span class="line">        writecn = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (writecn == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">    nowritecn -= writecn; <span class="comment">//写入的数据少于maxcn继续写</span></span><br><span class="line">    buf += writecn;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxcn - nowritecn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, Confd;</span><br><span class="line">  fd_set rset, allset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">  <span class="keyword">socklen_t</span> clilen = <span class="keyword">sizeof</span>(clilen);</span><br><span class="line">  bzero(&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">  bzero(&amp;cliaddr, clilen);</span><br><span class="line">  listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">int</span> *)&amp;reuse,</span><br><span class="line">                 <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;set socket fail&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(PORT);</span><br><span class="line">  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(listenfd, <span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Confd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">int</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (getsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">int</span> *)&amp;opt, &amp;optlen) &lt;</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;get sockopt fail&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; keep-alive : %d\n&quot;</span>, opt);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *buf = <span class="string">&quot;welcome to you&quot;</span>;</span><br><span class="line">    writen(Confd, (<span class="keyword">void</span> *)buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    shutdown(Confd, SHUT_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解一下 getsockopt 和 setsockopt&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV for Windows</title>
    <link href="http://example.com/jsblog/2116d0b5.html"/>
    <id>http://example.com/jsblog/2116d0b5.html</id>
    <published>2020-09-12T03:00:29.000Z</published>
    <updated>2020-09-12T03:40:20.657Z</updated>
    
    <content type="html"><![CDATA[<p>我的配置是vs2015+opencv3.4.0。</p><a id="more"></a><p>opencv3.4.0可以在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Releases - OpenCV library 官方网站下载，当然你也可以在  </span><br><span class="line">OpenCV GitHub进行下载，如果在GitHub下载，在Windows上你需要自己编译，使用vs2015或者cmake进行编译</span><br></pre></td></tr></table></figure><p>使用cmake编译的时候首先打开cmd然后进入<strong>opencv安装目录下的源代码目录下，</strong>使用如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=D:/opencv</span><br></pre></td></tr></table></figure><p>”-DCMAKE_INSTALL_PREFIX=D:/opencv“ 设置其安装目录为D盘opencv目录。</p><p>就拿我的配置环境来说：</p><p>我先在官网下载opencv3.4.0.exe文件然后解压到D盘，首先要配置好环境变量，打开<strong>控制面板</strong>找到<strong>系统</strong>（或者系统与安全）</p><p><img src="https://pic3.zhimg.com/80/v2-dec01822104fa1e0edc58bea8c506b78_720w.jpg" alt="img"></p><p>点击高级系统设置，然后选择环境变量</p><p><img src="https://pic2.zhimg.com/80/v2-d8e2412a9b2f5b4a39a4ca35402e35cc_720w.jpg" alt="img"></p><p>点击环境变量，然后找到<strong>path变量</strong></p><p><img src="https://pic2.zhimg.com/80/v2-2716ee22eb16b2bc7b6aec39e32472ad_720w.jpg" alt="img"></p><p>点击新建，然后将</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc14\bin</span><br><span class="line">D:\opencv\opencv\build\x64\vc15\bin</span><br></pre></td></tr></table></figure><p>加入环境变量（我的opencv配置是64位的，所以在vs2015创建项目学习opencv的时候</p><p><img src="https://pic3.zhimg.com/80/v2-b17d6291df112e3cf963f81545927747_720w.jpg" alt="img"></p><p>一定要把x86改成x64还有就是一定把debug改成release才能运行，其他版本的opencv不一定要把debug改成release）</p><p>添加好环境变量之后，就是修改vs2015的c++配置,首先新建一个<strong>win32控制台项目</strong>，然后</p><p><img src="https://pic3.zhimg.com/80/v2-f990d5b644dbce886cde0c9d83c7d6f6_720w.jpg" alt="img"></p><p>点击属性管理器，</p><p><img src="https://pic1.zhimg.com/80/v2-a55e65fa2b922270b83ef380a37365c4_720w.jpg" alt="img"></p><p>点击</p><p><img src="https://pic1.zhimg.com/80/v2-8dd9f2c7e64db07b1967b0104c8f8340_720w.jpg" alt="img"></p><p>进入属性设置</p><p><img src="https://pic2.zhimg.com/80/v2-55934bf0d09dff9b742f2788a9e1452e_720w.jpg" alt="img"></p><p>在包含目录将opencv解压目录下的build目录下的include添加进去，在链接器中选择输入</p><p><img src="https://pic4.zhimg.com/80/v2-817bd286ef6360b08cea8e23046bd7bb_720w.jpg" alt="img"></p><p>在输入中的附加依赖项将（在我的电脑上就是）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc14\lib\opencv_world340.lib</span><br><span class="line">D:\opencv\opencv\build\x64\vc14\lib\opencv_world340d.lib  opencv_world340d.lib代表debug版本</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv\opencv\build\x64\vc15\lib\opencv_world340.lib</span><br><span class="line">D:\opencv\opencv\build\x64\vc15\lib\opencv_world340d.lib  opencv_world340d.lib代表debug版本</span><br></pre></td></tr></table></figure><p>选择14还是15要看你的visual c++编译器版本。我们来测试一下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat img = imread(&quot;D:\\opencv\\opencv\\sources\\samples\\data\\lena.jpg&quot;);</span><br><span class="line">imshow(&quot;lena image&quot;,img);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyWindow(&quot;lena image&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-b58b2195ff3a74de0f816370e40330a2_720w.jpg" alt="img"></p><p>当出现这张图片的时候就可以进行opencv的开发。其他版本的配置也与此类似</p><p><strong>python:</strong></p><p>首先在</p><p><a href="https://link.zhihu.com/?target=https://www.python.org/">Welcome to Python.orgwww.python.org<img src="https://picb.zhimg.com/v2-ff06c339780f23112c1cbbbb284158ff_ipico.jpg" alt="图标"></a></p><p>首先在</p><p><a href="https://link.zhihu.com/?target=https://www.python.org/">https://www.python.org/</a></p><p>官网上下载python3.5.4由于我的电脑是64位的所以我选择的是python3.5.4</p><p><img src="https://pic3.zhimg.com/80/v2-c0257b899bd67be788689b6a0066dbd9_720w.jpg" alt="img"></p><p>这个版本，在安装的时候要要把python添加进入环境变量，要不然就需要自己配置环境变量</p><p>安装好之后打开cmd然后输入python,如果出现下图结果则安装完成。</p><p><img src="https://pic4.zhimg.com/80/v2-d485d17d55d51482e0684f142784d308_720w.jpg" alt="img"></p><p>要安装opencv首先要安装numpy这个时候可以使用pip来进行安装opencv。安装命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br><span class="line">pip install opencv_python</span><br><span class="line">pip install opencv-contrib-python // opencv的扩展包，里边有一些图像处理的算法</span><br></pre></td></tr></table></figure><p>我们看个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&quot;imgs/2.jpg&quot;,cv.IMREAD_COLOR)</span><br><span class="line">cv.imshow(&quot;opencv_demo&quot;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>如果出现</p><p><img src="https://pic1.zhimg.com/80/v2-153b395419d1671cd205ca3bd2eb0694_720w.jpg" alt="img"></p><p>读入的图片表明python3.5.4+opencv环境已经配好啦</p><p>接下来就可以进行我们的opencv的开发了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我的配置是vs2015+opencv3.4.0。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>读写图片</title>
    <link href="http://example.com/jsblog/96b8a012.html"/>
    <id>http://example.com/jsblog/96b8a012.html</id>
    <published>2020-09-12T02:58:56.000Z</published>
    <updated>2020-09-12T03:02:20.580Z</updated>
    
    <content type="html"><![CDATA[<p>上一话我们已经把opencv的环境配置完成，那么我们接下来分析一下上一话的例子。</p><a id="more"></a><p><strong>图像读入：imread</strong></p><p>首先我们来看一下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat img = imread(&quot;D:\\opencv\\opencv\\sources\\samples\\data\\lena.jpg&quot;);</span><br><span class="line">imshow(&quot;lena image&quot;,img);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyWindow(&quot;lena image&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是使用c++来写的，而opencv就是机遇c++开发的，所以我们使用c++来对<strong>imread</strong>,<strong>imshow</strong>以及<strong>imwrite</strong>这三个API进行讲解。当然在使用c++调用opencv的API有两种方法，一种就是在前面引用opencv的命名空间，然后直接调用其API;二是使用域解析符（::）加上要调用的函数名称。在这个例子中我所使用的就是第一种方法。</p><p>接下来我们看一下imread函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat cv::imread(const string&amp; filename,int flags&#x3D;MREAD_COLOR);</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>**filename:**需要加载的文件</li><li>**flags:**是指加载图片时的标识，指定图片的类型</li></ul><p>Mat类型是一个矩阵类型，如果imread对文件无法解码，就会返回一个NULL，空的矩阵。</p><p>opencv支持的图片包含以下几种</p><ul><li>Windows bitmaps - *.bmp, *.dib (always supported)</li><li>JPEG files - *.jpeg, <em>.jpg, *.jpe (see the *Notes</em> section)</li><li>JPEG 2000 files - *.jp2 (see the <em>Notes</em> section)</li><li>Portable Network Graphics - *.png (see the <em>Notes</em> section)</li><li>WebP - *.webp (see the <em>Notes</em> section)</li><li>Portable image format - *.pbm, *.pgm, *.ppm (always supported)</li><li>Sun rasters - *.sr, *.ras (always supported)</li><li>TIFF files - <em>.tiff, *.tif (see the *Notes</em> section)</li></ul><p><strong>NOTE：</strong></p><p>imread这个函数读取图片是根据文件内容来读取，而不是根据文件的扩展名。</p><p><strong>imread的flags有以下几种：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMREAD_UNCHANGED            = -1, //返回包含alpha通道的加载图像</span><br><span class="line">   IMREAD_GRAYSCALE            = 0,  //返回一个灰度图像</span><br><span class="line">   IMREAD_COLOR                = 1,  //返回一个BGR通道的图像</span><br><span class="line">   IMREAD_ANYDEPTH             = 2,  //当输入具有相应的深度时返回16位/ 32位图像，否则将其转换为8位。.</span><br><span class="line">   IMREAD_ANYCOLOR             = 4,  //则以任何可能的颜色格式读取图像。</span><br><span class="line">   IMREAD_LOAD_GDAL            = 8,  //使用GDAL的驱动加载图像。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_2  = 16, //将图像转换为单通道灰度图像，图像大小减少1/2。</span><br><span class="line">   IMREAD_REDUCED_COLOR_2      = 17, //转换图像的3通道BGR彩色图像和图像的大小减少1/2。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_4  = 32, //将图像转换为单通道灰度图像，图像大小减少1/4。</span><br><span class="line">   IMREAD_REDUCED_COLOR_4      = 33, //转换图像的3通道BGR彩色图像和图像的大小减少1/4。</span><br><span class="line">   IMREAD_REDUCED_GRAYSCALE_8  = 64, //将图像转换为单通道灰度图像，图像大小减少1/8。</span><br><span class="line">   IMREAD_REDUCED_COLOR_8      = 65, //转换图像的3通道BGR色彩图像和图像大小减少1/8。</span><br><span class="line">   IMREAD_IGNORE_ORIENTATION   = 128 //不旋转图像根据EXIF的定位标志。</span><br></pre></td></tr></table></figure><p><strong>图像的显示：imshow</strong></p><p>imshow主要用于显示图像，将加载到内存中的图像显示出来</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void imshow(const string&amp; winname,InputArray mat);</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>第一个参数: const string&amp;类型的winname,将要显示的窗口标识名称</li><li>第二个参数:InputArray类型的mat，需要显示的图像</li></ul><p><strong>图像的保存：imwrite</strong></p><p>虽然在例子中没有使用imwrite但是有必要说明一下imwrite这个函数的使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool imwrite(const string&amp; filename,InputArray img,</span><br><span class="line">                             const vector&lt;int&gt;&amp; params=vector&lt;int&gt;());</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong></p><ul><li>第一个参数：const string&amp;类型的filename，要保存的文件名，要带上后缀例如”123.jpg”.</li><li>第二个参数：InputArray类型的img，一般填入一个Mat类型的图像数据</li><li>第三个参数：const std::vector&amp; params表示为特定格式保存的参数编码，它有一个默认值std::vector&lt; int &gt;()，所以一般情况下不用写。如果要填写，则有以下几个方面需要了解：</li></ul><ol><li>对于JPEG格式的图片，这个参数表示从0-100的图片质量（CV_IMWRITE_JPEG_QUALITY）,默认值是95.</li><li>对于PNG格式的图片，这个参数表示压缩级别（CV_IMWRITE_PNG_COMPRESSION）从0-9.较高的值意味着更小的尺寸和更长的压缩时间而默认值是3.</li><li>对于PPM，PGM或PBM格式的图片，这个参数表示一个二进制格式标志（CV_IMWRITE_PXM_BINARY），取值为0或1，而默认值为1.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一话我们已经把opencv的环境配置完成，那么我们接下来分析一下上一话的例子。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>色彩空间转换</title>
    <link href="http://example.com/jsblog/ba11d693.html"/>
    <id>http://example.com/jsblog/ba11d693.html</id>
    <published>2020-09-12T02:31:05.000Z</published>
    <updated>2020-09-12T03:28:10.098Z</updated>
    
    <content type="html"><![CDATA[<p>首先来了解一下opencv提供的API</p><a id="more"></a><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvtColor(InputArray src,OutputArray dst,int code,int dstCn=0);</span><br></pre></td></tr></table></figure><p><strong>paraemters:</strong></p><ul><li>第一个参数：InputArray类型的src,表示输入的图像矩阵</li><li>第二个参数：OutputArray类型的dst,表示输出的图像矩阵</li><li>第三个参数：int类型的code,表示颜色转换标识符</li><li>第四个参数目标图像的通道数，该参数为0时，目标图像根据源图像的通道数和具体操作自动决定</li></ul><p><strong>Note:</strong></p><p>第三个参数要根据图像的载入类型进行选择。</p><p>在BGR图像与XYZ图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2XYZ </span><br><span class="line">COLOR_RGB2XYZ </span><br><span class="line">COLOR_XYZ2BGR </span><br><span class="line">COLOR_XYZ2RGB</span><br></pre></td></tr></table></figure><h2 id="YCrCb颜色空间"><a href="#YCrCb颜色空间" class="headerlink" title="YCrCb颜色空间"></a><strong>YCrCb颜色空间</strong></h2><p>该颜色空间广泛的用于视频压缩和图像压缩方案，不能算是纯粹的颜色空间，因为它是BGR颜色空间的一种解码方式。 <strong>该颜色空间广泛的应用于MPEG和JPEG等视频和图像压缩方案。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y表示亮度 </span><br><span class="line">Cr : RGB空间R通道和Y差值 </span><br><span class="line">Cb: RGB空间B通道和Y差值</span><br></pre></td></tr></table></figure><p>在BGR图像与YCrCb图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2YCrCb</span><br><span class="line">COLOR_RGB2YCrCb </span><br><span class="line">COLOR_YCrCb2BGR </span><br><span class="line">COLOR_YCrCb2RGB</span><br></pre></td></tr></table></figure><h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>HSV颜色空间属于面向色度的颜色坐标系的一种，这种颜色模型<strong>接近于人类颜色感知的仿真模型</strong>，而在其他颜色模型中，例如RGB，一副图像被视为3中基色的叠加。</p><p>在BGR图像与YCrCb图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2HSV</span><br><span class="line">COLOR_RGB2HSV </span><br><span class="line">COLOR_HSV2BGR </span><br><span class="line">COLOR_HSV2RGB</span><br></pre></td></tr></table></figure><p><strong>GARY色彩空间</strong></p><p>gray图像色彩空间就是灰度图像。</p><p>在BGR图像与gray图像之间的转换，此时的标识code便是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2GRAY</span><br><span class="line">COLOR_RGB2GRAY</span><br><span class="line">COLOR_GRAY2RGB </span><br><span class="line">COLOR_GRAY2BGR</span><br></pre></td></tr></table></figure><p><strong>HLS色彩空间</strong></p><p>HLS颜色空间，三个分量分别是色相（H）、亮度（L）、饱和度（S），这三个取值范围是</p><ul><li>0 &lt;= H &lt;= 360</li><li>0 &lt;= L &lt;= 1</li><li>0 &lt;= S &lt;= 1</li></ul><p>BGR与HLS图像之间的转换code如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2HLS</span><br><span class="line">COLOR_RGB2HLS</span><br><span class="line">COLOR_HLS2RGB </span><br><span class="line">COLOR_HLS2BGR</span><br></pre></td></tr></table></figure><p>YUV颜色模型中，U、V表示的是色度(Chrominance/Chroma)。YUV是欧洲电视系统所采用的颜色模型(属于PAL制式)，颜色被分为一个亮度信号和两个色差信号进行传输</p><p>BGR与YUV图像之间的转换code如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2YUV</span><br><span class="line">COLOR_RGB2YUV</span><br><span class="line">COLOR_YUV2RGB </span><br><span class="line">COLOR_YUV2BGR</span><br></pre></td></tr></table></figure><p>我们来看一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Mat srcImage = imread(&quot;E:\\vs2015\\imgs\\66.jpg&quot;);</span><br><span class="line">Mat hsvImage, YcrcbImage, HlsImage,grayImage,xyzImage,YuvImage;</span><br><span class="line">cvtColor(srcImage, xyzImage, COLOR_BGR2XYZ); //转换到XYZ</span><br><span class="line">cvtColor(srcImage,grayImage,COLOR_BGR2GRAY); //转换到灰度图像</span><br><span class="line">cvtColor(srcImage, HlsImage, COLOR_BGR2HLS); //转换到HLS色彩空间</span><br><span class="line">cvtColor(srcImage, YcrcbImage, COLOR_BGR2YCrCb); //转换到YCrCb色彩空间</span><br><span class="line">cvtColor(srcImage, hsvImage, COLOR_BGR2HSV);  //转换到HSV色彩空间</span><br><span class="line">cvtColor(srcImage, YuvImage, COLOR_BGR2YUV);</span><br><span class="line">//将图片显示出来</span><br><span class="line">imshow(&quot;input&quot;, srcImage);</span><br><span class="line">imshow(&quot;YUV&quot;,YuvImage);</span><br><span class="line">imshow(&quot;gray&quot;,grayImage);</span><br><span class="line">imshow(&quot;hsv&quot;, hsvImage);</span><br><span class="line">imshow(&quot;Ycrcb&quot;, YcrcbImage);</span><br><span class="line">imshow(&quot;hls&quot;, HlsImage);</span><br><span class="line">imshow(&quot;XYZ&quot;, xyzImage);</span><br><span class="line">waitKey(0);</span><br><span class="line">destroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9a7249d28bc077c0f9e319c111729e01_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-b24f95bb1d9b3d17d25f0352c66311f7_720w.jpg" alt="img"></p><p><img src="https://picb.zhimg.com/80/v2-d05ce28660f6234fdf23c84585eb4711_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e309901516618e0d6bf2cd26bfea5bec_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ff58ae8c80971db00acccff137000700_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-242710cf960ac30737476cb06757c228_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-79e39bf12d1fe6a3616c21ad80a5c0ba_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先来了解一下opencv提供的API&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV for MinGW</title>
    <link href="http://example.com/jsblog/9a6917e7.html"/>
    <id>http://example.com/jsblog/9a6917e7.html</id>
    <published>2020-09-12T02:29:24.000Z</published>
    <updated>2020-09-12T03:58:53.651Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个opencv的入门的小白来说，要学会如何如何去编译opencv。</p><p>当然在windows使用mingw-w64编译opencv会遇到一些坑。 </p><a id="more"></a><p>不过我们所遇到的坑，必定有前辈遇到过这种相同的问题，所以今天我就来说一下</p><p>如何使用开源的mingw-w64来编译opencv</p><p><strong>编译环境</strong></p><p>mingw版本：mingw-w64 5.4.0 (64 bit)</p><p>CMAKE ： cmake 3.11.4 (64 bit)</p><p>opencv : 3.4.4</p><p>(我也编译过4.0.0虽然也成功了，不过由于其使用的时候必须使用c++11来开发，所以我就放弃了，改用了3.4.4)</p><p><strong>编译过程：</strong></p><p>Step 1:</p><p>配置相应的编译环境，从<a href="https://link.zhihu.com/?target=https://sourceforge.net/projects/mingw-w64/">MinGW-w64 - for 32 and 64 bit Windows</a> 这个网站你可以下载适合你自己的mingw-w64的版本。下载好之后为mingw-w64配置环境变量。我将下载好的mingw x86_64-5.4.0-release-posix-sjlj-rt-v5-rev0.7z</p><p><img src="https://pic4.zhimg.com/80/v2-a83da9dbd0b147549f97e99be4251642_720w.jpg" alt="img"></p><p>也就是第一个，解压到了d盘下MinGW目录下，所以我在我的电脑上的配置环境为</p><p><img src="https://pic1.zhimg.com/80/v2-c2bde3ac4c42399a2631899e8c07de92_720w.jpg" alt="img"></p><p>环境变量为D:\MinGW\mingw\bin</p><p><img src="https://pic1.zhimg.com/80/v2-cb180653db250bb90902a6a087b06f59_720w.jpg" alt="img"></p><p>如果配置好了，可以验证一下，如果在dos下输入gcc -v出现</p><p><img src="https://picb.zhimg.com/80/v2-72e4295970adcf8fc1488ddbae307d7c_720w.jpg" alt="img"></p><p>则说明配置完成</p><p><strong>Step2.</strong></p><p>配置好gcc开发环境之后，你也可以使用gcc开发c程序或者c++程序。我们的目的是为了编译opencv这个计算机视觉库。所以第二步，配置cmake，你可以直接从 <a href="https://link.zhihu.com/?target=https://cmake.org/download/">https://cmake.org/download/</a> 这个网址直接下载相应的cmake工具，然后安装。安装的时候将cmake添加进环境变量。</p><p>Step3</p><p>将下载好的opencv3.4.4和opencv_contrib3.4.4解压。为了方便我将它们放在了同一个文件夹下，然后启动cmake-gui</p><p><img src="https://pic4.zhimg.com/80/v2-ec0f1bd0bd9e1e5b78933befa7b26fe6_720w.jpg" alt="img"></p><p>我将opencv放在了F盘，为了方便寻找我就在F盘新建了一个文件夹，source code 选择opencv-3.4.4,输出路径为F:/opencv/build</p><p>然后点击 configure</p><p><img src="https://pic3.zhimg.com/80/v2-87f2081ce6f5ef0a89126a6e7703ae19_720w.jpg" alt="img"></p><p>点击yes</p><p><img src="https://pic2.zhimg.com/80/v2-05aec86d816229393a75cf77e26f2991_720w.jpg" alt="img"></p><p>选择mingw makefiles。点击finnish,中间要下载一些东西，所以要保证有网络，有可能需要翻墙才能configure完成。</p><p><img src="https://pic4.zhimg.com/80/v2-9a0ea65e001cc6dd8c59805f634cd049_720w.jpg" alt="img"></p><p>其中 不勾选</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENABLE_PRECOMPILED_HEADERS</span><br><span class="line">WITH_MSMF</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-28c5958f47d4f42dc979c58e6c245a4a_720w.png" alt="img"></p><p>这一栏是配置opencv_contrib的modules。</p><p>勾选</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENABLE_CXX11</span><br></pre></td></tr></table></figure><p>除了配置以上的之外还要修改一些源代码</p><p>在opencv-3.4.4中的</p><p>modules/videoio/src/cap_dshow.cpp中的</p><p><img src="https://picb.zhimg.com/80/v2-8801099898f2836d6b803fcd0a2fdf6a_720w.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “cap_dshow.hpp”</span></span><br></pre></td></tr></table></figure><p>上一行添加</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NO_DSHOW_STRSAFE</span><br></pre></td></tr></table></figure><p>即：</p><p><img src="https://pic3.zhimg.com/80/v2-6ded081864bb8b58def07079b1081364_720w.jpg" alt="img"></p><p>然后configure ，完成之后，执行generate</p><p>generate完成之后就可以进行第四步。</p><p><strong>Step4</strong></p><p>在build目录下打开Dos窗口</p><p>输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make</span><br></pre></td></tr></table></figure><p>如果想加速编译可以在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make -j 4</span><br></pre></td></tr></table></figure><p><img src="https://picb.zhimg.com/80/v2-91ecbae494ea3225d4ea6b704ee2df54_720w.jpg" alt="img"></p><p>等到编译完成100%（根据自己的电脑性能选择线程）我选择12是为了加速编译</p><p>你可以在编译的时候看会书，估计要1个小时</p><p><img src="https://pic3.zhimg.com/80/v2-645c94ab02e32b51eb0c91bd1dfe0495_720w.jpg" alt="img"></p><p>就可以使用</p><p><img src="https://pic2.zhimg.com/80/v2-92d2c18a2abbb6ecf993f234f3045fac_720w.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make install</span><br></pre></td></tr></table></figure><p>直到安装完成</p><p><img src="https://picb.zhimg.com/80/v2-ab0adbf3c5c92d62505d296281567b05_720w.jpg" alt="img"></p><p>这样opencv库就编译完成，你可以在build文件夹中找到install这个文件夹，</p><p>我将install文件夹移动到了D盘下的MinGW文件下，然后配置相应的环境变量，以便于cmake工具能够找到opencv这个库（我个人的配置）</p><p>新建一个变量</p><p><img src="https://pic1.zhimg.com/80/v2-9f083be6602529b827ab4b6d5bfdcc35_720w.jpg" alt="img"></p><p>点击确定，然后编辑PATH变量</p><p><img src="https://pic3.zhimg.com/80/v2-24b781b3fdb990747c9c4d87551db7b0_720w.jpg" alt="img"></p><p>添加一项，因为我的是64位所以就是x64，如果是32位则其中x64换成x86</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%OpenCV_DIR%\x64\mingw\bin</span><br></pre></td></tr></table></figure><p>就可以使用cmake，和mingw来开发opencv应用程序了</p><p>在编译的时候可能会遇到其他vs_version.rc.obj无法生成的问题</p><p>根据自己的编译目录手动生成 vs_version.rc.obj</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windres E:\opencv\build\modules\core\vs_version.rc -O coff E:\opencv\build\modules\core\CMa</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个opencv的入门的小白来说，要学会如何如何去编译opencv。&lt;/p&gt;
&lt;p&gt;当然在windows使用mingw-w64编译opencv会遇到一些坑。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Thread 入门</title>
    <link href="http://example.com/jsblog/ac99a763.html"/>
    <id>http://example.com/jsblog/ac99a763.html</id>
    <published>2020-09-07T12:52:36.000Z</published>
    <updated>2020-09-12T03:22:55.279Z</updated>
    
    <content type="html"><![CDATA[<p>在c++11之前c++没有提供对并发编程提供语言级别的支持，而在c++11在增加了线程以及线程相关的类，很方便的支持并发编程，提高了代码的可移植性。</p><a id="more"></a><p>创建线程：使用std::thread类可以创建新的线程，可以使用std::this_thread::get_id() 查看当前线程的id.。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ <span class="keyword">this</span> thread id is ” &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">      t.join();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用join函数会阻塞主线程，直到线程函数执行结束，如果func有返回值，则返回值被忽略。而如果不想阻塞主线程，可以使用detach函数，但是detach之后，线程函数就被分离，无法与线程函数发生联系，也不知道线程函数会何时执行完。</p><p>当然，可以构造传入参数的线程如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ str = ” &lt;&lt; str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func,”test”)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不能复制，但是可以被转移，利用移动语义（std::move）将一个线程的资源转给另外一个线程。也可以使用std::bind以及lambda函数表达式构造新的线程。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “ str = ” &lt;&lt; str&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">([](<span class="built_in">std</span>::<span class="built_in">string</span> str)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>&#125;,”test”)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::bind(func,”test”))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::thread t2;</span><br><span class="line">    t2 = <span class="built_in">std</span>::move(t1); <span class="comment">//ok</span></span><br><span class="line">    t.join();</span><br><span class="line">    t1.join(); <span class="comment">// system_error</span></span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在c++11之前c++没有提供对并发编程提供语言级别的支持，而在c++11在增加了线程以及线程相关的类，很方便的支持并发编程，提高了代码的可移植性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>FileStorage</title>
    <link href="http://example.com/jsblog/5c7f6c43.html"/>
    <id>http://example.com/jsblog/5c7f6c43.html</id>
    <published>2020-09-07T12:18:24.000Z</published>
    <updated>2020-09-07T12:54:43.230Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV中可以使用FileStorage 对xml，yml等文本文件的读写。可扩展<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">标记语言</a>，<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>的子集，简称XML。是一种用于标记电子文件使其具有结构性的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436">标记语言</a>。YAML是一个可读性高，用来表达数据<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的格式。</p><a id="more"></a><p>首先看一下fileStorage的构造函数和析构函数：</p><p><strong>构造函数：</strong></p><p>FileStorage::FileStorage(const String&amp; filename,int flags,const String&amp; encoding= String());</p><p>filename: 文件名称</p><p>flags：文件的打开模式，主要有以下几种：</p><p>READ: 以读的形式打开</p><p>WRITE:以写的形式打开</p><p>APPEND:以追加的形式打开</p><p>MEMORY: 从source 中读取数据或者写入数据到缓存中（通过FileStorage::release返回）</p><p>FORMAT_MASK: 格式化数据的掩码</p><p>FORMAT_AUTO : 自动格式化数据</p><p>FORMAT_XML： 将文件按照xml方式读写</p><p>FORMAT_YAML: 将文件按照yaml方式读写</p><p>FORMAT_JSON 将文件按照JSON方式读写</p><p>enconding: 文件的编码格式</p><p><strong>析构函数：</strong></p><p>FileStorage::~FileStorage()</p><p><strong>几个重要的函数：</strong></p><p>FileStorage::release() ： 关闭文件</p><p>FileStorage::isOpened() ：判断文件是否打开</p><p>FileStorage::Open(const String&amp; filename,int flags,const String&amp; encoding= String()) 与构造函数一样，将文件按照指定的格式以及编码打开。</p><p>operator&gt;&gt; ： 重载运算符，将节点数据读入到某个变量中</p><p>operator&lt;&lt; : 将数据保存到某个节点中</p><p>operator[] : 取出某个节点的数据</p><p>以yaml文件为例</p><p>读写数据代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/opencv.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;test.yml&quot;</span>,FileStorage::WRITE)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> fps = <span class="number">5</span>;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;fps&quot;</span> &lt;&lt; fps;</span><br><span class="line">    Mat m = Mat::eye(<span class="number">2</span>,<span class="number">3</span>,CV_32F);</span><br><span class="line">    Mat m1 = Mat::eye(<span class="number">3</span>,<span class="number">2</span>,CV_32F);</span><br><span class="line">    Mat result = (m+<span class="number">1</span>).mul(m+<span class="number">3</span>);</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; result;</span><br><span class="line">    fs.release();</span><br><span class="line">    <span class="comment">//读出数据</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs2</span><span class="params">(<span class="string">&quot;test.yml&quot;</span>,FileStorage::READ)</span></span>;</span><br><span class="line">    Mat r;</span><br><span class="line">    fs2[<span class="string">&quot;result&quot;</span>] &gt;&gt; r;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r  &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fs2.release();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存在test.yml的数据如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML:1.0</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">fps:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">result:</span> <span class="type">!!opencv</span><span class="string">-matrix</span></span><br><span class="line">   <span class="attr">rows:</span> <span class="number">2</span></span><br><span class="line">   <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">   <span class="attr">dt:</span> <span class="string">f</span></span><br><span class="line">   <span class="attr">data:</span> [ <span class="number">8</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span>, <span class="number">8</span><span class="string">.</span>, <span class="number">3</span><span class="string">.</span> ]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenCV中可以使用FileStorage 对xml，yml等文本文件的读写。可扩展&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&quot;&gt;标记语言&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073&quot;&gt;标准通用标记语言&lt;/a&gt;的子集，简称XML。是一种用于标记电子文件使其具有结构性的&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436&quot;&gt;标记语言&lt;/a&gt;。YAML是一个可读性高，用来表达数据&lt;a href=&quot;https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BA%8F%E5%88%97%E5%8C%96&quot;&gt;序列化&lt;/a&gt;的格式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
