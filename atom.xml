<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林森</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-26T10:32:50.768Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步操作</title>
    <link href="http://example.com/jsblog/ac8be0e6.html"/>
    <id>http://example.com/jsblog/ac8be0e6.html</id>
    <published>2020-12-26T07:56:26.000Z</published>
    <updated>2020-12-26T10:32:50.768Z</updated>
    
    <content type="html"><![CDATA[<p>假设有两个线程，一个用来进行数据的处理，另外一个线程用来将计算好的线程输出。<a id="more"></a>如果没有将数据进行处理，那么就不应该将数据输出。为了实现同步数据，第一个线程设置一个标志，用来表明数据已经处理完成，并且第二个线程在这个标志设置之前不能读取进行数据的处理。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_data;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">readyFlag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessData</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    g_data = x;</span><br><span class="line">    readyFlag.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!readyFlag.load())&#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; g_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把等待数据的低效循环一边，当非原子的读和写对同一数据结构进行无序访问时，将有可能导致未定义的行为发生。强制访问顺序是由atomic的类型的数据readyFlag变量进行操作完成的，这些操作通过“先行发生”和“同步发生”确定必要的顺序。</p><p>所谓同步发生关系是指：只能在原子类型之间进行的操作。同步发生的基本思想：对数据进行适当标记的原子写操作，同步与对数据进行适当标记的原子读操作，读取的是在写之后的数据。如果线程A存储了一个值，并且线程B读取了这个值，线程A的存储操作和线程B的载入才足以呼吁事故同步关系。如上述代码。</p><p>所谓的先行关系是指在一个程序中，基本的操作顺序是：它指定了某个操作去影响另一个操作。如果一个操作排在另外一个操作之后，那么这个操作就是先执行的。如果代码中操作A发生在操作B之前，那么A就先行与B发生。如果A操作在一个线程上，并且操作B线程同步，那么A就线程间先行与B。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;假设有两个线程，一个用来进行数据的处理，另外一个线程用来将计算好的线程输出。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>atomic操作</title>
    <link href="http://example.com/jsblog/3152afc0.html"/>
    <id>http://example.com/jsblog/3152afc0.html</id>
    <published>2020-12-26T04:39:12.000Z</published>
    <updated>2020-12-26T09:35:07.336Z</updated>
    
    <content type="html"><![CDATA[<p>最基本的原子整数类型就是std::atomic<boo>。<a id="more"></a>它比std::atomic_flag拥有更加齐全的布尔标志特性。可以使用一个非原子的bool类型进行构造，也可以使用一个非原子类型的bool值进行赋值。</boo></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">ready</span><span class="params">(ture)</span></span>;</span><br><span class="line">ready = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>在原子类型中，赋值操作通过返回值（返回相关的非原子类型）完成，而非返回引用。std::atomic也支持对值的普通查找，其会将对象隐式转换为一个普通的类型值，或者调用load()函数来获取这个类型值。store()是一个存储操作，load()是一个加载操作即读取操作。exchange()则是一个“读-改-写”操作,当前值与预期值一致时，存储新值的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">ready</span><span class="params">(ture)</span></span>;</span><br><span class="line">ready = <span class="literal">false</span>;</span><br><span class="line">boo x = ready.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">ready.store(<span class="literal">true</span>);</span><br><span class="line">x = ready.exchange(<span class="literal">false</span>,<span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure><p>还有就是比较/交换操作，compare_exchange_weak()和compare_exchange_strong()成员函数，这个操作时原子类型编程的基础：它比较原子变量的当前值和预期值，当两者相等时，存储预期值。当两者不等时，预期值会被更新为原子变量中的值，此操作的结果时一个bool值，为true执行存储操作，为false则更新期望值。但是对于compare_exchange_weak()函数，当原始值与预期值一致时，存储也有可能会失败。</p><p>原子指针类型，可以使用内置类型或自定义类型T,通过特化std::atomic&lt;T*&gt;进行定义，虽然接口和std::atomic<T>的一致，但是它的操作时对于相关类型的指针，在使用load(),store()，exchange(),compare_exchange_weak()和compare_exchange_strong()成员函数时,获取与返回的类型都是指针类型T *。</T></p><p>使用原子类型的一个示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_data</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Set_data</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    g_data.store(x,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = g_data.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread id : &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; stl;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; ptl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        stl.emplace_back(<span class="built_in">std</span>::thread(Set_data,i));</span><br><span class="line">        ptl.emplace_back(<span class="built_in">std</span>::thread(PrintX));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        stl[i].join();</span><br><span class="line">        ptl[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最基本的原子整数类型就是std::atomic&lt;boo&gt;。&lt;/boo&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>atomic_flag</title>
    <link href="http://example.com/jsblog/17f63eb7.html"/>
    <id>http://example.com/jsblog/17f63eb7.html</id>
    <published>2020-12-25T12:40:26.000Z</published>
    <updated>2020-12-25T12:41:07.883Z</updated>
    
    <content type="html"><![CDATA[<p>std::atomic_flag是最简单的标准原子类型，它表示了一个bool标志。<a id="more"></a>这个类型的对象可以在两个状态切换：设置和清除。</p><p>std::atomic_flag类型的对象必须被ATOMIC_FLAG_INIT初始化，初始化标志位是清除状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure><p>这适用于任何对象的声明，并且可以在任意范围内。它是唯一需要以这种方式初始化的原子类型，它是唯一保证无锁的类型。std::atomic_flag在首次使用时，都需要初始化。当std::atomic_flag对象已经初始化，那么对于此对象只能做三件事情：销毁，清除或设置。这些操作对应的函数分别是： clear()成员函数，和test_and_set()成员函数。</p><p>clear()和test_and_set()成员函数可以指定内存顺序。clear()是一个存储操作，所以不能有memory_order_acquire或memory_order_acq_rel语义。但是test_and_set()是一个读-改-写操作，所有可以应用于任何内存顺序标签。每一个原子操作，默认的内存顺序都是memroy_order_seq_cst。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line"><span class="keyword">bool</span> x = f.test_and_set()</span><br></pre></td></tr></table></figure><p>对于std::atomic_flag对象不能进行拷贝构造，也不能将一个对象赋予另一个std::atomic_flag对象。copy constructor和copy assignment 都是不支持的，对于所有的原子类型而言。因为赋值和拷贝构造都会包含操作的原子性。下面使用std::atomic_flag实现一个自选互斥锁。初始化标志是“清除”，并且互斥量处于解锁状态。为了锁上互斥量，循环运行test_and_set()直到旧值为false，就意味着这个线程已经被设置为true了。解锁互斥量是一件很简单的事情，将标志清除即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spinlock_mutex</span>&#123;</span></span><br><span class="line"><span class="built_in">std</span>::atomic_flag _flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Spinlock_mutex() : _flag(ATOMIC_FLAG_INIT)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(_flah.test_and_set(<span class="built_in">std</span>::memory_order_acquire))&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _flag.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用std::atomic_flag的示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic_flag f = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f.test_and_set(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread id is : &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">f.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; tls;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">tls.emplace_back(<span class="built_in">std</span>::thread(ThreadTest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : tls) &#123;</span><br><span class="line">it.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下表是一个内存顺序模型和值：</p><table><thead><tr><th align="center">Memory Order 值</th><th align="center">Memory Order 类型</th></tr></thead><tbody><tr><td align="center">memory_order_relaxed</td><td align="center">Relaxed</td></tr><tr><td align="center">memory_order_consume</td><td align="center">Consume</td></tr><tr><td align="center">memory_order_acquire</td><td align="center">Acquire</td></tr><tr><td align="center">memory_order_release</td><td align="center">Release</td></tr><tr><td align="center">memory_order_acq_rel</td><td align="center">Acquire/Release</td></tr><tr><td align="center">memory_order_seq_cst</td><td align="center">Sequentially consistent</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;std::atomic_flag是最简单的标准原子类型，它表示了一个bool标志。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>NumPy面向数组</title>
    <link href="http://example.com/jsblog/2da432df.html"/>
    <id>http://example.com/jsblog/2da432df.html</id>
    <published>2020-12-24T12:24:42.000Z</published>
    <updated>2020-12-24T13:10:09.620Z</updated>
    
    <content type="html"><![CDATA[<p>使用NumPy数组可以使你利用简单的数组表达式完成多种数据操作任务，而无须写些大量循环。<a id="more"></a>这种利用数组表达式来替代显式循环的方法，称为向量化。通常，向量化的数组操作会比纯Python的等价实现在速度上快一到两个数量级（甚至更多），这对所有种类的数值计算产生了最大的影响。附录A中我解释的广播机制，就是向量化计算的有效方式。<br>作为一个简单的示例，假设我们想要对一些网格数据来计算函数sqrt(x^2 + y^2)的值。np.meshgrid函数接收两个一维数组，并根据两个数组的所有(x, y)对生成一个二维矩阵,并使用matplotlib函数imshow根据函数值生成图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">points = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">xs,ys = np.meshgrid(points,points)</span><br><span class="line">z = np.sqrt(xs**<span class="number">2</span>+ys**<span class="number">2</span>)</span><br><span class="line">plt.imshow(z)</span><br><span class="line">plt.title(<span class="string">&quot;Image plot of $\sqrt&#123;x^2+y^2&#125;$ for a grid value&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/jsblog/meshgrid.jpg" alt="mesh"></p><p>将条件逻辑作为数组操作，numpy的where函数是三元表达式x if condition else y的向量化版本。</p><p>许多关于计算整个数组统计值或关于轴向数据的数学函数，可以作为数组类型的方法被调用。你可以使用聚合函数（通常也叫缩减函数），比如sum、mean和std（标准差），既可以直接调用数组实例的方法，也可以使用顶层的NumPy函数。像means，sum函数可以接收一个可选参数axis,用于计算给定轴上的统计值，形成一个下降一维的数组。下表是基础数组统计方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sum</td><td>沿轴向计算所有元素的累和，0长度的数组累和为0</td></tr><tr><td>mean</td><td>数学平均值，0长度的数组的平均值为NaN</td></tr><tr><td>std,var</td><td>标准差，方差</td></tr><tr><td>min,max</td><td>最小值和最大值</td></tr><tr><td>argmin,argmax</td><td>最小最大值的位置</td></tr><tr><td>cumsum</td><td>从0开始元素累和</td></tr><tr><td>cumrod</td><td>从1开始元素累积</td></tr></tbody></table><p>对于布尔值数组，有两个非常有用的方法any和all。any检查数组中是否至少有一个True，而all检查是否每个值是否都为True</p><p>对于排序而言，NumPy数组可以使用sort函数位排序，也可以对不同的axis进行排序，顶层的np.sort()返回的是已排好序的数组而不是对原数组的位置排序。</p><p>对于一些NumPy的nadarray的基础集合操作如下：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>unique(x)</td><td>计算x的唯一值并排序</td></tr><tr><td>intersect1d(x,y)</td><td>计算x和y的交集，并排序</td></tr><tr><td>union1d(x,y)</td><td>计算x和y的并集，并排序</td></tr><tr><td>in1d(x,y)</td><td>计算x中的元素是否包含在y中，返回一个布尔值数组</td></tr><tr><td>setdiff1d(x,y)</td><td>差集，在x中但不在y中的x的元素</td></tr><tr><td>setxor1d(x,y)</td><td>异或集，在x或y中，当不属于x、y交集的元素</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用NumPy数组可以使你利用简单的数组表达式完成多种数据操作任务，而无须写些大量循环。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>atomic</title>
    <link href="http://example.com/jsblog/3df66479.html"/>
    <id>http://example.com/jsblog/3df66479.html</id>
    <published>2020-12-24T11:53:19.000Z</published>
    <updated>2020-12-24T11:54:34.209Z</updated>
    
    <content type="html"><![CDATA[<p>在了解原子操作之前，首先看一下内存模型。<a id="more"></a></p><p>C++程序中的所有数据都是由对象构成，对象仅仅时对C++数据的一个声明。在声明C++对象的时候需要对这个对象指定分配相应的内存空间。如果使用new在堆上分配内存空间需要调用相应的delete来将这块内存空间归还。就类似于在C语言中使用malloc/free来分配和释放内存空间一样。</p><p>无论对象时怎么样的一个类型，一个对象都会存储在一个或多个内存位置上。每一个内存为位置都是一个标量类型的对象。有四个需要牢记的原则：</p><ol><li>每一个变量都是一个对象，包括作为其成员变量的对象</li><li>每个对象至少有一个内存位置</li><li>基本类型都有确定的内存位置</li><li>相邻位域时相同内存中一部分。</li></ol><p>对于多线程应用而言，所有的数据都在内存中。当两个线程访问不同的内存位置时不会造成任何的问题，但是当程序访问同一个内存，如果只是读取那么也不会出现问题，但是要是写入的话，则有可能会发生data race。为了避免条件竞争，两个线程之间就需要一定的执行顺序。可以使用互斥量确定访问顺序；还有就是使用原子操作同步机制，决定两个线程的访问顺序。当多个线程访问同一个内存地址时，对每个访问都需要定义一个顺序。</p><p>每一个在C++程序中的对象，都有确定好的修改顺序。如果对象不是一个原子类型，必须确保同步操作使得每个线程都遵守不同变量的修改顺序，这样才不会发生data race或这未定义的行为，如果使用原子操作，那么只需交给编译器去负责就好。那么什么是原子操作呢？</p><p>原子操作是一类不可分割的操作，它的状态只能为完成或者未完成，不存在完成一半。标准原子类型可以在头文件<atomic>中找到。所有的这种类型上的操作都是原子的。标准原子类型都有一个is_lock_free()函数，这个函数允许用户决定是否直接对一个给定类型使用原子指令（x.is_lock_free()返回true），或对编译器和运行库使用内部锁（x.is_lock_free()返回false）。只有std::atomic_flag没有提供is_lock_free()成员函数。std::atomic_flag只有test_and_set()函数和clear()成员函数。在明确std::atomic_flag初始化后，做查询和设置，或者清除都很容易。</atomic></p><p>剩下的原子类型都可以通过特化std::atomic&lt;&gt;类型模板来访问，并且拥有更多的功能。下表为标准院子类型与其特化类：</p><table><thead><tr><th>原子类型</th><th>相关特化类</th></tr></thead><tbody><tr><td>atomic_bool</td><td>std::atomic<bool></bool></td></tr><tr><td>atomic_char</td><td>std::atomic<char></char></td></tr><tr><td>atomic_schar</td><td>std::atomic<signed char></signed></td></tr><tr><td>atomic_uchar</td><td>std::atomic<unsigned char></unsigned></td></tr><tr><td>atomic_int</td><td>std::atomic<int></int></td></tr><tr><td>atomic_uint</td><td>std::atomic<uint></uint></td></tr><tr><td>atomic_short</td><td>std::atomic<short></short></td></tr><tr><td>atomic_ushort</td><td>std::atomic<unsigned short></unsigned></td></tr><tr><td>atomic_long</td><td>std::atomic<long></long></td></tr><tr><td>atomic_ulong</td><td>std::atomic<unsigned long></unsigned></td></tr><tr><td>atomic_llong</td><td>std::atomic<long long></long></td></tr><tr><td>atomic_ullong</td><td>std::atomic<unsigned long></unsigned></td></tr><tr><td>atomic_char16_t</td><td>std::atomic<char16_t></char16_t></td></tr><tr><td>atomic_char32_t</td><td>std::atomic<char32_t></char32_t></td></tr><tr><td>atomic_wchar_t</td><td>std::atomic<w_char_t></w_char_t></td></tr></tbody></table><p>通常，标准原子类型不能copy和赋值，他们没有copy constructor和copy assignment函数，但是为了可以隐式转化成对应的内置类型，这些类型依旧支持赋值。可以使用load()和store()成员函数，exchange(),compare_exchange_weak()和compare_exchange_strong()。都支持符合赋值符：+=，-=，*=，/=等等。并且整型和指针还支持++和–。也有对应的成员函数。</p><h3 id="特化成员函数"><a href="#特化成员函数" class="headerlink" title="特化成员函数"></a>特化成员函数</h3><table><thead><tr><th>fetch_add</th><th>原子地将参数加到存储于原子对象的值，并返回先前保有的值   (公开成员函数)</th></tr></thead><tbody><tr><td>fetch_sub</td><td>原子地从存储于原子对象的值减去参数，并获得先前保有的值   (公开成员函数)</td></tr><tr><td>fetch_and</td><td>原子地进行参数和原子对象的值的逐位与，并获得先前保有的值   (公开成员函数)</td></tr><tr><td>fetch_or</td><td>原子地进行参数和原子对象的值的逐位或，并获得先前保有的值    (公开成员函数)</td></tr><tr><td>fetch_xor</td><td>原子地进行参数和原子对象的值的逐位异或，并获得先前保有的值    (公开成员函数)</td></tr></tbody></table><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>(构造函数)</th><th>构造原子对象   (公开成员函数)</th></tr></thead><tbody><tr><td>operator=</td><td>存储值于原子对象   (公开成员函数)</td></tr><tr><td>is_lock_free</td><td>检查原子对象是否免锁   (公开成员函数)</td></tr><tr><td>store</td><td>原子地以非原子对象替换原子对象的值   (公开成员函数)</td></tr><tr><td>load</td><td>原子地获得原子对象的值   (公开成员函数)</td></tr><tr><td>operator T</td><td>从原子对象加载值   (公开成员函数)</td></tr><tr><td>exchange</td><td>原子地替换原子对象的值并获得它先前持有的值   (公开成员函数)</td></tr><tr><td>compare_exchange_weak，ompare_exchange_strong</td><td>原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载   (公开成员函数)</td></tr><tr><td>wait(C++20)</td><td>阻塞线程直至被提醒且原子值更改   (公开成员函数)</td></tr><tr><td>notify_one(C++20)</td><td>提醒至少一个在原子对象上的等待中阻塞的线程   (公开成员函数)</td></tr><tr><td>notify_all(C++20)</td><td>提醒所有在原子对象上的等待中阻塞的线程   (公开成员函数)</td></tr></tbody></table><p>对于用户自定义类型，std::atmoic&lt;&gt;会有所限制：load()和store()(赋值和转换用户自定义类型),exchange(),compare_exchange_weak()和compare_exchange_strong()。每种类型都有一个可选内存排序参数，主要操作为以下三类：</p><p>1.Store操作，可选内存顺序:memory_order_relaxed,memory_order_release,memory_order_seq_cst</p><p>2.Load操作，可选顺序模型：memory_order_relaxed,memory_order_consume,memory_order_acquire,memory_order_seq_cst</p><p>3.Read-modify-write(读改写)操作：memory_order_relaxed,memory_order_consume,memory_order_acquire,memory_order_seq_cst，memory_order_release，memory_order_acq_rel。</p><p>所有的默认顺序为memory_order_seq_cst</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解原子操作之前，首先看一下内存模型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Qt基础</title>
    <link href="http://example.com/jsblog/759084aa.html"/>
    <id>http://example.com/jsblog/759084aa.html</id>
    <published>2020-12-23T13:35:48.000Z</published>
    <updated>2020-12-24T13:13:36.004Z</updated>
    
    <content type="html"><![CDATA[<p>Qt是一个跨平台的C++图形用户界面程序框架。<a id="more"></a>它为应用程序开发者提供建立艺术级图形用户界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p><p>在Qt程序开发过程中，除可以通过手写代码实现软件开发功能外，还可以通过Qt的GUI界面设计器进行界面的绘制与布局，该工具提供了Qt的基本可绘制窗口组件。在设计器中直接拖拽窗口部件，能够高效、快速地实现GUI界面的是设计，所见即所得。</p><p>虽然Qt库起初只是一个C++图形库，但是经过多年的演化，它已经成为一个功能丰富的通用C++类库。它集成了数据库、OpenGL、多媒体、脚本、XML、正则表达式、WebKit等模块等，其内核部分也加入了进程间通信、多线程等模块。<br>作为一个成熟的GUI框架，它定义了多种功能丰富的控件，实现了事件处理机制，可以实现普通菜单、上下文相关菜单、拖曳、可停靠工具栏等功能。Qt发明了“信号与槽”机制，各控件利用这一机制发送、处理消息，大幅降低了各控件的耦合度。其他GUI框架常常使用回调函数来实现控件之间的通信，相比之下，信号与槽机制更加安全。Qt库提供的Graphics/View框架以及Model/View框架可令程序员编写少量的代码，即可显示、编辑应用程序所要处理的数据。<br>整个Qt库支持Unicode编码，因而一个Qt应用程序可以轻易地同时显示英文、中文、日文、俄文等多种Unicode编码所支持的语言。Qt软件包还提供了诸如Qt Linguist这样的工具，便于程序员开发国际化软件产品。<br>Qt库的数据库模块内含以下数据库管理系统的驱动软件：Oracle，Microsoft SQL Server，Sybase Adaptive Server，IBM DB2，PostgreSQL，MySQL，Borland Interbase，SQLite，以及其他支持ODBC（Open Database Connectivity）接口的数据库管理系统。这意味着可以使用Qt访问各种平台上的多种数据库管理系统。除了使用SQL语句直接访问数据库外，Qt还提供了一些与数据库密切相关的控件，以简化数据的访问过程。<br>Qt库的XML模块包含了能够读取、解析、处理XML文档的类。该模块支持SAX（Simple API for XML）接口以及DOM（Document Object Model）规范。该模块易用、强大、功能完备。Qt库还允许应用程序使用正则表达式搜索、解析文档，或者在一个数据集中筛选符合某种条件的数据项。<br>Qt库集成了浏览器引擎WebKit，该引擎能够从服务器下载、解析、渲染、显示网页。由于该引擎执行速度快、运行稳定，已被用于Safari、Google Chrome等浏览器中。利用这个引擎，Qt应用程序可以在其界面中显示服务器网页。不但如此，Qt令WebKit引擎将网页的结构以及其中一些对象的细节呈现给Qt应用程序，使得程序中的其他控件可以直接和这些对象进行交互。这意味着Qt应用程序在显示网页时可以将一些Qt控件嵌入到网页中，也可以使用“信号与槽”机制，使得网页中某些对象的状态发生变化时，能够触发本地程序中某些控件的槽函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Qt是一个跨平台的C++图形用户界面程序框架。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>直方图匹配</title>
    <link href="http://example.com/jsblog/3afb3874.html"/>
    <id>http://example.com/jsblog/3afb3874.html</id>
    <published>2020-12-23T12:56:25.000Z</published>
    <updated>2020-12-23T12:58:40.409Z</updated>
    
    <content type="html"><![CDATA[<p>直方图匹配又称直方图规定化。<a id="more"></a>按照给定的直方图形状调整原先图像的直方图信息。直方图匹配使用到了直方图变换以及均衡化的思想，通过建立映射关系，使期望图像的直方图达到一种特定的形态。</p><p>直方图匹配的步骤如下:</p><ol><li><p>分别计算原图像与目标图像的累计概率分布</p></li><li><p>分别对源图像和目标图像进行直方图均衡化操作</p></li><li><p>利用映射关系使源图像直方图按照规定进行变换</p></li></ol><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\lena.jpg)&quot;</span>);</span><br><span class="line">    cv::Mat dstImage = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\starry_night.jpg)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data || ! dstImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::resize(dstImage,dstImage,srcImage.size(),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;testImage&quot;</span>,dstImage);</span><br><span class="line">    <span class="comment">//统计直方图参数</span></span><br><span class="line">    <span class="keyword">float</span> srcCdf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">float</span> dstCdf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> srcAddTemp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> dstAddTemp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> histMatchMap[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srcCdf[i] = <span class="number">0</span>;</span><br><span class="line">        dstCdf[i] = <span class="number">0</span>;</span><br><span class="line">        srcAddTemp[i] = <span class="number">0</span>;</span><br><span class="line">        dstAddTemp[i] = <span class="number">0</span>;</span><br><span class="line">        histMatchMap[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> srcSumTemp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> dstSumTemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcNPixel = srcImage.rows * srcImage.cols;</span><br><span class="line">    <span class="keyword">int</span> dstNPixel = dstImage.rows * dstImage.cols;</span><br><span class="line">    <span class="keyword">int</span> matchFlag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计像素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; srcImage.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; srcImage.cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            srcAddTemp[(<span class="keyword">int</span>)srcImage.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">            dstAddTemp[(<span class="keyword">int</span>)dstImage.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算累计概率分布</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srcSumTemp += srcAddTemp[i];</span><br><span class="line">        srcCdf[i] = srcSumTemp/ srcNPixel;</span><br><span class="line">        dstSumTemp += dstAddTemp[i];</span><br><span class="line">        dstCdf[i] = dstSumTemp/ dstNPixel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直方图匹配实现</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> minMatchPara = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (minMatchPara &gt; cv::<span class="built_in">abs</span>(srcCdf[i] - dstCdf[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                minMatchPara = cv::<span class="built_in">abs</span>(srcCdf[i] - dstCdf[j]);</span><br><span class="line">                matchFlag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        histMatchMap[i] = matchFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化匹配图像</span></span><br><span class="line">    cv::Mat HistMatchImage = cv::Mat::zeros(srcImage.size(),CV_8UC3);</span><br><span class="line">    cv::cvtColor(srcImage,HistMatchImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//映射</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HistMatchImage.rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;HistMatchImage.cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            HistMatchImage.at&lt;uchar&gt;(i,j) = histMatchMap[(<span class="keyword">int</span>)HistMatchImage.at&lt;uchar&gt;(i,j) ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     cv::imshow(<span class="string">&quot;ResultImage&quot;</span>,HistMatchImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic4.zhimg.com/80/v2-3750c19228235a3c8127e32015241493_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-dcffa77bfd687064c66ed2c19aacbd56_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1daaf40e2e58d68c25cb92bb4c935d66_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直方图匹配又称直方图规定化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>直方图比较</title>
    <link href="http://example.com/jsblog/b29ec0e5.html"/>
    <id>http://example.com/jsblog/b29ec0e5.html</id>
    <published>2020-12-23T12:55:30.000Z</published>
    <updated>2020-12-23T12:58:40.411Z</updated>
    
    <content type="html"><![CDATA[<p>直方图对比用来计算图像的直方图的相似程度。<a id="more"></a>要表示直方图的相似程度，需要使用一定的衡量对比标准。OpenCV中compareHist函数计算两个直方图的相似程度。以下为几种标准：</p><ol><li>相关系数 （method=CV_COMP_CORREL）</li></ol><p><img src="https://pic2.zhimg.com/80/v2-7c973b0a5d85de77799195974422b511_720w.jpg" alt="img"></p><p>其中</p><p><img src="https://pic2.zhimg.com/80/v2-dbafa72fb03a3099f5a1a1687034c7ad_720w.png" alt="img"></p><p>N表示bins数量</p><ol start="2"><li>卡方系数（CV_COMP_CHISQR）</li></ol><p><img src="https://pic4.zhimg.com/80/v2-f001d343d00c7e7959f8a83b456a7973_720w.jpg" alt="img"></p><ol start="3"><li>相交系数 （CV_COMP_INTERSECT）</li></ol><p><img src="https://pic4.zhimg.com/80/v2-f615c6e77b3a146f87991099b6116c9b_720w.png" alt="img"></p><ol start="4"><li>巴式系数 （CV_COMP_BHATTACHARYYA,CV_COMP_HELLINGER）</li></ol><p><img src="https://pic3.zhimg.com/80/v2-851b770a936df2fc70f655997d69201e_720w.jpg" alt="img"></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算两幅图像的直方图相似度</span></span><br><span class="line">    cv::Mat srcImage1 = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\aero1.jpg)&quot;</span>);</span><br><span class="line">    cv::Mat srcImage2 = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\aero3.jpg)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage1.data || !srcImage2.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将图像转换到hsv色彩空间</span></span><br><span class="line">    cv::Mat hsv_image1,hsv_image2;</span><br><span class="line">    cv::cvtColor(srcImage1,hsv_image1,cv::COLOR_BGR2HSV);</span><br><span class="line">    cv::cvtColor(srcImage2,hsv_image2,cv::COLOR_BGR2HSV);</span><br><span class="line">    <span class="comment">//计算每幅图像的直方图</span></span><br><span class="line">    <span class="keyword">int</span> h_bins = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> s_bins = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> HistSize[] = &#123;h_bins,s_bins&#125;;</span><br><span class="line">    <span class="keyword">float</span> h_ranges[] = &#123;<span class="number">0</span>,<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> s_ranges[] = &#123;<span class="number">0</span>,<span class="number">180</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> *ranges[] = &#123;h_ranges,s_ranges&#125;;</span><br><span class="line">    <span class="keyword">int</span> channels[] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cv::MatND hist1,hist2;</span><br><span class="line">    cv::calcHist(&amp;hsv_image1,<span class="number">1</span>,channels,cv::Mat(),hist1,<span class="number">2</span>,HistSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::normalize(hist1,hist1,<span class="number">0</span>,<span class="number">1</span>,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line">    cv::calcHist(&amp;hsv_image2,<span class="number">1</span>,channels,cv::Mat(),hist2,<span class="number">2</span>,HistSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::normalize(hist2,hist2,<span class="number">0</span>,<span class="number">1</span>,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不同的直方图比较算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> method = i;</span><br><span class="line">        <span class="keyword">double</span> coefficient = cv::compareHist(hist1,hist2,method);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;method &quot;</span> &lt;&lt;i &lt;&lt; <span class="string">&quot; the coefficient is &quot;</span> &lt;&lt; coefficient &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage1&quot;</span>,srcImage1);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage2&quot;</span>,srcImage2);</span><br><span class="line">    cv::waitKey();</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic4.zhimg.com/80/v2-94da51fb0aeb49516bc6165434fd2e87_720w.jpg" alt="img"></p><p>图片显示：</p><p><img src="https://pic3.zhimg.com/80/v2-ab94d457dc8500c7ef4129b459a2b5fe_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-bebff0cde4b9f4f8f6ae23e90eb74305_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直方图对比用来计算图像的直方图的相似程度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>直方图均衡化</title>
    <link href="http://example.com/jsblog/ed8ed8eb.html"/>
    <id>http://example.com/jsblog/ed8ed8eb.html</id>
    <published>2020-12-23T12:54:52.000Z</published>
    <updated>2020-12-23T12:58:40.410Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们很难观察一幅非常亮或暗的图像的细节信息，因此对于差异较大的图像，我们可以尝试改变其图像灰度分布来使图像灰度阶分布尽量均匀，进而增强图像细节信息。<a id="more"></a>直方图均衡是拉伸各个像素分布来实现图像增强的，以累计分布函数变换基础，通过特定映射转换成一种更宽的分布，其核心就是把灰度分布映射成均匀分布</p><p>直方图均衡的目的是利用动态范围内的所有灰度阶，因此对于映射函数y=f(x),要求x在（0,1）的灰度是连续的，每一个元素都能得到相应的元素一一对应可得到下式：</p><p>p(x)dx = p(y)dy</p><p>对于均衡化的输出图像p(y) = 1，则同时积分得</p><p><img src="https://pic4.zhimg.com/80/v2-a36ecb40e3de909fde4e7712ec4ead73_720w.png" alt="img"></p><p>即映射函数为：</p><p>y = f(x) = p(x) – p(0)</p><p>直方图均衡化算法的步骤如下：</p><p>（1） 获取输入图像的直方图</p><p>（2） 求累计分布直方图，构建查找表</p><p>（3） 通过图像映射，计算新的图像像素分布</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">&quot;E:/CodeBlocks/data/lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat grayImage,histImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::equalizeHist(grayImage,histImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;grayImage&quot;</span>,grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;histImage&quot;</span>,histImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://pic4.zhimg.com/80/v2-5acdaf808bdf585165830acd1c26d817_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-679d3c40ab103551f5956c279b43029d_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常我们很难观察一幅非常亮或暗的图像的细节信息，因此对于差异较大的图像，我们可以尝试改变其图像灰度分布来使图像灰度阶分布尽量均匀，进而增强图像细节信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>C++之RAII</title>
    <link href="http://example.com/jsblog/44da37.html"/>
    <id>http://example.com/jsblog/44da37.html</id>
    <published>2020-12-23T12:52:56.000Z</published>
    <updated>2020-12-23T12:58:40.385Z</updated>
    
    <content type="html"><![CDATA[<p>以前总是听过学习C++ 不知道RAII那就是不合格的c++程序员，那什么是RAII呢？<a id="more"></a>所谓RAII机制就是（Resource Acquisition Is Initialization，资源获取即初始化），在类的构造里申请资源，然后使用资源，最后在析构函数中释放资源。在计算机中有很多种资源，内存是我们经常使用的资源，此外还有文件描述符，socket以及数据库连接等，在程序中申请这些资源后利用完必须归还，否则会造成未定义的行为。如果对象在栈上创建，那么RAII会正常工作，在离开作用域的时候释放资源。如果是使用new操作符在堆上创建对象，那么就需要程序员手动delete对象，如果程序因为某些错误而无法delete对象，则有可能对系统造成未定义的行为，内存等部分资源就会永久丢失。</p><p>未使用RAII的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.lock();                    <span class="comment">// 请求互斥体</span></span><br><span class="line">    f();                         <span class="comment">// 若 f() 抛异常，则互斥体永远不被释放</span></span><br><span class="line">    <span class="keyword">if</span>(!everything_ok()) <span class="keyword">return</span>; <span class="comment">// 提早返回，互斥体永远不被释放</span></span><br><span class="line">    m.unlock();                  <span class="comment">// 若 bad() 抵达此语句，互斥才被释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>无论那一步操作失败都需要自己释放资源，如果使用了RAII则不需要自己关闭文件，在离开函数的时候，会自动释放文件描述符。</p><p>使用RAII机制的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// RAII类：互斥体的请求即是初始化</span></span><br><span class="line">    f();                               <span class="comment">// 若 f() 抛异常，则释放互斥体</span></span><br><span class="line">    <span class="keyword">if</span>(!everything_ok()) <span class="keyword">return</span>;       <span class="comment">// 提早返回，互斥体被释放</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>RAII的总结如下（cppreference）：</p><ul><li>将每个资源封装入一个类，其中</li></ul><p>· 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</p><p>· 析构函数释放资源并决不抛出异常；</p><ul><li>始终经由 RAII 类的实例使用满足要求的资源，该资源</li></ul><p>· 自身拥有自动存储期或临时生存期，或</p><p>· 具有与自动或临时对象的生存期绑定的生存期</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前总是听过学习C++ 不知道RAII那就是不合格的c++程序员，那什么是RAII呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>宏参数#和##</title>
    <link href="http://example.com/jsblog/b039a98a.html"/>
    <id>http://example.com/jsblog/b039a98a.html</id>
    <published>2020-12-23T12:52:10.000Z</published>
    <updated>2020-12-23T12:58:40.403Z</updated>
    
    <content type="html"><![CDATA[<p>作用：</p><p>使用#把宏参数变成一个字符串，使用##则是把两个红参数连接在一起 <a id="more"></a></p><p>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Str(var) #var</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Str(var) _Str(var)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _StringCat(str1) 123##str1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StringCat(str1) _StringCat(str1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,Str(<span class="number">123456</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,StringCat(<span class="number">123</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:当宏参数是另一个宏的时候，需要注意的是宏定义例有用“#”或“##”的地方宏参数是不会再展开。即只有当前的宏生效，参数里的宏不会生效。解决的办法就是增加新的宏定义做一个转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作用：&lt;/p&gt;
&lt;p&gt;使用#把宏参数变成一个字符串，使用##则是把两个红参数连接在一起&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>printf格式化输出</title>
    <link href="http://example.com/jsblog/67b33fcc.html"/>
    <id>http://example.com/jsblog/67b33fcc.html</id>
    <published>2020-12-23T12:51:26.000Z</published>
    <updated>2020-12-23T12:58:40.407Z</updated>
    
    <content type="html"><![CDATA[<p>学着学着好像忘记了好多知识， 回想一哈，原来不是自己忘记了而是自己从来没有认真的看过，用过。<a id="more"></a>只有等到用的时候才去百度一下。有时候用到去百度又会太浪费时间，所以现在纪录一下，方便自己的使用。</p><p>printf函数原型如下：</p><p>int printf(const char* format,…);</p><p>其中format表示两部分内容：</p><ol><li><ol><li>正常字符，直接输出</li><li>格式化字符以 “%”开始，用来表示输出内容格式。</li></ol></li></ol><p>格式化字符串的模板是：%[输出标志][输出最小宽度][.小数点位数][长度]类型</p><p>其中输出标志：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>“-”</td><td>左对齐</td></tr><tr><td>“+”</td><td>右对齐</td></tr><tr><td>“ ”</td><td>空格，符号为正显示空格，为负显示负号“-”</td></tr><tr><td>“#”</td><td>对c,s,d,u无影响，对o类输出前加缀为o,对x类，在输出前缀加0x，对e,g,f当结果有小数时给出小数点</td></tr></tbody></table><p>最小宽度 m：实际长度大于m时按照实际输出，实际长度小于m时，无标志则左边填充空格。若为“%-md”则右边填充到m长度为止。</p><p>小数点：</p><p>“%m.nf”：　　输出浮点数，m为宽度，n为小数点右边数位</p><p>“%m.ns”：　　输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n</p><p>长度：h为短整型，l为长整型</p><p>类型：</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%a,%A</td><td>浮点数、十六进制数字和p-计数法</td></tr><tr><td>%c</td><td>一个字符</td></tr><tr><td>%C</td><td>一个ISO宽字符</td></tr><tr><td>%d</td><td>有符号十进制整数（int）(%ld ，%Ld为：长整型数据，%hd：短整型数)</td></tr><tr><td>%e,%E</td><td>浮点数，e-计数法，E-计数法</td></tr><tr><td>%f</td><td>单精度浮点数</td></tr><tr><td>%g，%G</td><td>根据数值不同自动选择%f或%e</td></tr><tr><td>%i</td><td>有符号十进制数（与%d相同）</td></tr><tr><td>%o</td><td>无符号八进制整数</td></tr><tr><td>%p</td><td>指针</td></tr><tr><td>%s</td><td>对应字符串char*（%s = %hs = %hS 输出 窄字符）</td></tr><tr><td>%S</td><td>对应宽字符串WCAHR*（%ws = %S 输出宽字符串</td></tr><tr><td>%u</td><td>无符号十进制整数(unsigned int)</td></tr><tr><td>%x,%X</td><td>使用十六进制数字0xf的无符号十六进制整</td></tr><tr><td>%%</td><td>打印一个%号</td></tr><tr><td>%I64d</td><td>用于int64 或者 long long</td></tr><tr><td>%I64u</td><td>用于uint64 或者unsigned long long</td></tr><tr><td>%I64x</td><td>用于64 位16进制数字</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;学着学着好像忘记了好多知识， 回想一哈，原来不是自己忘记了而是自己从来没有认真的看过，用过。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>MoreEffective基础</title>
    <link href="http://example.com/jsblog/35778d45.html"/>
    <id>http://example.com/jsblog/35778d45.html</id>
    <published>2020-12-23T12:50:24.000Z</published>
    <updated>2020-12-23T12:58:40.404Z</updated>
    
    <content type="html"><![CDATA[<p><strong>条款一</strong> <strong>：认真区分pointers和 references</strong><a id="more"></a></p><ol><li><p>没有null reference,一个reference必须总代表着一个对象。pointer是可以为null的。</p></li><li><p>reference不能为null，所以使用reference可能会比pointer更有效率。</p></li><li><p>pointer可以被重新赋值，而reference总是指向它最初获得的那个对象。</p></li><li><p>当考虑不指向任何对象，或者在不同时刻可以指向不同对象时应使用pointer,如果确定一直是该对象，并且不再更改应该使用reference</p></li><li><p>在某些操作符重载的时候，需要使用reference,例如operator[]</p></li><li><p>当你需要指向某个东西，而且绝不会改变指向其他东西，或者重载操作符而语法需求无法由pointers达成，应该使用reference.任何其他时候应该使用pointer</p></li></ol><p><strong>条款二：最好使用C++转型操作符</strong></p><ol><li><p>static_cast 基本上具有与C旧式转型相同的威力与意义，以及想听听的限制</p></li><li><p>const_cast 用来改变表达式中的常量性（constness）和变易性(volatileness)。不能将const_cast用于其他的用途。const_cast最常见的就是去掉常量性</p></li><li><p>dynamic_cast 用来执行继承体系中“安全的向下转型或者跨系转型动作”。利用dynamic_cast 实现将 指向base class 的 pointer或者reference 转型为指向 derived class object的pointer或者reference,如果转型失败返回nullptr。dynamic_cast无法应用在缺乏虚函数的类型身上，也不能改变常量性。</p></li><li><p>reinterpret_cast 与平台相关，不具有可移植性。最常用的用途是转换 函数指针类型</p></li></ol><p><strong>条款三：绝对不要以多态方式处理数组</strong></p><p>C++ 规范：通过base class 指针删除一个由derived classes objects构成的数组，其结果未定义。简单的说就是多态和指针算术不能混用。因为derived class objects 的大小比base classes 的objects的大小要大，在进行运算的时候可能会出错。</p><p><strong>条款四：非必要不提供default constructor</strong></p><p>classes 如果缺乏一个default constructor,当你使用这个classs时可能会有某些限制。同时如果class 缺乏default constructor 它们将不适用于许多template-based container classes.但是添加没有意义的default container 可能会影响classes的效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;条款一&lt;/strong&gt; &lt;strong&gt;：认真区分pointers和 references&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>C++之Queue</title>
    <link href="http://example.com/jsblog/2d2a48d2.html"/>
    <id>http://example.com/jsblog/2d2a48d2.html</id>
    <published>2020-12-23T12:49:15.000Z</published>
    <updated>2020-12-23T12:58:40.384Z</updated>
    
    <content type="html"><![CDATA[<p>C++中实现了一个queue位于头文件中<queue>中。<a id="more"></a>queue是队列，队列是一种非常重要的数据结构，它是一种先进先出（LILO）的数据结构。作为一个模板类，可以方便的操作任意类型。</queue></p><p>queue的核心接口为：</p><p>push() : 入队，将一个元素放入队尾</p><p>front() : 返回队头元素</p><p>back(): 返回队尾元素</p><p>pop() : 从队列中移除一个元素</p><p>当然也可以利用容器自己实现一个队列，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by JSL on 2020/12/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYQUEUE_MYQUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYQUEUE_MYQUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueEmpty</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Queue empty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;::<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> QueueEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> QueueEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> QueueEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">elem</span><span class="params">(_con.front())</span></span>;</span><br><span class="line">        _con.pop_front();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        _con.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; _con;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MYQUEUE_MYQUEUE_HPP</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中实现了一个queue位于头文件中&lt;queue&gt;中。&lt;/queue&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之Stack</title>
    <link href="http://example.com/jsblog/137f4cdb.html"/>
    <id>http://example.com/jsblog/137f4cdb.html</id>
    <published>2020-12-23T12:48:53.000Z</published>
    <updated>2020-12-23T12:58:40.386Z</updated>
    
    <content type="html"><![CDATA[<p>C++中实现了一个stack位于头文件中<stack>中。<a id="more"></a>stack是栈，栈是一种非常重要的数据结构，它是一种先进后出或者是后进先出(LIFO)的数据结构。作为一个模板类，可以方便的操作任意类型。</stack></p><p>stack的核心接口为：</p><p>push() : 进栈，将一个元素放入栈中</p><p>top() : 返回栈中的头部元素</p><p>pop() : 从栈中移除元素</p><p>当然也可以利用容器自己实现一个栈，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by JSL on 2020/12/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSTACK_MYSTACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSTACK_MYSTACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadEmptyStack</span> :</span><span class="keyword">public</span> <span class="built_in">std</span>::exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read empty stack&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;::<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        _con.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> ReadEmptyStack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> ReadEmptyStack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">elem</span><span class="params">(_con.back())</span></span>;</span><br><span class="line">        _con.pop_back();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; _con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MYSTACK_MYSTACK_HPP</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中实现了一个stack位于头文件中&lt;stack&gt;中。&lt;/stack&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之可变参数模板</title>
    <link href="http://example.com/jsblog/940291e0.html"/>
    <id>http://example.com/jsblog/940291e0.html</id>
    <published>2020-12-23T12:47:48.000Z</published>
    <updated>2020-12-23T12:58:40.396Z</updated>
    
    <content type="html"><![CDATA[<p>从C++11开始，C++可以使用变长模板参数，能让函数接受任意数量的参. <a id="more"></a>，有时这些参数都组合成一个表达式，从中得到函数结果。可变模板参数比较抽象，使用起来需要一定的技巧，因为其需要一定的技巧才能使用，所以会显得比较有意思。</p><p><strong>可变模板参数函数</strong></p><p><strong>可变模板参数函数的声明：</strong></p><p>可变模板参数函数的声明和模板函数的声明类似，唯一不同的是需要在表示其抽象类型时即在关键字typename或者class的后面添加上省略号“…”。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;<span class="comment">//template&lt;class ...Args&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args... args)</span></span></span><br></pre></td></tr></table></figure><p>省略号的作用：</p><p>1.声明一个参数包，包含任意个参数</p><p>2.在模板定义的右边，可以将参数展开成一个一个独立的参数</p><p>展开参数包的方法有两种：</p><p>1.通过递归的模板函数展开</p><p>2.通过逗号表达式和初始化列表方式展开</p><p><strong>1.通过递归的模板函数展开参数包</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//递归终止函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(T&amp;&amp; value,Args&amp;&amp; ...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    show_list(args...);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    show_list(<span class="number">1</span>,<span class="number">123</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在使用递归的方式展开模板参数的时候，需要指定递归终止函数。递归终止函数与可变模板参数的函数同名。且当参数包中剩余的参数个数等于递归终止函数的参数个数时，会调用递归终止函数。</p><p><strong>2.通过逗号表达式和初始化列表方式展开</strong></p><p>使用递归函数比较好理解如何展开参数包，而使用逗号表达式和初始化列表的方式可能不那么容易理解，其中最关键的就是对于逗号表达式的理解。如果理解了逗号表达式那么应该也就很好理解了。逗号表达式示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = (x=y,m); </span><br></pre></td></tr></table></figure><p>对于括号中的求值顺序是从左往右，意思就是先进行 x=y的运算，将y赋值给x,然后将括号中的m赋值给z，这样z的值就为m。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(T&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_listl</span><span class="params">(Args&amp;&amp; ...args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;(show_list(args),<span class="number">0</span>)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    show_listl(<span class="number">1</span>,<span class="number">123</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其展开式为 {(show_list(arg0),0)…},{(show_list(arg0),0),(show_list(args1),0)…},{(show_list(arg0),0),(show_list(args1),0),(show_list(args2),0)…}…,{(show_list(arg0),0),(show_list(args1),0),(show_list(args2),0),….,(show_list(argsn),0)}.最终会创建一个元素全部为0的数组。</p><p>下面是使用列表初始化和lambda函数的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(T&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_listl</span><span class="params">(F&amp;&amp; f,Args&amp;&amp; ...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;(&#123;(f(args),<span class="number">0</span>)...&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    show_listl([](<span class="keyword">auto</span> t)&#123;<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;&#125;,<span class="number">1</span>,<span class="number">123</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数模板类"><a href="#可变参数模板类" class="headerlink" title="可变参数模板类"></a><strong>可变参数模板类</strong></h2><p>当然也可以使用可变模板参数来对结构体或者类进行声明，请声明方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt; <span class="comment">// template&lt;class ...Args&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span>&#125;; <span class="comment">//struct Car&#123;&#125;;</span></span><br></pre></td></tr></table></figure><p>对于可变参数模板类来说，模板的参数个数可以为任意个。但是可变参数模板类的展开可以通过两个方式进行展开：</p><p>1.通过模板偏特化和递归的方式展开</p><p>2.通过继承的方式展开参数包</p><p><strong>1.通过模板偏特化和递归的方式展开</strong></p><p>如下代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//递归终止，其模板参数可以是多个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;T&gt;&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;value = <span class="keyword">sizeof</span>(T)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板类的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;T,Args...&gt;&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;value = Sum&lt;T&gt;::value + Sum&lt;Args...&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Sum&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">double</span> &gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意不要忘记声明递归终止的类，否则会出错哦。</p><p><strong>2.通过继承的方式展开参数包</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义整型序列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>...&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexSeq</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//继承方式展开参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N,<span class="keyword">int</span>... Indexes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexs</span> :</span> MakeIndexs &lt;N<span class="number">-1</span>,N<span class="number">-1</span>,Indexes...&gt;&#123;&#125;;</span><br><span class="line"><span class="comment">//模板特化，终止展开的条件</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Indexes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexs</span>&lt;0,Indexes...&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> IndexSeq&lt;Indexes...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MakeIndexs&lt;<span class="number">3</span>&gt;::type m3;</span><br><span class="line">    MakeIndexs&lt;<span class="number">6</span>&gt;::type m6;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(m3).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(m6).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;从C++11开始，C++可以使用变长模板参数，能让函数接受任意数量的参.&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之unordered容器</title>
    <link href="http://example.com/jsblog/8fa8fc90.html"/>
    <id>http://example.com/jsblog/8fa8fc90.html</id>
    <published>2020-12-23T12:46:57.000Z</published>
    <updated>2020-12-24T11:54:03.798Z</updated>
    
    <content type="html"><![CDATA[<p>无序容器以一种随意顺序包含插入进去的所有元素。并以一种随机的次序访问他们。<a id="more"></a>unordered_set和unordered_multiset存放的是特定类型的个别value,而unordered_map和unordered_multimap存放的元素都是key/value pair,其中key用来作为存放和查找特定元素的依据。unordered_set, unordered_multiset, unordered_map unordered_multimap的实现都是以hash table为底层数据结构。和map,set一样，unordered_set和unordered_map不允许有重复的元素，而unordered_multiset和unordered_multimap允许元素重复。unordered_set, unordered_multiset,位于头文件<unordered_set>,unordered_map unordered_multimap位于头文件<unordered_map>.</unordered_map></unordered_set></p><p>unordered_set和unordered_multiset的元素类型，必须是可比较的。</p><p>unordered_map和unordered_multimap是key/value类型的，对于其中的key、value的要求如下：</p><ol><li><p>key和value都必须可以复制和可以移动（movable）</p></li><li><p>key必须是可以等价准则比较的。</p></li></ol><p>对于模板中的参数Hash用来定义hash函数，如果是自己定义的类型，就必须指定hash函数。</p><p>对于无序容器的构造函数与set和map的构造函数类似，不过可以对于自己定义的类型，需要自己定义特殊的hash 函数。这个hash函数的要求是一个必须是个函数或者是一个function object它接受一个value作为参数，并返回一个std::size_t的value.</p><p>无序容器的接口与set和map的接口差不多，但是相比于set和map而言，无序容器不支持双向迭代器，它的迭代器是一个单向的迭代器。</p><p>构造函数，拷贝构造，拷贝赋值，析构函数</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>Unordered c;</td><td>默认构造函数，创建一个空的无序容器</td></tr><tr><td>Unordered c(bnum)</td><td>建立一个空的Unordered对象，内部至少使用bnum个bucket</td></tr><tr><td>Unordered c(bnum,hf)</td><td>建立一个空的Unordered对象，内部至少使用bnum个bucket,并以hf作为hash 函数</td></tr><tr><td>Unordered c(bnum,hf,cmp)</td><td>建立一个空的Unordered对象，内部至少使用bnum个bucket,并以hf作为hash 函数，并以cmp作为predicate用来鉴定value</td></tr><tr><td>Unordered c(c2)</td><td>copy constructor</td></tr><tr><td>Unordered c = c2;</td><td>copy constructor</td></tr><tr><td>Unordered c(rv)</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>Unordered c = rv</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>Unordered c(beg,end)</td><td>以区间[beg,end)内的元素为c的初值</td></tr><tr><td>Unordered c(beg,end,bnum)</td><td>以区间[beg,end)内的元素为c的初值，内部至少使用bnum个bucket</td></tr><tr><td>Unordered c(beg,end,bnum,hf)</td><td>以区间[beg,end)内的元素为c的初值，内部至少使用bnum个bucket，并以hf作为hash 函数</td></tr><tr><td>Unordered c(beg,end,bnum,hf,cmp)</td><td>以区间[beg,end)内的元素为c的初值，内部至少使用bnum个bucket，并以hf作为hash 函数并以cmp作为predicate用来鉴定value</td></tr><tr><td>Unordered c(initlist)</td><td>列表初始化</td></tr><tr><td>Unordered c = initlist</td><td>列表初始化</td></tr><tr><td>c.~ Unordered ()</td><td>析构函数</td></tr></tbody></table><p>其中 Unordered的形式为以下几种：</p><p>unordered_set<Elem> / unorderd_set&lt;Elem,Hash&gt; / unordered_set&lt;Elem,Hash,Cmp&gt;</Elem></p><p>unordered_multiset<Elem> / unorderd_multiset&lt;Elem,Hash&gt; / unordered_multiset&lt;Elem,Hash,Cmp&gt;</Elem></p><p>unordered_map<Elem> / unorderd_map&lt;Elem,Hash&gt; / unordered_map&lt;Elem,Hash,Cmp&gt;</Elem></p><p>unordered_multimap<Elem> / unorderd_multimap&lt;Elem,Hash&gt; / unordered_multimap&lt;Elem,Hash,Cmp&gt;</Elem></p><p><strong>无序容器的布局函数</strong>：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.hash_function()</td><td>返回hash函数</td></tr><tr><td>c.key_eq()</td><td>返回相等性判断式</td></tr><tr><td>c.bucket_count()</td><td>返回当前的bucket个数</td></tr><tr><td>c.max_bucket_count()</td><td>返回bucket的最大可能数量</td></tr><tr><td>c.load_factor()</td><td>返回当前的负载因子</td></tr><tr><td>c.max_load_factor()</td><td>返回当前的最大负载系数</td></tr><tr><td>c,max_load_factor(val)</td><td>设定当前的最大负载系数为val</td></tr><tr><td>c.rehash(bnum)</td><td>将容器重新计算hash，使其bucket至少为bnum</td></tr><tr><td>c．reverse(num)</td><td>将容器重新计算hash，使其至少可以容纳num个元素</td></tr></tbody></table><p><strong>非更改操作：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.empty()</td><td>容器是否为空</td></tr><tr><td>c.size()</td><td>目前的元素个数</td></tr><tr><td>c.max_size()</td><td>元素个数的最大可能量</td></tr><tr><td>c1 == c2</td><td>c1是否等于c2(每个元素调用 == )</td></tr><tr><td>c1 != c2</td><td>c1 是否 不等于 c2</td></tr></tbody></table><p>查找函数：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.count(val)</td><td>返回容器中key为val的个数</td></tr><tr><td>c.find(val)</td><td>返回容器中第一个元素为key为val的元素，找不到返回val</td></tr><tr><td>c.equal_range(val)</td><td>返回key为val可被插入的第一个位置和最后一个位置即key==val的元素区间</td></tr></tbody></table><p>赋值操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c = c1</td><td>copy assignment，将c2元素赋值给c</td></tr><tr><td>c = rv</td><td>move assignment,</td></tr><tr><td>c = initilist</td><td>将初值列的元素赋值给c</td></tr><tr><td>c1.swap(c2)</td><td>交换c1和c2的元素</td></tr><tr><td>swap(c1,c2)</td><td>交换c1和c2的元素</td></tr></tbody></table><p>迭代器：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.begin()</td><td>返回一个 forward iterator指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 forward iterator指向末尾元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const forward iterator指向第一元素</td></tr><tr><td>c.cend()</td><td>返回一个 const forward iterator指向末尾元素的下一位置</td></tr><tr><td>c.rbegin()</td><td>返回一个 reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个 reverse iterator指向反向迭代的末尾元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.crend()</td><td>返回一个const reverse iterator指向反向迭代的末尾元素的下一位置</td></tr></tbody></table><p>元素操作：(下面的元素指的是 key/value pair)</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.insert(val)</td><td>插入val,并返回新元素的位置</td></tr><tr><td>c.insert(pos,val)</td><td>以pos为起点在[pos,end)中插入val，返回新元素的位置</td></tr><tr><td>c.insert(beg,end)</td><td>将区间[beg,end)内的元素插入到c中</td></tr><tr><td>c.insert(initlist)</td><td>将初值列的元素插入到c中</td></tr><tr><td>c.emplace(args…)</td><td>插入一个args元素的值，并返回新元素的位置</td></tr><tr><td>c.emplace_hint(pos,args…)</td><td>以pos为起点在[pos,end)中插入args，返回新元素的位置</td></tr><tr><td>c.erase(val)</td><td>移除与 val相等的所有元素，返回被移除的个数</td></tr><tr><td>c.erase(pos)</td><td>移除iterator位置pos上的元素，无返回值</td></tr><tr><td>c.erase(beg,end)</td><td>移除区间[beg,end)内的元素，无返回值</td></tr><tr><td>c.clear()</td><td>将容器清空</td></tr></tbody></table><p>关联式操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c[key]</td><td>如果key存在，则返回key元素的值，如果不存则插入一个key/value元素</td></tr><tr><td>c.at(key)</td><td>返回对应key/value中对应key的value</td></tr></tbody></table><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_set</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_set----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; coll = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    coll.insert(&#123;<span class="number">-7</span>,<span class="number">17</span>,<span class="number">33</span>,<span class="number">-11</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">13</span>&#125;);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (coll.find(<span class="number">19</span>) != coll.end())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;19 is available&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_multiset----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt; coll = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    coll.insert(&#123;<span class="number">-7</span>,<span class="number">17</span>,<span class="number">33</span>,<span class="number">-11</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">13</span>&#125;);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (coll.find(<span class="number">19</span>) != coll.end())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;19 is available&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_map----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; coll;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">10</span> ; ++i) &#123;</span><br><span class="line">        coll[i] = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">101</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">102</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">103</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;first &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multimap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_multimap----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; coll;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">10</span> ; ++i) &#123;</span><br><span class="line">        coll.insert(&#123;i,<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i) / <span class="number">10</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.02</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.03</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">103</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;first &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_multiset();</span><br><span class="line">    test_set();</span><br><span class="line">    test_map();</span><br><span class="line">    test_multimap();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;无序容器以一种随意顺序包含插入进去的所有元素。并以一种随机的次序访问他们。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之map</title>
    <link href="http://example.com/jsblog/ae064968.html"/>
    <id>http://example.com/jsblog/ae064968.html</id>
    <published>2020-12-23T12:45:38.000Z</published>
    <updated>2020-12-23T12:58:40.390Z</updated>
    
    <content type="html"><![CDATA[<p>map和multimap将key/value pair当作元素进行管理。<a id="more"></a>它们可根据key的排序准则自动为元素进行排序。multimap允许元素重复，但map不允许。map和multimap位于头文件<map>中。map和multimap的元素类型Key 和value T必须满足以下条件：</map></p><ol><li><p>Key 和 value必须都是copyable（可复制的）和movable(可移动的)</p></li><li><p>对指定的排序规则，key必须是可比较的</p></li></ol><p>如果没有指定排序规则，那就使用默认的less&lt;&gt;排序规则，以operator&lt;进行比较。map和multimap通常也是以平衡二叉树来完成。map和multimap会对key/value根据key的排序规则自动排序，也可以很方便的通过key找到value,但是通过value找到key效率并不是很好。和set一样，不能直接修改元素的key，要想修改元素的key,需要先移除拥有该key的元素，然后插入新的key/value的元素，对于value可以直接更改。</p><p>操作函数：</p><p>构造函数，拷贝构造，拷贝赋值，析构函数</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>map m;</td><td>默认构造函数，创建一个空的map/multimap</td></tr><tr><td>map m(op)</td><td>建立一个空的map/multimap对象，以op为排序准则</td></tr><tr><td>map m(m2)</td><td>copy constructor</td></tr><tr><td>map m = m2;</td><td>copy constructor</td></tr><tr><td>map m(rv)</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>map m = rv</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>map m(beg,end)</td><td>以区间[beg,end)内的元素为m的初值</td></tr><tr><td>map m(beg,end,op)</td><td>以区间[beg,end)内的元素为m的初值，以op为排序准则</td></tr><tr><td>map m(initlist)</td><td>列表初始化</td></tr><tr><td>map m = initlist</td><td>列表初始化</td></tr><tr><td>m.~map()</td><td>析构函数</td></tr></tbody></table><p>其中 map 的形式为以下几种：</p><table><thead><tr><th>map</th><th>含义</th></tr></thead><tbody><tr><td>map&lt;key,Value&gt;</td><td>一个map使用默认的排序准则</td></tr><tr><td>map&lt;key,Value,Op&gt;</td><td>一个map使用op排序准则</td></tr><tr><td>multimap&lt;key,Value&gt;</td><td>一个multimap使用默认的排序准则</td></tr><tr><td>multimap&lt;key,Value,Op&gt;</td><td>一个multimap使用op排序准则</td></tr></tbody></table><p><strong>非更改操作：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.key_comp()</td><td>返回 op</td></tr><tr><td>c.value_comp()</td><td>返回 针对value的排序准则</td></tr><tr><td>c.empty()</td><td>容器是否为空</td></tr><tr><td>c.size()</td><td>目前的元素个数</td></tr><tr><td>c.max_size()</td><td>元素个数的最大可能量</td></tr><tr><td>c1 == c2</td><td>c1是否等于c2(每个元素调用 == )</td></tr><tr><td>c1 != c2</td><td>c1 是否 不等于 c2</td></tr><tr><td>c1 &lt; c2</td><td>c1 是否小于 c2</td></tr><tr><td>c1 &gt; c2</td><td>c1 是否大于 c2</td></tr><tr><td>c1 &lt;= c2</td><td>c1 是否小于等于c2</td></tr><tr><td>c1 &gt;= c2</td><td>c1 是否大于等于 c2</td></tr></tbody></table><p>查找函数：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.count(val)</td><td>返回容器中key为val的个数</td></tr><tr><td>c.find(val)</td><td>返回容器中第一个元素为key为val的元素，没有返回end()</td></tr><tr><td>c.lower_bound(val)</td><td>返回key为val第一个可以插入的位置，也就是key&gt;=val的第一个位置</td></tr><tr><td>c.upper_bound(val)</td><td>返回key为val最后一个可以插入的位置，也就是key&gt;val的第一个位置</td></tr><tr><td>c.equal_range(val)</td><td>返回key为val可被插入的第一个位置和最后一个位置即key==val的元素区间</td></tr></tbody></table><p>赋值操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c = c1</td><td>copy assignment，将c2元素赋值给c</td></tr><tr><td>c = rv</td><td>move assignment,</td></tr><tr><td>c = initilist</td><td>将初值列的元素赋值给c</td></tr><tr><td>c1.swap(c2)</td><td>交换c1和c2的元素</td></tr><tr><td>swap(c1,c2)</td><td>交换c1和c2的元素</td></tr></tbody></table><p>迭代器：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.begin()</td><td>返回一个 bidirectional iterator指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const bidirectional iterator指向第一元素</td></tr><tr><td>c.cend()</td><td>返回一个 const bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.rbegin()</td><td>返回一个 reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个 reverse iterator指向反向迭代的末尾元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.crend()</td><td>返回一个const reverse iterator指向反向迭代的末尾元素的下一位置</td></tr></tbody></table><p>元素操作：(下面的元素指的是 key/value pair)</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.insert(val)</td><td>插入val,并返回新元素的位置</td></tr><tr><td>c.insert(pos,val)</td><td>以pos为起点在[pos,end)中插入val，返回新元素的位置</td></tr><tr><td>c.insert(beg,end)</td><td>将区间[beg,end)内的元素插入到c中</td></tr><tr><td>c.insert(initlist)</td><td>将初值列的元素插入到c中</td></tr><tr><td>c.emplace(args…)</td><td>插入一个args元素的值，并返回新元素的位置</td></tr><tr><td>c.emplace_hint(pos,args…)</td><td>以pos为起点在[pos,end)中插入args，返回新元素的位置</td></tr><tr><td>c.erase(val)</td><td>移除与 val相等的所有元素，返回被移除的个数</td></tr><tr><td>c.erase(pos)</td><td>移除iterator位置pos上的元素，无返回值</td></tr><tr><td>c.erase(beg,end)</td><td>移除区间[beg,end)内的元素，无返回值</td></tr><tr><td>c.clear()</td><td>将容器清空</td></tr></tbody></table><p>关联式操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>m[key]</td><td>如果key存在，则返回key元素的值，如果不存则插入一个key/value元素</td></tr><tr><td>m.at(key)</td><td>返回对应key/value中对应key的value</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; SSMap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillAndPrint</span><span class="params">(SSMap&amp; ssMap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SSMap  coll;</span><br><span class="line">    fillAndPrint(coll);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size : &quot;</span> &lt;&lt; coll.size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max size : &quot;</span> &lt;&lt; coll.max_size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillAndPrint</span><span class="params">(SSMap&amp; ssMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ssMap[<span class="string">&quot;Deutschland&quot;</span>] = <span class="string">&quot;germangy&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;deutsch&quot;</span>] = <span class="string">&quot;genman&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;Haken&quot;</span>] = <span class="string">&quot;snag&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;arbeiten&quot;</span>] = <span class="string">&quot;work&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;Hund&quot;</span>] = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;gen&quot;</span>] = <span class="string">&quot;walk&quot;</span>;</span><br><span class="line">    ssMap.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;gooo&quot;</span>));</span><br><span class="line">    ssMap.insert(&#123;<span class="string">&quot;test&quot;</span>,<span class="string">&quot;initlist&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">auto</span> pos = find_if(ssMap.begin(),ssMap.end(),[](<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&amp; elem )&#123;</span><br><span class="line">        <span class="keyword">return</span> elem.first == <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (pos != ssMap.end())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; key : &quot;</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">&quot; value : &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ssMap.count(<span class="string">&quot;gen&quot;</span>))&#123;</span><br><span class="line">        ssMap[<span class="string">&quot;gen&quot;</span>] = <span class="string">&quot;Walk&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        ssMap[<span class="string">&quot;gen&quot;</span>] = <span class="string">&quot;goes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos = ssMap.find(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != ssMap.end())&#123;</span><br><span class="line">        ssMap.erase(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::left,ios::adjustfield);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : ssMap)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">15</span>) &lt;&lt; elem.first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; elem.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size : &quot;</span> &lt;&lt; ssMap.size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max size : &quot;</span> &lt;&lt; ssMap.max_size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    ssMap.clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;map和multimap将key/value pair当作元素进行管理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之set</title>
    <link href="http://example.com/jsblog/dbbfc60f.html"/>
    <id>http://example.com/jsblog/dbbfc60f.html</id>
    <published>2020-12-23T12:45:08.000Z</published>
    <updated>2020-12-23T12:58:40.392Z</updated>
    
    <content type="html"><![CDATA[<p>Set和MultiSet会按照特定的排序规则，自动将元素排序。两者的不同是在于mutilset允许有重复元素在容器内，而set则不允许有重复元素。set和multiset位于头文件<set>中。<a id="more"></a></set></p><p>对于set和multiset而言,只要是comparable（可依据某排序准则比较）的任意类型T都可以成为set或multiset的元素类型，如果没有自定义排序准则，那么set和multiset就会使用默认的仿函数less用来作为排序的准则,以operator&lt;对元素进行比较。所谓的排序准则需要遵循以下原则：</p><ol><li><p>必须是非对称的：若x op y为true，则 y op x 为 false</p></li><li><p>必须是可传递的：如 x op y为 true且 y op z 为true,则 x op z 为 true</p></li><li><p>必须是非自反的: x op x为 false</p></li><li><p>必须有等效传递性： 如果 a = b且 b=c 那么 a = c</p></li></ol><p>multiset的等效元素是随机且稳定的。set和multiset通常以平衡二叉树实现。自动排序的主要优点在于令二叉树于查找元素时拥有良好的效能。其查找函数具有对数复杂度。但是不能直接改变元素值，要想改变元素值，需要删除旧的元素再插入新元素。set和multiset不提供任何操作函数可以直接访问元素，通过迭代器进行元素间接访问，元素值是常量。</p><p>操作函数：</p><p>构造函数，拷贝构造，拷贝赋值，析构函数</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>set/multiset c</td><td>创建一个空的set/multiset对象c</td></tr><tr><td>set/multiset c(op)</td><td>建立一个空的set/multiset对象，以op为排序准则</td></tr><tr><td>set/multiset c(c1)</td><td>copy constructor</td></tr><tr><td>set/multiset c = c1</td><td>copy constructor</td></tr><tr><td>set/multiset c(rv)</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>set/multiset c = rv</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>set/multiset c(beg,end)</td><td>以区间[beg,end)内的元素为c的初值</td></tr><tr><td>set/multiset c(beg,end,op)</td><td>以区间[beg,end)内的元素为c的初值，以op为排序准则</td></tr><tr><td>set/multiset c(initlist)</td><td>列表初始化</td></tr><tr><td>set/multiset c=initlist</td><td>列表初始化</td></tr><tr><td>c.<del>set/c.</del>multiset()</td><td>析构函数</td></tr></tbody></table><p>其中 set代表 set<T>,multiset 代表 multiset<T></T></T></p><p><strong>非更改操作：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.key_comp()</td><td>返回 op</td></tr><tr><td>c.value_comp()</td><td>返回 op</td></tr><tr><td>c.empty()</td><td>容器是否为空</td></tr><tr><td>c.size()</td><td>目前的元素个数</td></tr><tr><td>c.max_size()</td><td>元素个数的最大可能量</td></tr><tr><td>c1 == c2</td><td>c1是否等于c2(每个元素调用 == )</td></tr><tr><td>c1 != c2</td><td>c1 是否 不等于 c2</td></tr><tr><td>c1 &lt; c2</td><td>c1 是否小于 c2</td></tr><tr><td>c1 &gt; c2</td><td>c1 是否大于 c2</td></tr><tr><td>c1 &lt;= c2</td><td>c1 是否小于等于c2</td></tr><tr><td>c1 &gt;= c2</td><td>c1 是否大于等于 c2</td></tr></tbody></table><p>查找函数：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.ount(val)</td><td>返回容器中val的个数</td></tr><tr><td>c.find(val)</td><td>返回容器中第一个元素为val的元素，没有返回end()</td></tr><tr><td>c.lower_bound(val)</td><td>返回val第一个可以插入的位置，也就是元素值&gt;=val的第一个位置</td></tr><tr><td>c.upper_bound(val)</td><td>返回val最后一个可以插入的位置，也就是元素值&gt;val的第一个位置</td></tr><tr><td>c.equal_range(val)</td><td>返回val可被插入的第一个位置和最后一个位置即元素值==val的元素区间</td></tr></tbody></table><p>赋值操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c = c1</td><td>copy assignment，将c2元素赋值给c</td></tr><tr><td>c = rv</td><td>move assignment,</td></tr><tr><td>c = initilist</td><td>将初值列的元素赋值给c</td></tr><tr><td>c1.swap(c2)</td><td>交换c1和c2的元素</td></tr><tr><td>swap(c1,c2)</td><td>交换c1和c2的元素</td></tr></tbody></table><p>迭代器：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.begin()</td><td>返回一个 bidirectional iterator指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const bidirectional iterator指向第一元素</td></tr><tr><td>c.cend()</td><td>返回一个 const bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.rbegin()</td><td>返回一个 reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个 reverse iterator指向反向迭代的末尾元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.crend()</td><td>返回一个const reverse iterator指向反向迭代的末尾元素的下一位置</td></tr></tbody></table><p>元素操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.insert(val)</td><td>插入val,并返回新元素的位置</td></tr><tr><td>c.insert(pos,val)</td><td>以pos为起点在[pos,end)中插入val，返回新元素的位置</td></tr><tr><td>c.insert(beg,end)</td><td>将区间[beg,end)内的元素插入到c中</td></tr><tr><td>c.insert(initlist)</td><td>将初值列的元素插入到c中</td></tr><tr><td>c.emplace(args…)</td><td>插入一个args元素的值，并返回新元素的位置</td></tr><tr><td>c.emplace_hint(pos,args…)</td><td>以pos为起点在[pos,end)中插入args，返回新元素的位置</td></tr><tr><td>c.erase(val)</td><td>移除与 val相等的所有元素，返回被移除的个数</td></tr><tr><td>c.erase(pos)</td><td>移除iterator位置pos上的元素，无返回值</td></tr><tr><td>c.erase(beg,end)</td><td>移除区间[beg,end)内的元素，无返回值</td></tr><tr><td>c.clear()</td><td>将容器清空</td></tr></tbody></table><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; coll1;</span><br><span class="line">    coll1.insert(&#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">15</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    coll1.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; elem : coll1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    copy(coll1.rbegin(),coll1.rend(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pos = coll1.insert(<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos.second)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;21 insert as element &quot;</span> &lt;&lt; distance(coll1.begin(),pos.first) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;21 is exists&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">coll2</span><span class="params">(coll1.begin(),coll1.end())</span></span>;</span><br><span class="line">    copy(coll2.begin(),coll2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    coll2.erase(coll2.begin(),coll2.find(<span class="number">21</span>));</span><br><span class="line">    <span class="keyword">int</span> num = coll2.erase(<span class="number">45</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; elements is removed &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(coll2.begin(),coll2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Set和MultiSet会按照特定的排序规则，自动将元素排序。两者的不同是在于mutilset允许有重复元素在容器内，而set则不允许有重复元素。set和multiset位于头文件&lt;set&gt;中。&lt;/set&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之forward_list</title>
    <link href="http://example.com/jsblog/ef69092c.html"/>
    <id>http://example.com/jsblog/ef69092c.html</id>
    <published>2020-12-23T12:44:30.000Z</published>
    <updated>2020-12-23T12:58:40.389Z</updated>
    
    <content type="html"><![CDATA[<p>Forward list 是class forward_list&lt;&gt;的一个实例，其内部以一个single linked list管理元素。<a id="more"></a>forward_list位于<forward_list>头文件中。相对于list而言，forward_list只提供了前向迭代器，因此它不支持反向迭代器。它也不提供size函数，如果提供size函数会浪费大量开销，forward_list也没有指向最末元素的指针。forward_list可以看成是一个单向链表。</forward_list></p><p>forward_list的成员函数如下：</p><table><thead><tr><th>empty()</th><th>判断容器是否为空</th></tr></thead><tbody><tr><td>max_size()</td><td>返回容器的最大可能数量</td></tr><tr><td>operator==()</td><td>判断两个forward_list是否相等</td></tr><tr><td>operator!=()</td><td>判断两个forward_list是否不等</td></tr><tr><td>operator&lt;()</td><td>判断一个forward_list是否小于另外一个forward_list</td></tr><tr><td>operator&gt;()</td><td>判断一个forward_list是否大于另外一个forward_list</td></tr><tr><td>operator&lt;=()</td><td>判断一个forward_list是否小于等于另外一个forward_list</td></tr><tr><td>operator&gt;=()</td><td>判断一个forward_list是否大于等于另外一个forward_list</td></tr><tr><td>operator=()</td><td>将一个forward_list拷贝到另外一个forward_list</td></tr><tr><td>assign()</td><td>为forward_list赋值</td></tr><tr><td>swap()</td><td>交换两个链表</td></tr><tr><td>front()</td><td>返回头部元素</td></tr><tr><td>begin()</td><td>返回指向第一个元素的迭代器</td></tr><tr><td>end()</td><td>返回指向末尾的迭代器</td></tr><tr><td>cbegin()</td><td>返回指向第一个元素的const迭代器</td></tr><tr><td>cend()</td><td>返回指向末尾的const迭代器</td></tr><tr><td>before_begin()</td><td>返回指向第一元素的迭代器</td></tr><tr><td>cbefore_begin()</td><td>返回指向第一元素的前一位置的const 迭代器</td></tr><tr><td>push_front()</td><td>在头部插入一个元素</td></tr><tr><td>pop_front()</td><td>移除第一个元素</td></tr><tr><td>insert_after(pos,elem)</td><td>在pos后插入elem</td></tr><tr><td>emplace_after(pos,elem)</td><td>在pos位置后插入elem,不添加元素</td></tr><tr><td>emplace_front(elem)</td><td>在起点插入elem</td></tr><tr><td>earse_after(pos)</td><td>移除pos后的所有元素</td></tr><tr><td>resize(size)</td><td>将元素数量该为size</td></tr><tr><td>clear()</td><td>清除所有元素内容</td></tr><tr><td>unique()</td><td>移除重复而相邻的元素只留一个</td></tr><tr><td>splice_after(pos,c2)</td><td>将c2所有元素转移到pos之后</td></tr><tr><td>sort()</td><td>排序</td></tr><tr><td>merge(c2)</td><td>将两个链表合并为一个链表</td></tr><tr><td>reverse()</td><td>逆序</td></tr></tbody></table><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        fl.push_front(i*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> fl2 = fl;</span><br><span class="line">    fl2.reverse();</span><br><span class="line">    copy(fl2.begin(),fl2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (fl == fl2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (fl &gt; fl2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (fl &lt; fl2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    fl.insert_after(fl.begin(),<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> fl3 = fl2;</span><br><span class="line">    fl.merge(fl2);</span><br><span class="line">    fl.sort();</span><br><span class="line">    fl.unique();</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    fl2.splice_after(fl2.before_begin(),fl3);</span><br><span class="line">    copy(fl2.begin(),fl2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    fl.pop_front();</span><br><span class="line">    fl.pop_front();</span><br><span class="line">    fl.remove(<span class="number">2</span>);</span><br><span class="line">    fl.resize(<span class="number">20</span>,<span class="number">9</span>);</span><br><span class="line">    fl.remove_if([](<span class="keyword">auto</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>;&#125;);</span><br><span class="line">    fl.emplace_after(++fl.begin(),<span class="number">5</span>);</span><br><span class="line">    fl.erase_after(++fl.begin());</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;max size : &quot;</span> &lt;&lt; fl.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Forward list 是class forward_list&amp;lt;&amp;gt;的一个实例，其内部以一个single linked list管理元素。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
</feed>
