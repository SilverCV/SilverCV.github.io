<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林森</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-23T12:58:40.409Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>直方图匹配</title>
    <link href="http://example.com/jsblog/3afb3874.html"/>
    <id>http://example.com/jsblog/3afb3874.html</id>
    <published>2020-12-23T12:56:25.000Z</published>
    <updated>2020-12-23T12:58:40.409Z</updated>
    
    <content type="html"><![CDATA[<p>直方图匹配又称直方图规定化。<a id="more"></a>按照给定的直方图形状调整原先图像的直方图信息。直方图匹配使用到了直方图变换以及均衡化的思想，通过建立映射关系，使期望图像的直方图达到一种特定的形态。</p><p>直方图匹配的步骤如下:</p><ol><li><p>分别计算原图像与目标图像的累计概率分布</p></li><li><p>分别对源图像和目标图像进行直方图均衡化操作</p></li><li><p>利用映射关系使源图像直方图按照规定进行变换</p></li></ol><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\lena.jpg)&quot;</span>);</span><br><span class="line">    cv::Mat dstImage = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\starry_night.jpg)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data || ! dstImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::resize(dstImage,dstImage,srcImage.size(),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage&quot;</span>,srcImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;testImage&quot;</span>,dstImage);</span><br><span class="line">    <span class="comment">//统计直方图参数</span></span><br><span class="line">    <span class="keyword">float</span> srcCdf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">float</span> dstCdf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> srcAddTemp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> dstAddTemp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> histMatchMap[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srcCdf[i] = <span class="number">0</span>;</span><br><span class="line">        dstCdf[i] = <span class="number">0</span>;</span><br><span class="line">        srcAddTemp[i] = <span class="number">0</span>;</span><br><span class="line">        dstAddTemp[i] = <span class="number">0</span>;</span><br><span class="line">        histMatchMap[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> srcSumTemp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> dstSumTemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcNPixel = srcImage.rows * srcImage.cols;</span><br><span class="line">    <span class="keyword">int</span> dstNPixel = dstImage.rows * dstImage.cols;</span><br><span class="line">    <span class="keyword">int</span> matchFlag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计像素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; srcImage.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; srcImage.cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            srcAddTemp[(<span class="keyword">int</span>)srcImage.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">            dstAddTemp[(<span class="keyword">int</span>)dstImage.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算累计概率分布</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srcSumTemp += srcAddTemp[i];</span><br><span class="line">        srcCdf[i] = srcSumTemp/ srcNPixel;</span><br><span class="line">        dstSumTemp += dstAddTemp[i];</span><br><span class="line">        dstCdf[i] = dstSumTemp/ dstNPixel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直方图匹配实现</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> minMatchPara = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (minMatchPara &gt; cv::<span class="built_in">abs</span>(srcCdf[i] - dstCdf[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                minMatchPara = cv::<span class="built_in">abs</span>(srcCdf[i] - dstCdf[j]);</span><br><span class="line">                matchFlag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        histMatchMap[i] = matchFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化匹配图像</span></span><br><span class="line">    cv::Mat HistMatchImage = cv::Mat::zeros(srcImage.size(),CV_8UC3);</span><br><span class="line">    cv::cvtColor(srcImage,HistMatchImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//映射</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HistMatchImage.rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;HistMatchImage.cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            HistMatchImage.at&lt;uchar&gt;(i,j) = histMatchMap[(<span class="keyword">int</span>)HistMatchImage.at&lt;uchar&gt;(i,j) ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     cv::imshow(<span class="string">&quot;ResultImage&quot;</span>,HistMatchImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic4.zhimg.com/80/v2-3750c19228235a3c8127e32015241493_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-dcffa77bfd687064c66ed2c19aacbd56_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1daaf40e2e58d68c25cb92bb4c935d66_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直方图匹配又称直方图规定化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>直方图比较</title>
    <link href="http://example.com/jsblog/b29ec0e5.html"/>
    <id>http://example.com/jsblog/b29ec0e5.html</id>
    <published>2020-12-23T12:55:30.000Z</published>
    <updated>2020-12-23T12:58:40.411Z</updated>
    
    <content type="html"><![CDATA[<p>直方图对比用来计算图像的直方图的相似程度。<a id="more"></a>要表示直方图的相似程度，需要使用一定的衡量对比标准。OpenCV中compareHist函数计算两个直方图的相似程度。以下为几种标准：</p><ol><li>相关系数 （method=CV_COMP_CORREL）</li></ol><p><img src="https://pic2.zhimg.com/80/v2-7c973b0a5d85de77799195974422b511_720w.jpg" alt="img"></p><p>其中</p><p><img src="https://pic2.zhimg.com/80/v2-dbafa72fb03a3099f5a1a1687034c7ad_720w.png" alt="img"></p><p>N表示bins数量</p><ol start="2"><li>卡方系数（CV_COMP_CHISQR）</li></ol><p><img src="https://pic4.zhimg.com/80/v2-f001d343d00c7e7959f8a83b456a7973_720w.jpg" alt="img"></p><ol start="3"><li>相交系数 （CV_COMP_INTERSECT）</li></ol><p><img src="https://pic4.zhimg.com/80/v2-f615c6e77b3a146f87991099b6116c9b_720w.png" alt="img"></p><ol start="4"><li>巴式系数 （CV_COMP_BHATTACHARYYA,CV_COMP_HELLINGER）</li></ol><p><img src="https://pic3.zhimg.com/80/v2-851b770a936df2fc70f655997d69201e_720w.jpg" alt="img"></p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算两幅图像的直方图相似度</span></span><br><span class="line">    cv::Mat srcImage1 = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\aero1.jpg)&quot;</span>);</span><br><span class="line">    cv::Mat srcImage2 = cv::imread(<span class="string">R&quot;(E:\CodeBlocks\data\aero3.jpg)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage1.data || !srcImage2.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将图像转换到hsv色彩空间</span></span><br><span class="line">    cv::Mat hsv_image1,hsv_image2;</span><br><span class="line">    cv::cvtColor(srcImage1,hsv_image1,cv::COLOR_BGR2HSV);</span><br><span class="line">    cv::cvtColor(srcImage2,hsv_image2,cv::COLOR_BGR2HSV);</span><br><span class="line">    <span class="comment">//计算每幅图像的直方图</span></span><br><span class="line">    <span class="keyword">int</span> h_bins = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> s_bins = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> HistSize[] = &#123;h_bins,s_bins&#125;;</span><br><span class="line">    <span class="keyword">float</span> h_ranges[] = &#123;<span class="number">0</span>,<span class="number">256</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> s_ranges[] = &#123;<span class="number">0</span>,<span class="number">180</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> *ranges[] = &#123;h_ranges,s_ranges&#125;;</span><br><span class="line">    <span class="keyword">int</span> channels[] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cv::MatND hist1,hist2;</span><br><span class="line">    cv::calcHist(&amp;hsv_image1,<span class="number">1</span>,channels,cv::Mat(),hist1,<span class="number">2</span>,HistSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::normalize(hist1,hist1,<span class="number">0</span>,<span class="number">1</span>,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line">    cv::calcHist(&amp;hsv_image2,<span class="number">1</span>,channels,cv::Mat(),hist2,<span class="number">2</span>,HistSize,ranges,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    cv::normalize(hist2,hist2,<span class="number">0</span>,<span class="number">1</span>,cv::NORM_MINMAX,<span class="number">-1</span>,cv::Mat());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不同的直方图比较算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> method = i;</span><br><span class="line">        <span class="keyword">double</span> coefficient = cv::compareHist(hist1,hist2,method);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;method &quot;</span> &lt;&lt;i &lt;&lt; <span class="string">&quot; the coefficient is &quot;</span> &lt;&lt; coefficient &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage1&quot;</span>,srcImage1);</span><br><span class="line">    cv::imshow(<span class="string">&quot;srcImage2&quot;</span>,srcImage2);</span><br><span class="line">    cv::waitKey();</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="https://pic4.zhimg.com/80/v2-94da51fb0aeb49516bc6165434fd2e87_720w.jpg" alt="img"></p><p>图片显示：</p><p><img src="https://pic3.zhimg.com/80/v2-ab94d457dc8500c7ef4129b459a2b5fe_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-bebff0cde4b9f4f8f6ae23e90eb74305_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直方图对比用来计算图像的直方图的相似程度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>直方图均衡化</title>
    <link href="http://example.com/jsblog/ed8ed8eb.html"/>
    <id>http://example.com/jsblog/ed8ed8eb.html</id>
    <published>2020-12-23T12:54:52.000Z</published>
    <updated>2020-12-23T12:58:40.410Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们很难观察一幅非常亮或暗的图像的细节信息，因此对于差异较大的图像，我们可以尝试改变其图像灰度分布来使图像灰度阶分布尽量均匀，进而增强图像细节信息。<a id="more"></a>直方图均衡是拉伸各个像素分布来实现图像增强的，以累计分布函数变换基础，通过特定映射转换成一种更宽的分布，其核心就是把灰度分布映射成均匀分布</p><p>直方图均衡的目的是利用动态范围内的所有灰度阶，因此对于映射函数y=f(x),要求x在（0,1）的灰度是连续的，每一个元素都能得到相应的元素一一对应可得到下式：</p><p>p(x)dx = p(y)dy</p><p>对于均衡化的输出图像p(y) = 1，则同时积分得</p><p><img src="https://pic4.zhimg.com/80/v2-a36ecb40e3de909fde4e7712ec4ead73_720w.png" alt="img"></p><p>即映射函数为：</p><p>y = f(x) = p(x) – p(0)</p><p>直方图均衡化算法的步骤如下：</p><p>（1） 获取输入图像的直方图</p><p>（2） 求累计分布直方图，构建查找表</p><p>（3） 通过图像映射，计算新的图像像素分布</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat srcImage = cv::imread(<span class="string">&quot;E:/CodeBlocks/data/lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fail to load image&quot;</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat grayImage,histImage;</span><br><span class="line">    cv::cvtColor(srcImage,grayImage,cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::equalizeHist(grayImage,histImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;grayImage&quot;</span>,grayImage);</span><br><span class="line">    cv::imshow(<span class="string">&quot;histImage&quot;</span>,histImage);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://pic4.zhimg.com/80/v2-5acdaf808bdf585165830acd1c26d817_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-679d3c40ab103551f5956c279b43029d_720w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常我们很难观察一幅非常亮或暗的图像的细节信息，因此对于差异较大的图像，我们可以尝试改变其图像灰度分布来使图像灰度阶分布尽量均匀，进而增强图像细节信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>C++之RAII</title>
    <link href="http://example.com/jsblog/44da37.html"/>
    <id>http://example.com/jsblog/44da37.html</id>
    <published>2020-12-23T12:52:56.000Z</published>
    <updated>2020-12-23T12:58:40.385Z</updated>
    
    <content type="html"><![CDATA[<p>以前总是听过学习C++ 不知道RAII那就是不合格的c++程序员，那什么是RAII呢？<a id="more"></a>所谓RAII机制就是（Resource Acquisition Is Initialization，资源获取即初始化），在类的构造里申请资源，然后使用资源，最后在析构函数中释放资源。在计算机中有很多种资源，内存是我们经常使用的资源，此外还有文件描述符，socket以及数据库连接等，在程序中申请这些资源后利用完必须归还，否则会造成未定义的行为。如果对象在栈上创建，那么RAII会正常工作，在离开作用域的时候释放资源。如果是使用new操作符在堆上创建对象，那么就需要程序员手动delete对象，如果程序因为某些错误而无法delete对象，则有可能对系统造成未定义的行为，内存等部分资源就会永久丢失。</p><p>未使用RAII的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.lock();                    <span class="comment">// 请求互斥体</span></span><br><span class="line">    f();                         <span class="comment">// 若 f() 抛异常，则互斥体永远不被释放</span></span><br><span class="line">    <span class="keyword">if</span>(!everything_ok()) <span class="keyword">return</span>; <span class="comment">// 提早返回，互斥体永远不被释放</span></span><br><span class="line">    m.unlock();                  <span class="comment">// 若 bad() 抵达此语句，互斥才被释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>无论那一步操作失败都需要自己释放资源，如果使用了RAII则不需要自己关闭文件，在离开函数的时候，会自动释放文件描述符。</p><p>使用RAII机制的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// RAII类：互斥体的请求即是初始化</span></span><br><span class="line">    f();                               <span class="comment">// 若 f() 抛异常，则释放互斥体</span></span><br><span class="line">    <span class="keyword">if</span>(!everything_ok()) <span class="keyword">return</span>;       <span class="comment">// 提早返回，互斥体被释放</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>RAII的总结如下（cppreference）：</p><ul><li>将每个资源封装入一个类，其中</li></ul><p>· 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</p><p>· 析构函数释放资源并决不抛出异常；</p><ul><li>始终经由 RAII 类的实例使用满足要求的资源，该资源</li></ul><p>· 自身拥有自动存储期或临时生存期，或</p><p>· 具有与自动或临时对象的生存期绑定的生存期</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前总是听过学习C++ 不知道RAII那就是不合格的c++程序员，那什么是RAII呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>宏参数#和##</title>
    <link href="http://example.com/jsblog/b039a98a.html"/>
    <id>http://example.com/jsblog/b039a98a.html</id>
    <published>2020-12-23T12:52:10.000Z</published>
    <updated>2020-12-23T12:58:40.403Z</updated>
    
    <content type="html"><![CDATA[<p>作用：</p><p>使用#把宏参数变成一个字符串，使用##则是把两个红参数连接在一起 <a id="more"></a></p><p>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Str(var) #var</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Str(var) _Str(var)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _StringCat(str1) 123##str1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StringCat(str1) _StringCat(str1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,Str(<span class="number">123456</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,StringCat(<span class="number">123</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:当宏参数是另一个宏的时候，需要注意的是宏定义例有用“#”或“##”的地方宏参数是不会再展开。即只有当前的宏生效，参数里的宏不会生效。解决的办法就是增加新的宏定义做一个转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作用：&lt;/p&gt;
&lt;p&gt;使用#把宏参数变成一个字符串，使用##则是把两个红参数连接在一起&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>printf格式化输出</title>
    <link href="http://example.com/jsblog/67b33fcc.html"/>
    <id>http://example.com/jsblog/67b33fcc.html</id>
    <published>2020-12-23T12:51:26.000Z</published>
    <updated>2020-12-23T12:58:40.407Z</updated>
    
    <content type="html"><![CDATA[<p>学着学着好像忘记了好多知识， 回想一哈，原来不是自己忘记了而是自己从来没有认真的看过，用过。<a id="more"></a>只有等到用的时候才去百度一下。有时候用到去百度又会太浪费时间，所以现在纪录一下，方便自己的使用。</p><p>printf函数原型如下：</p><p>int printf(const char* format,…);</p><p>其中format表示两部分内容：</p><ol><li><ol><li>正常字符，直接输出</li><li>格式化字符以 “%”开始，用来表示输出内容格式。</li></ol></li></ol><p>格式化字符串的模板是：%[输出标志][输出最小宽度][.小数点位数][长度]类型</p><p>其中输出标志：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>“-”</td><td>左对齐</td></tr><tr><td>“+”</td><td>右对齐</td></tr><tr><td>“ ”</td><td>空格，符号为正显示空格，为负显示负号“-”</td></tr><tr><td>“#”</td><td>对c,s,d,u无影响，对o类输出前加缀为o,对x类，在输出前缀加0x，对e,g,f当结果有小数时给出小数点</td></tr></tbody></table><p>最小宽度 m：实际长度大于m时按照实际输出，实际长度小于m时，无标志则左边填充空格。若为“%-md”则右边填充到m长度为止。</p><p>小数点：</p><p>“%m.nf”：　　输出浮点数，m为宽度，n为小数点右边数位</p><p>“%m.ns”：　　输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n</p><p>长度：h为短整型，l为长整型</p><p>类型：</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%a,%A</td><td>浮点数、十六进制数字和p-计数法</td></tr><tr><td>%c</td><td>一个字符</td></tr><tr><td>%C</td><td>一个ISO宽字符</td></tr><tr><td>%d</td><td>有符号十进制整数（int）(%ld ，%Ld为：长整型数据，%hd：短整型数)</td></tr><tr><td>%e,%E</td><td>浮点数，e-计数法，E-计数法</td></tr><tr><td>%f</td><td>单精度浮点数</td></tr><tr><td>%g，%G</td><td>根据数值不同自动选择%f或%e</td></tr><tr><td>%i</td><td>有符号十进制数（与%d相同）</td></tr><tr><td>%o</td><td>无符号八进制整数</td></tr><tr><td>%p</td><td>指针</td></tr><tr><td>%s</td><td>对应字符串char*（%s = %hs = %hS 输出 窄字符）</td></tr><tr><td>%S</td><td>对应宽字符串WCAHR*（%ws = %S 输出宽字符串</td></tr><tr><td>%u</td><td>无符号十进制整数(unsigned int)</td></tr><tr><td>%x,%X</td><td>使用十六进制数字0xf的无符号十六进制整</td></tr><tr><td>%%</td><td>打印一个%号</td></tr><tr><td>%I64d</td><td>用于int64 或者 long long</td></tr><tr><td>%I64u</td><td>用于uint64 或者unsigned long long</td></tr><tr><td>%I64x</td><td>用于64 位16进制数字</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;学着学着好像忘记了好多知识， 回想一哈，原来不是自己忘记了而是自己从来没有认真的看过，用过。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>MoreEffective基础</title>
    <link href="http://example.com/jsblog/35778d45.html"/>
    <id>http://example.com/jsblog/35778d45.html</id>
    <published>2020-12-23T12:50:24.000Z</published>
    <updated>2020-12-23T12:58:40.404Z</updated>
    
    <content type="html"><![CDATA[<p><strong>条款一</strong> <strong>：认真区分pointers和 references</strong><a id="more"></a></p><ol><li><p>没有null reference,一个reference必须总代表着一个对象。pointer是可以为null的。</p></li><li><p>reference不能为null，所以使用reference可能会比pointer更有效率。</p></li><li><p>pointer可以被重新赋值，而reference总是指向它最初获得的那个对象。</p></li><li><p>当考虑不指向任何对象，或者在不同时刻可以指向不同对象时应使用pointer,如果确定一直是该对象，并且不再更改应该使用reference</p></li><li><p>在某些操作符重载的时候，需要使用reference,例如operator[]</p></li><li><p>当你需要指向某个东西，而且绝不会改变指向其他东西，或者重载操作符而语法需求无法由pointers达成，应该使用reference.任何其他时候应该使用pointer</p></li></ol><p><strong>条款二：最好使用C++转型操作符</strong></p><ol><li><p>static_cast 基本上具有与C旧式转型相同的威力与意义，以及想听听的限制</p></li><li><p>const_cast 用来改变表达式中的常量性（constness）和变易性(volatileness)。不能将const_cast用于其他的用途。const_cast最常见的就是去掉常量性</p></li><li><p>dynamic_cast 用来执行继承体系中“安全的向下转型或者跨系转型动作”。利用dynamic_cast 实现将 指向base class 的 pointer或者reference 转型为指向 derived class object的pointer或者reference,如果转型失败返回nullptr。dynamic_cast无法应用在缺乏虚函数的类型身上，也不能改变常量性。</p></li><li><p>reinterpret_cast 与平台相关，不具有可移植性。最常用的用途是转换 函数指针类型</p></li></ol><p><strong>条款三：绝对不要以多态方式处理数组</strong></p><p>C++ 规范：通过base class 指针删除一个由derived classes objects构成的数组，其结果未定义。简单的说就是多态和指针算术不能混用。因为derived class objects 的大小比base classes 的objects的大小要大，在进行运算的时候可能会出错。</p><p><strong>条款四：非必要不提供default constructor</strong></p><p>classes 如果缺乏一个default constructor,当你使用这个classs时可能会有某些限制。同时如果class 缺乏default constructor 它们将不适用于许多template-based container classes.但是添加没有意义的default container 可能会影响classes的效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;条款一&lt;/strong&gt; &lt;strong&gt;：认真区分pointers和 references&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>C++之Queue</title>
    <link href="http://example.com/jsblog/2d2a48d2.html"/>
    <id>http://example.com/jsblog/2d2a48d2.html</id>
    <published>2020-12-23T12:49:15.000Z</published>
    <updated>2020-12-23T12:58:40.384Z</updated>
    
    <content type="html"><![CDATA[<p>C++中实现了一个queue位于头文件中<queue>中。<a id="more"></a>queue是队列，队列是一种非常重要的数据结构，它是一种先进先出（LILO）的数据结构。作为一个模板类，可以方便的操作任意类型。</queue></p><p>queue的核心接口为：</p><p>push() : 入队，将一个元素放入队尾</p><p>front() : 返回队头元素</p><p>back(): 返回队尾元素</p><p>pop() : 从队列中移除一个元素</p><p>当然也可以利用容器自己实现一个队列，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by JSL on 2020/12/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYQUEUE_MYQUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYQUEUE_MYQUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueEmpty</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Queue empty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;::<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> QueueEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> QueueEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> QueueEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">elem</span><span class="params">(_con.front())</span></span>;</span><br><span class="line">        _con.pop_front();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        _con.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; _con;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MYQUEUE_MYQUEUE_HPP</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中实现了一个queue位于头文件中&lt;queue&gt;中。&lt;/queue&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之Stack</title>
    <link href="http://example.com/jsblog/137f4cdb.html"/>
    <id>http://example.com/jsblog/137f4cdb.html</id>
    <published>2020-12-23T12:48:53.000Z</published>
    <updated>2020-12-23T12:58:40.386Z</updated>
    
    <content type="html"><![CDATA[<p>C++中实现了一个stack位于头文件中<stack>中。<a id="more"></a>stack是栈，栈是一种非常重要的数据结构，它是一种先进后出或者是后进先出(LIFO)的数据结构。作为一个模板类，可以方便的操作任意类型。</stack></p><p>stack的核心接口为：</p><p>push() : 进栈，将一个元素放入栈中</p><p>top() : 返回栈中的头部元素</p><p>pop() : 从栈中移除元素</p><p>当然也可以利用容器自己实现一个栈，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by JSL on 2020/12/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSTACK_MYSTACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSTACK_MYSTACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadEmptyStack</span> :</span><span class="keyword">public</span> <span class="built_in">std</span>::exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read empty stack&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;::<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        _con.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> ReadEmptyStack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_con.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> ReadEmptyStack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">elem</span><span class="params">(_con.back())</span></span>;</span><br><span class="line">        _con.pop_back();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; _con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MYSTACK_MYSTACK_HPP</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中实现了一个stack位于头文件中&lt;stack&gt;中。&lt;/stack&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之可变参数模板</title>
    <link href="http://example.com/jsblog/940291e0.html"/>
    <id>http://example.com/jsblog/940291e0.html</id>
    <published>2020-12-23T12:47:48.000Z</published>
    <updated>2020-12-23T12:58:40.396Z</updated>
    
    <content type="html"><![CDATA[<p>从C++11开始，C++可以使用变长模板参数，能让函数接受任意数量的参. <a id="more"></a>，有时这些参数都组合成一个表达式，从中得到函数结果。可变模板参数比较抽象，使用起来需要一定的技巧，因为其需要一定的技巧才能使用，所以会显得比较有意思。</p><p><strong>可变模板参数函数</strong></p><p><strong>可变模板参数函数的声明：</strong></p><p>可变模板参数函数的声明和模板函数的声明类似，唯一不同的是需要在表示其抽象类型时即在关键字typename或者class的后面添加上省略号“…”。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;<span class="comment">//template&lt;class ...Args&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args... args)</span></span></span><br></pre></td></tr></table></figure><p>省略号的作用：</p><p>1.声明一个参数包，包含任意个参数</p><p>2.在模板定义的右边，可以将参数展开成一个一个独立的参数</p><p>展开参数包的方法有两种：</p><p>1.通过递归的模板函数展开</p><p>2.通过逗号表达式和初始化列表方式展开</p><p><strong>1.通过递归的模板函数展开参数包</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//递归终止函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(T&amp;&amp; value,Args&amp;&amp; ...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    show_list(args...);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    show_list(<span class="number">1</span>,<span class="number">123</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在使用递归的方式展开模板参数的时候，需要指定递归终止函数。递归终止函数与可变模板参数的函数同名。且当参数包中剩余的参数个数等于递归终止函数的参数个数时，会调用递归终止函数。</p><p><strong>2.通过逗号表达式和初始化列表方式展开</strong></p><p>使用递归函数比较好理解如何展开参数包，而使用逗号表达式和初始化列表的方式可能不那么容易理解，其中最关键的就是对于逗号表达式的理解。如果理解了逗号表达式那么应该也就很好理解了。逗号表达式示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = (x=y,m); </span><br></pre></td></tr></table></figure><p>对于括号中的求值顺序是从左往右，意思就是先进行 x=y的运算，将y赋值给x,然后将括号中的m赋值给z，这样z的值就为m。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(T&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_listl</span><span class="params">(Args&amp;&amp; ...args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;(show_list(args),<span class="number">0</span>)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    show_listl(<span class="number">1</span>,<span class="number">123</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其展开式为 {(show_list(arg0),0)…},{(show_list(arg0),0),(show_list(args1),0)…},{(show_list(arg0),0),(show_list(args1),0),(show_list(args2),0)…}…,{(show_list(arg0),0),(show_list(args1),0),(show_list(args2),0),….,(show_list(argsn),0)}.最终会创建一个元素全部为0的数组。</p><p>下面是使用列表初始化和lambda函数的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(T&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_listl</span><span class="params">(F&amp;&amp; f,Args&amp;&amp; ...args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;(&#123;(f(args),<span class="number">0</span>)...&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    show_listl([](<span class="keyword">auto</span> t)&#123;<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;&#125;,<span class="number">1</span>,<span class="number">123</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数模板类"><a href="#可变参数模板类" class="headerlink" title="可变参数模板类"></a><strong>可变参数模板类</strong></h2><p>当然也可以使用可变模板参数来对结构体或者类进行声明，请声明方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt; <span class="comment">// template&lt;class ...Args&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span>&#125;; <span class="comment">//struct Car&#123;&#125;;</span></span><br></pre></td></tr></table></figure><p>对于可变参数模板类来说，模板的参数个数可以为任意个。但是可变参数模板类的展开可以通过两个方式进行展开：</p><p>1.通过模板偏特化和递归的方式展开</p><p>2.通过继承的方式展开参数包</p><p><strong>1.通过模板偏特化和递归的方式展开</strong></p><p>如下代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//递归终止，其模板参数可以是多个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;T&gt;&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;value = <span class="keyword">sizeof</span>(T)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板类的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&lt;T,Args...&gt;&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;value = Sum&lt;T&gt;::value + Sum&lt;Args...&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Sum&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">double</span> &gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意不要忘记声明递归终止的类，否则会出错哦。</p><p><strong>2.通过继承的方式展开参数包</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义整型序列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>...&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexSeq</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//继承方式展开参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N,<span class="keyword">int</span>... Indexes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexs</span> :</span> MakeIndexs &lt;N<span class="number">-1</span>,N<span class="number">-1</span>,Indexes...&gt;&#123;&#125;;</span><br><span class="line"><span class="comment">//模板特化，终止展开的条件</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Indexes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MakeIndexs</span>&lt;0,Indexes...&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> IndexSeq&lt;Indexes...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MakeIndexs&lt;<span class="number">3</span>&gt;::type m3;</span><br><span class="line">    MakeIndexs&lt;<span class="number">6</span>&gt;::type m6;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(m3).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(m6).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;从C++11开始，C++可以使用变长模板参数，能让函数接受任意数量的参.&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之unordered容器</title>
    <link href="http://example.com/jsblog/8fa8fc90.html"/>
    <id>http://example.com/jsblog/8fa8fc90.html</id>
    <published>2020-12-23T12:46:57.000Z</published>
    <updated>2020-12-23T12:58:40.393Z</updated>
    
    <content type="html"><![CDATA[<p>无序容器以一种随意顺序包含插入进去的所有元素。并以一种随机的次序访问他们。<!--mpre-->unordered_set和unordered_multiset存放的是特定类型的个别value,而unordered_map和unordered_multimap存放的元素都是key/value pair,其中key用来作为存放和查找特定元素的依据。unordered_set, unordered_multiset, unordered_map unordered_multimap的实现都是以hash table为底层数据结构。和map,set一样，unordered_set和unordered_map不允许有重复的元素，而unordered_multiset和unordered_multimap允许元素重复。unordered_set, unordered_multiset,位于头文件<unordered_set>,unordered_map unordered_multimap位于头文件<unordered_map>.</unordered_map></unordered_set></p><p>unordered_set和unordered_multiset的元素类型，必须是可比较的。</p><p>unordered_map和unordered_multimap是key/value类型的，对于其中的key、value的要求如下：</p><ol><li><p>key和value都必须可以复制和可以移动（movable）</p></li><li><p>key必须是可以等价准则比较的。</p></li></ol><p>对于模板中的参数Hash用来定义hash函数，如果是自己定义的类型，就必须指定hash函数。</p><p>对于无序容器的构造函数与set和map的构造函数类似，不过可以对于自己定义的类型，需要自己定义特殊的hash 函数。这个hash函数的要求是一个必须是个函数或者是一个function object它接受一个value作为参数，并返回一个std::size_t的value.</p><p>无序容器的接口与set和map的接口差不多，但是相比于set和map而言，无序容器不支持双向迭代器，它的迭代器是一个单向的迭代器。</p><p>构造函数，拷贝构造，拷贝赋值，析构函数</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>Unordered c;</td><td>默认构造函数，创建一个空的无序容器</td></tr><tr><td>Unordered c(bnum)</td><td>建立一个空的Unordered对象，内部至少使用bnum个bucket</td></tr><tr><td>Unordered c(bnum,hf)</td><td>建立一个空的Unordered对象，内部至少使用bnum个bucket,并以hf作为hash 函数</td></tr><tr><td>Unordered c(bnum,hf,cmp)</td><td>建立一个空的Unordered对象，内部至少使用bnum个bucket,并以hf作为hash 函数，并以cmp作为predicate用来鉴定value</td></tr><tr><td>Unordered c(c2)</td><td>copy constructor</td></tr><tr><td>Unordered c = c2;</td><td>copy constructor</td></tr><tr><td>Unordered c(rv)</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>Unordered c = rv</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>Unordered c(beg,end)</td><td>以区间[beg,end)内的元素为c的初值</td></tr><tr><td>Unordered c(beg,end,bnum)</td><td>以区间[beg,end)内的元素为c的初值，内部至少使用bnum个bucket</td></tr><tr><td>Unordered c(beg,end,bnum,hf)</td><td>以区间[beg,end)内的元素为c的初值，内部至少使用bnum个bucket，并以hf作为hash 函数</td></tr><tr><td>Unordered c(beg,end,bnum,hf,cmp)</td><td>以区间[beg,end)内的元素为c的初值，内部至少使用bnum个bucket，并以hf作为hash 函数并以cmp作为predicate用来鉴定value</td></tr><tr><td>Unordered c(initlist)</td><td>列表初始化</td></tr><tr><td>Unordered c = initlist</td><td>列表初始化</td></tr><tr><td>c.~ Unordered ()</td><td>析构函数</td></tr></tbody></table><p>其中 Unordered的形式为以下几种：</p><p>unordered_set<Elem> / unorderd_set&lt;Elem,Hash&gt; / unordered_set&lt;Elem,Hash,Cmp&gt;</Elem></p><p>unordered_multiset<Elem> / unorderd_multiset&lt;Elem,Hash&gt; / unordered_multiset&lt;Elem,Hash,Cmp&gt;</Elem></p><p>unordered_map<Elem> / unorderd_map&lt;Elem,Hash&gt; / unordered_map&lt;Elem,Hash,Cmp&gt;</Elem></p><p>unordered_multimap<Elem> / unorderd_multimap&lt;Elem,Hash&gt; / unordered_multimap&lt;Elem,Hash,Cmp&gt;</Elem></p><p><strong>无序容器的布局函数</strong>：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.hash_function()</td><td>返回hash函数</td></tr><tr><td>c.key_eq()</td><td>返回相等性判断式</td></tr><tr><td>c.bucket_count()</td><td>返回当前的bucket个数</td></tr><tr><td>c.max_bucket_count()</td><td>返回bucket的最大可能数量</td></tr><tr><td>c.load_factor()</td><td>返回当前的负载因子</td></tr><tr><td>c.max_load_factor()</td><td>返回当前的最大负载系数</td></tr><tr><td>c,max_load_factor(val)</td><td>设定当前的最大负载系数为val</td></tr><tr><td>c.rehash(bnum)</td><td>将容器重新计算hash，使其bucket至少为bnum</td></tr><tr><td>c．reverse(num)</td><td>将容器重新计算hash，使其至少可以容纳num个元素</td></tr></tbody></table><p><strong>非更改操作：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.empty()</td><td>容器是否为空</td></tr><tr><td>c.size()</td><td>目前的元素个数</td></tr><tr><td>c.max_size()</td><td>元素个数的最大可能量</td></tr><tr><td>c1 == c2</td><td>c1是否等于c2(每个元素调用 == )</td></tr><tr><td>c1 != c2</td><td>c1 是否 不等于 c2</td></tr></tbody></table><p>查找函数：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.count(val)</td><td>返回容器中key为val的个数</td></tr><tr><td>c.find(val)</td><td>返回容器中第一个元素为key为val的元素，找不到返回val</td></tr><tr><td>c.equal_range(val)</td><td>返回key为val可被插入的第一个位置和最后一个位置即key==val的元素区间</td></tr></tbody></table><p>赋值操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c = c1</td><td>copy assignment，将c2元素赋值给c</td></tr><tr><td>c = rv</td><td>move assignment,</td></tr><tr><td>c = initilist</td><td>将初值列的元素赋值给c</td></tr><tr><td>c1.swap(c2)</td><td>交换c1和c2的元素</td></tr><tr><td>swap(c1,c2)</td><td>交换c1和c2的元素</td></tr></tbody></table><p>迭代器：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.begin()</td><td>返回一个 forward iterator指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 forward iterator指向末尾元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const forward iterator指向第一元素</td></tr><tr><td>c.cend()</td><td>返回一个 const forward iterator指向末尾元素的下一位置</td></tr><tr><td>c.rbegin()</td><td>返回一个 reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个 reverse iterator指向反向迭代的末尾元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.crend()</td><td>返回一个const reverse iterator指向反向迭代的末尾元素的下一位置</td></tr></tbody></table><p>元素操作：(下面的元素指的是 key/value pair)</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.insert(val)</td><td>插入val,并返回新元素的位置</td></tr><tr><td>c.insert(pos,val)</td><td>以pos为起点在[pos,end)中插入val，返回新元素的位置</td></tr><tr><td>c.insert(beg,end)</td><td>将区间[beg,end)内的元素插入到c中</td></tr><tr><td>c.insert(initlist)</td><td>将初值列的元素插入到c中</td></tr><tr><td>c.emplace(args…)</td><td>插入一个args元素的值，并返回新元素的位置</td></tr><tr><td>c.emplace_hint(pos,args…)</td><td>以pos为起点在[pos,end)中插入args，返回新元素的位置</td></tr><tr><td>c.erase(val)</td><td>移除与 val相等的所有元素，返回被移除的个数</td></tr><tr><td>c.erase(pos)</td><td>移除iterator位置pos上的元素，无返回值</td></tr><tr><td>c.erase(beg,end)</td><td>移除区间[beg,end)内的元素，无返回值</td></tr><tr><td>c.clear()</td><td>将容器清空</td></tr></tbody></table><p>关联式操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c[key]</td><td>如果key存在，则返回key元素的值，如果不存则插入一个key/value元素</td></tr><tr><td>c.at(key)</td><td>返回对应key/value中对应key的value</td></tr></tbody></table><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_set</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_set----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; coll = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    coll.insert(&#123;<span class="number">-7</span>,<span class="number">17</span>,<span class="number">33</span>,<span class="number">-11</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">13</span>&#125;);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (coll.find(<span class="number">19</span>) != coll.end())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;19 is available&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_multiset----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt; coll = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    coll.insert(&#123;<span class="number">-7</span>,<span class="number">17</span>,<span class="number">33</span>,<span class="number">-11</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">13</span>&#125;);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (coll.find(<span class="number">19</span>) != coll.end())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;19 is available&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_map----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; coll;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">10</span> ; ++i) &#123;</span><br><span class="line">        coll[i] = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">101</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">102</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">103</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;first &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multimap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ------------unordered_multimap----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; coll;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">10</span> ; ++i) &#123;</span><br><span class="line">        coll.insert(&#123;i,<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i) / <span class="number">10</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.02</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">100</span>,<span class="number">0.03</span>&#125;);</span><br><span class="line">    coll.insert(&#123;<span class="number">103</span>,<span class="number">0.01</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;first &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            pos = coll.erase(pos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin();pos != coll.end();++pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coll[&quot;</span> &lt;&lt;  pos-&gt;first &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_multiset();</span><br><span class="line">    test_set();</span><br><span class="line">    test_map();</span><br><span class="line">    test_multimap();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;无序容器以一种随意顺序包含插入进去的所有元素。并以一种随机的次序访问他们。&lt;!--mpre--&gt;unordered_set和unordered_multiset存放的是特定类型的个别value,而unordered_map和unordered_multimap存放的元素都是</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之map</title>
    <link href="http://example.com/jsblog/ae064968.html"/>
    <id>http://example.com/jsblog/ae064968.html</id>
    <published>2020-12-23T12:45:38.000Z</published>
    <updated>2020-12-23T12:58:40.390Z</updated>
    
    <content type="html"><![CDATA[<p>map和multimap将key/value pair当作元素进行管理。<a id="more"></a>它们可根据key的排序准则自动为元素进行排序。multimap允许元素重复，但map不允许。map和multimap位于头文件<map>中。map和multimap的元素类型Key 和value T必须满足以下条件：</map></p><ol><li><p>Key 和 value必须都是copyable（可复制的）和movable(可移动的)</p></li><li><p>对指定的排序规则，key必须是可比较的</p></li></ol><p>如果没有指定排序规则，那就使用默认的less&lt;&gt;排序规则，以operator&lt;进行比较。map和multimap通常也是以平衡二叉树来完成。map和multimap会对key/value根据key的排序规则自动排序，也可以很方便的通过key找到value,但是通过value找到key效率并不是很好。和set一样，不能直接修改元素的key，要想修改元素的key,需要先移除拥有该key的元素，然后插入新的key/value的元素，对于value可以直接更改。</p><p>操作函数：</p><p>构造函数，拷贝构造，拷贝赋值，析构函数</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>map m;</td><td>默认构造函数，创建一个空的map/multimap</td></tr><tr><td>map m(op)</td><td>建立一个空的map/multimap对象，以op为排序准则</td></tr><tr><td>map m(m2)</td><td>copy constructor</td></tr><tr><td>map m = m2;</td><td>copy constructor</td></tr><tr><td>map m(rv)</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>map m = rv</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>map m(beg,end)</td><td>以区间[beg,end)内的元素为m的初值</td></tr><tr><td>map m(beg,end,op)</td><td>以区间[beg,end)内的元素为m的初值，以op为排序准则</td></tr><tr><td>map m(initlist)</td><td>列表初始化</td></tr><tr><td>map m = initlist</td><td>列表初始化</td></tr><tr><td>m.~map()</td><td>析构函数</td></tr></tbody></table><p>其中 map 的形式为以下几种：</p><table><thead><tr><th>map</th><th>含义</th></tr></thead><tbody><tr><td>map&lt;key,Value&gt;</td><td>一个map使用默认的排序准则</td></tr><tr><td>map&lt;key,Value,Op&gt;</td><td>一个map使用op排序准则</td></tr><tr><td>multimap&lt;key,Value&gt;</td><td>一个multimap使用默认的排序准则</td></tr><tr><td>multimap&lt;key,Value,Op&gt;</td><td>一个multimap使用op排序准则</td></tr></tbody></table><p><strong>非更改操作：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.key_comp()</td><td>返回 op</td></tr><tr><td>c.value_comp()</td><td>返回 针对value的排序准则</td></tr><tr><td>c.empty()</td><td>容器是否为空</td></tr><tr><td>c.size()</td><td>目前的元素个数</td></tr><tr><td>c.max_size()</td><td>元素个数的最大可能量</td></tr><tr><td>c1 == c2</td><td>c1是否等于c2(每个元素调用 == )</td></tr><tr><td>c1 != c2</td><td>c1 是否 不等于 c2</td></tr><tr><td>c1 &lt; c2</td><td>c1 是否小于 c2</td></tr><tr><td>c1 &gt; c2</td><td>c1 是否大于 c2</td></tr><tr><td>c1 &lt;= c2</td><td>c1 是否小于等于c2</td></tr><tr><td>c1 &gt;= c2</td><td>c1 是否大于等于 c2</td></tr></tbody></table><p>查找函数：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.count(val)</td><td>返回容器中key为val的个数</td></tr><tr><td>c.find(val)</td><td>返回容器中第一个元素为key为val的元素，没有返回end()</td></tr><tr><td>c.lower_bound(val)</td><td>返回key为val第一个可以插入的位置，也就是key&gt;=val的第一个位置</td></tr><tr><td>c.upper_bound(val)</td><td>返回key为val最后一个可以插入的位置，也就是key&gt;val的第一个位置</td></tr><tr><td>c.equal_range(val)</td><td>返回key为val可被插入的第一个位置和最后一个位置即key==val的元素区间</td></tr></tbody></table><p>赋值操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c = c1</td><td>copy assignment，将c2元素赋值给c</td></tr><tr><td>c = rv</td><td>move assignment,</td></tr><tr><td>c = initilist</td><td>将初值列的元素赋值给c</td></tr><tr><td>c1.swap(c2)</td><td>交换c1和c2的元素</td></tr><tr><td>swap(c1,c2)</td><td>交换c1和c2的元素</td></tr></tbody></table><p>迭代器：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.begin()</td><td>返回一个 bidirectional iterator指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const bidirectional iterator指向第一元素</td></tr><tr><td>c.cend()</td><td>返回一个 const bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.rbegin()</td><td>返回一个 reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个 reverse iterator指向反向迭代的末尾元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.crend()</td><td>返回一个const reverse iterator指向反向迭代的末尾元素的下一位置</td></tr></tbody></table><p>元素操作：(下面的元素指的是 key/value pair)</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.insert(val)</td><td>插入val,并返回新元素的位置</td></tr><tr><td>c.insert(pos,val)</td><td>以pos为起点在[pos,end)中插入val，返回新元素的位置</td></tr><tr><td>c.insert(beg,end)</td><td>将区间[beg,end)内的元素插入到c中</td></tr><tr><td>c.insert(initlist)</td><td>将初值列的元素插入到c中</td></tr><tr><td>c.emplace(args…)</td><td>插入一个args元素的值，并返回新元素的位置</td></tr><tr><td>c.emplace_hint(pos,args…)</td><td>以pos为起点在[pos,end)中插入args，返回新元素的位置</td></tr><tr><td>c.erase(val)</td><td>移除与 val相等的所有元素，返回被移除的个数</td></tr><tr><td>c.erase(pos)</td><td>移除iterator位置pos上的元素，无返回值</td></tr><tr><td>c.erase(beg,end)</td><td>移除区间[beg,end)内的元素，无返回值</td></tr><tr><td>c.clear()</td><td>将容器清空</td></tr></tbody></table><p>关联式操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>m[key]</td><td>如果key存在，则返回key元素的值，如果不存则插入一个key/value元素</td></tr><tr><td>m.at(key)</td><td>返回对应key/value中对应key的value</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; SSMap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillAndPrint</span><span class="params">(SSMap&amp; ssMap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SSMap  coll;</span><br><span class="line">    fillAndPrint(coll);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size : &quot;</span> &lt;&lt; coll.size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max size : &quot;</span> &lt;&lt; coll.max_size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillAndPrint</span><span class="params">(SSMap&amp; ssMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ssMap[<span class="string">&quot;Deutschland&quot;</span>] = <span class="string">&quot;germangy&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;deutsch&quot;</span>] = <span class="string">&quot;genman&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;Haken&quot;</span>] = <span class="string">&quot;snag&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;arbeiten&quot;</span>] = <span class="string">&quot;work&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;Hund&quot;</span>] = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">    ssMap[<span class="string">&quot;gen&quot;</span>] = <span class="string">&quot;walk&quot;</span>;</span><br><span class="line">    ssMap.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;gooo&quot;</span>));</span><br><span class="line">    ssMap.insert(&#123;<span class="string">&quot;test&quot;</span>,<span class="string">&quot;initlist&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">auto</span> pos = find_if(ssMap.begin(),ssMap.end(),[](<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&amp; elem )&#123;</span><br><span class="line">        <span class="keyword">return</span> elem.first == <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (pos != ssMap.end())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; key : &quot;</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">&quot; value : &quot;</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ssMap.count(<span class="string">&quot;gen&quot;</span>))&#123;</span><br><span class="line">        ssMap[<span class="string">&quot;gen&quot;</span>] = <span class="string">&quot;Walk&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        ssMap[<span class="string">&quot;gen&quot;</span>] = <span class="string">&quot;goes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos = ssMap.find(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != ssMap.end())&#123;</span><br><span class="line">        ssMap.erase(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::left,ios::adjustfield);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : ssMap)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">15</span>) &lt;&lt; elem.first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; elem.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size : &quot;</span> &lt;&lt; ssMap.size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max size : &quot;</span> &lt;&lt; ssMap.max_size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    ssMap.clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;map和multimap将key/value pair当作元素进行管理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之set</title>
    <link href="http://example.com/jsblog/dbbfc60f.html"/>
    <id>http://example.com/jsblog/dbbfc60f.html</id>
    <published>2020-12-23T12:45:08.000Z</published>
    <updated>2020-12-23T12:58:40.392Z</updated>
    
    <content type="html"><![CDATA[<p>Set和MultiSet会按照特定的排序规则，自动将元素排序。两者的不同是在于mutilset允许有重复元素在容器内，而set则不允许有重复元素。set和multiset位于头文件<set>中。<a id="more"></a></set></p><p>对于set和multiset而言,只要是comparable（可依据某排序准则比较）的任意类型T都可以成为set或multiset的元素类型，如果没有自定义排序准则，那么set和multiset就会使用默认的仿函数less用来作为排序的准则,以operator&lt;对元素进行比较。所谓的排序准则需要遵循以下原则：</p><ol><li><p>必须是非对称的：若x op y为true，则 y op x 为 false</p></li><li><p>必须是可传递的：如 x op y为 true且 y op z 为true,则 x op z 为 true</p></li><li><p>必须是非自反的: x op x为 false</p></li><li><p>必须有等效传递性： 如果 a = b且 b=c 那么 a = c</p></li></ol><p>multiset的等效元素是随机且稳定的。set和multiset通常以平衡二叉树实现。自动排序的主要优点在于令二叉树于查找元素时拥有良好的效能。其查找函数具有对数复杂度。但是不能直接改变元素值，要想改变元素值，需要删除旧的元素再插入新元素。set和multiset不提供任何操作函数可以直接访问元素，通过迭代器进行元素间接访问，元素值是常量。</p><p>操作函数：</p><p>构造函数，拷贝构造，拷贝赋值，析构函数</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>set/multiset c</td><td>创建一个空的set/multiset对象c</td></tr><tr><td>set/multiset c(op)</td><td>建立一个空的set/multiset对象，以op为排序准则</td></tr><tr><td>set/multiset c(c1)</td><td>copy constructor</td></tr><tr><td>set/multiset c = c1</td><td>copy constructor</td></tr><tr><td>set/multiset c(rv)</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>set/multiset c = rv</td><td>move constructor.rv的所有资源被释放</td></tr><tr><td>set/multiset c(beg,end)</td><td>以区间[beg,end)内的元素为c的初值</td></tr><tr><td>set/multiset c(beg,end,op)</td><td>以区间[beg,end)内的元素为c的初值，以op为排序准则</td></tr><tr><td>set/multiset c(initlist)</td><td>列表初始化</td></tr><tr><td>set/multiset c=initlist</td><td>列表初始化</td></tr><tr><td>c.<del>set/c.</del>multiset()</td><td>析构函数</td></tr></tbody></table><p>其中 set代表 set<T>,multiset 代表 multiset<T></T></T></p><p><strong>非更改操作：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.key_comp()</td><td>返回 op</td></tr><tr><td>c.value_comp()</td><td>返回 op</td></tr><tr><td>c.empty()</td><td>容器是否为空</td></tr><tr><td>c.size()</td><td>目前的元素个数</td></tr><tr><td>c.max_size()</td><td>元素个数的最大可能量</td></tr><tr><td>c1 == c2</td><td>c1是否等于c2(每个元素调用 == )</td></tr><tr><td>c1 != c2</td><td>c1 是否 不等于 c2</td></tr><tr><td>c1 &lt; c2</td><td>c1 是否小于 c2</td></tr><tr><td>c1 &gt; c2</td><td>c1 是否大于 c2</td></tr><tr><td>c1 &lt;= c2</td><td>c1 是否小于等于c2</td></tr><tr><td>c1 &gt;= c2</td><td>c1 是否大于等于 c2</td></tr></tbody></table><p>查找函数：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>c.ount(val)</td><td>返回容器中val的个数</td></tr><tr><td>c.find(val)</td><td>返回容器中第一个元素为val的元素，没有返回end()</td></tr><tr><td>c.lower_bound(val)</td><td>返回val第一个可以插入的位置，也就是元素值&gt;=val的第一个位置</td></tr><tr><td>c.upper_bound(val)</td><td>返回val最后一个可以插入的位置，也就是元素值&gt;val的第一个位置</td></tr><tr><td>c.equal_range(val)</td><td>返回val可被插入的第一个位置和最后一个位置即元素值==val的元素区间</td></tr></tbody></table><p>赋值操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c = c1</td><td>copy assignment，将c2元素赋值给c</td></tr><tr><td>c = rv</td><td>move assignment,</td></tr><tr><td>c = initilist</td><td>将初值列的元素赋值给c</td></tr><tr><td>c1.swap(c2)</td><td>交换c1和c2的元素</td></tr><tr><td>swap(c1,c2)</td><td>交换c1和c2的元素</td></tr></tbody></table><p>迭代器：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.begin()</td><td>返回一个 bidirectional iterator指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const bidirectional iterator指向第一元素</td></tr><tr><td>c.cend()</td><td>返回一个 const bidirectional iterator指向末尾元素的下一位置</td></tr><tr><td>c.rbegin()</td><td>返回一个 reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个 reverse iterator指向反向迭代的末尾元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator指向反向迭代的第一元素</td></tr><tr><td>c.crend()</td><td>返回一个const reverse iterator指向反向迭代的末尾元素的下一位置</td></tr></tbody></table><p>元素操作：</p><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody><tr><td>c.insert(val)</td><td>插入val,并返回新元素的位置</td></tr><tr><td>c.insert(pos,val)</td><td>以pos为起点在[pos,end)中插入val，返回新元素的位置</td></tr><tr><td>c.insert(beg,end)</td><td>将区间[beg,end)内的元素插入到c中</td></tr><tr><td>c.insert(initlist)</td><td>将初值列的元素插入到c中</td></tr><tr><td>c.emplace(args…)</td><td>插入一个args元素的值，并返回新元素的位置</td></tr><tr><td>c.emplace_hint(pos,args…)</td><td>以pos为起点在[pos,end)中插入args，返回新元素的位置</td></tr><tr><td>c.erase(val)</td><td>移除与 val相等的所有元素，返回被移除的个数</td></tr><tr><td>c.erase(pos)</td><td>移除iterator位置pos上的元素，无返回值</td></tr><tr><td>c.erase(beg,end)</td><td>移除区间[beg,end)内的元素，无返回值</td></tr><tr><td>c.clear()</td><td>将容器清空</td></tr></tbody></table><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; coll1;</span><br><span class="line">    coll1.insert(&#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">15</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    coll1.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; elem : coll1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    copy(coll1.rbegin(),coll1.rend(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pos = coll1.insert(<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos.second)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;21 insert as element &quot;</span> &lt;&lt; distance(coll1.begin(),pos.first) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;21 is exists&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">coll2</span><span class="params">(coll1.begin(),coll1.end())</span></span>;</span><br><span class="line">    copy(coll2.begin(),coll2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    coll2.erase(coll2.begin(),coll2.find(<span class="number">21</span>));</span><br><span class="line">    <span class="keyword">int</span> num = coll2.erase(<span class="number">45</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; elements is removed &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(coll2.begin(),coll2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Set和MultiSet会按照特定的排序规则，自动将元素排序。两者的不同是在于mutilset允许有重复元素在容器内，而set则不允许有重复元素。set和multiset位于头文件&lt;set&gt;中。&lt;/set&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之forward_list</title>
    <link href="http://example.com/jsblog/ef69092c.html"/>
    <id>http://example.com/jsblog/ef69092c.html</id>
    <published>2020-12-23T12:44:30.000Z</published>
    <updated>2020-12-23T12:58:40.389Z</updated>
    
    <content type="html"><![CDATA[<p>Forward list 是class forward_list&lt;&gt;的一个实例，其内部以一个single linked list管理元素。<a id="more"></a>forward_list位于<forward_list>头文件中。相对于list而言，forward_list只提供了前向迭代器，因此它不支持反向迭代器。它也不提供size函数，如果提供size函数会浪费大量开销，forward_list也没有指向最末元素的指针。forward_list可以看成是一个单向链表。</forward_list></p><p>forward_list的成员函数如下：</p><table><thead><tr><th>empty()</th><th>判断容器是否为空</th></tr></thead><tbody><tr><td>max_size()</td><td>返回容器的最大可能数量</td></tr><tr><td>operator==()</td><td>判断两个forward_list是否相等</td></tr><tr><td>operator!=()</td><td>判断两个forward_list是否不等</td></tr><tr><td>operator&lt;()</td><td>判断一个forward_list是否小于另外一个forward_list</td></tr><tr><td>operator&gt;()</td><td>判断一个forward_list是否大于另外一个forward_list</td></tr><tr><td>operator&lt;=()</td><td>判断一个forward_list是否小于等于另外一个forward_list</td></tr><tr><td>operator&gt;=()</td><td>判断一个forward_list是否大于等于另外一个forward_list</td></tr><tr><td>operator=()</td><td>将一个forward_list拷贝到另外一个forward_list</td></tr><tr><td>assign()</td><td>为forward_list赋值</td></tr><tr><td>swap()</td><td>交换两个链表</td></tr><tr><td>front()</td><td>返回头部元素</td></tr><tr><td>begin()</td><td>返回指向第一个元素的迭代器</td></tr><tr><td>end()</td><td>返回指向末尾的迭代器</td></tr><tr><td>cbegin()</td><td>返回指向第一个元素的const迭代器</td></tr><tr><td>cend()</td><td>返回指向末尾的const迭代器</td></tr><tr><td>before_begin()</td><td>返回指向第一元素的迭代器</td></tr><tr><td>cbefore_begin()</td><td>返回指向第一元素的前一位置的const 迭代器</td></tr><tr><td>push_front()</td><td>在头部插入一个元素</td></tr><tr><td>pop_front()</td><td>移除第一个元素</td></tr><tr><td>insert_after(pos,elem)</td><td>在pos后插入elem</td></tr><tr><td>emplace_after(pos,elem)</td><td>在pos位置后插入elem,不添加元素</td></tr><tr><td>emplace_front(elem)</td><td>在起点插入elem</td></tr><tr><td>earse_after(pos)</td><td>移除pos后的所有元素</td></tr><tr><td>resize(size)</td><td>将元素数量该为size</td></tr><tr><td>clear()</td><td>清除所有元素内容</td></tr><tr><td>unique()</td><td>移除重复而相邻的元素只留一个</td></tr><tr><td>splice_after(pos,c2)</td><td>将c2所有元素转移到pos之后</td></tr><tr><td>sort()</td><td>排序</td></tr><tr><td>merge(c2)</td><td>将两个链表合并为一个链表</td></tr><tr><td>reverse()</td><td>逆序</td></tr></tbody></table><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; fl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        fl.push_front(i*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> fl2 = fl;</span><br><span class="line">    fl2.reverse();</span><br><span class="line">    copy(fl2.begin(),fl2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (fl == fl2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (fl &gt; fl2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (fl &lt; fl2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    fl.insert_after(fl.begin(),<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> fl3 = fl2;</span><br><span class="line">    fl.merge(fl2);</span><br><span class="line">    fl.sort();</span><br><span class="line">    fl.unique();</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    fl2.splice_after(fl2.before_begin(),fl3);</span><br><span class="line">    copy(fl2.begin(),fl2.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    fl.pop_front();</span><br><span class="line">    fl.pop_front();</span><br><span class="line">    fl.remove(<span class="number">2</span>);</span><br><span class="line">    fl.resize(<span class="number">20</span>,<span class="number">9</span>);</span><br><span class="line">    fl.remove_if([](<span class="keyword">auto</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>;&#125;);</span><br><span class="line">    fl.emplace_after(++fl.begin(),<span class="number">5</span>);</span><br><span class="line">    fl.erase_after(++fl.begin());</span><br><span class="line">    copy(fl.begin(),fl.end(),ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;max size : &quot;</span> &lt;&lt; fl.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Forward list 是class forward_list&amp;lt;&amp;gt;的一个实例，其内部以一个single linked list管理元素。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之deque</title>
    <link href="http://example.com/jsblog/fdd2317.html"/>
    <id>http://example.com/jsblog/fdd2317.html</id>
    <published>2020-12-23T12:43:36.000Z</published>
    <updated>2020-12-23T12:58:40.387Z</updated>
    
    <content type="html"><![CDATA[<p>std::deque位于头文件<deque>容器deque和vector类似，它也采用动态数组来管理元素.<a id="more"></a>提供随机访问，并有和vector一模一样的接口，不同的是deque是双端队列，头尾都开发。即可以在头尾快速插入和删除。</deque></p><p>deque的构造函数：默认构造、copy constructor、move constructor以及列表初始化构造</p><p>deque的copy assignment函数：有 default copy assignment 和 move copy assignment</p><p>deque的析构函数就有一个默认析构函数，负责销毁元素释放内存</p><p>其操作如下：</p><table><thead><tr><th>empty()</th><th>返回容器是否为空</th></tr></thead><tbody><tr><td>size()</td><td>返回元素个数</td></tr><tr><td>max_size()</td><td>返回元素个数的最大可能量</td></tr><tr><td>shrink_to_fit()</td><td>减少容量到符合元素个数</td></tr><tr><td>operator==();</td><td>判断两个deque是否相等，容器内元素相等</td></tr><tr><td>operator !=();</td><td>判断两个deque是否不相等，容器内任一元素不相等即可</td></tr><tr><td>operator&lt;()</td><td>返回一个deque是否小于另外一个deque</td></tr><tr><td>operator&gt;()</td><td>返回一个deque是否大于另外一个deque</td></tr><tr><td>operator &lt;=()</td><td>返回一个deque是否小于等于另外一个deque</td></tr><tr><td>operator &gt;=()</td><td>返回一个deque是否大于等于另外一个deque</td></tr><tr><td>operator [](size_t idx);</td><td>返回索引idx所指的元素</td></tr><tr><td>at(size_t idx);</td><td>返回索引idx所指的元素</td></tr><tr><td>front()</td><td>返回初始位置的元素</td></tr><tr><td>back()</td><td>返回最后位置的元素</td></tr><tr><td>begin()</td><td>返回指向首元素的迭代器</td></tr><tr><td>end()</td><td>返回指向末元素的迭代器</td></tr><tr><td>cbegin()</td><td>返回指向首元素的const迭代器</td></tr><tr><td>cend()</td><td>返回指向末元素的const迭代器</td></tr><tr><td>rbegin()</td><td>返回反向的指向第一个元素的迭代器</td></tr><tr><td>rend()</td><td>返回反向的指向末尾元素的迭代器</td></tr><tr><td>crbegin()</td><td>返回反向的指向第一个元素的const迭代器</td></tr><tr><td>crend()</td><td>返回反向的指向末尾元素的const迭代器</td></tr><tr><td>assign(n,elem)</td><td>复制n个elem</td></tr><tr><td>assign(begin,end)</td><td>将区间begin到end的元素复制给deque</td></tr><tr><td>assign(initilist)</td><td>将初值列的元素复制给deque</td></tr><tr><td>swap()</td><td>两个deque交换数据</td></tr><tr><td>push_back()</td><td>在末尾插入一个元素</td></tr><tr><td>pop_back()</td><td>移除最后一个元素</td></tr><tr><td>push_front()</td><td>头部插入元素</td></tr><tr><td>pop_front()</td><td>移除第一个元素</td></tr><tr><td>insert()</td><td>在某个位置插入</td></tr><tr><td>emplace()</td><td>原地插入</td></tr><tr><td>emplace_front()</td><td>在初始位置原地插入</td></tr><tr><td>emplace_back()</td><td>在末尾原地插入</td></tr><tr><td>erase(pos)</td><td>移除pos位置上的元素</td></tr><tr><td>resize(num)</td><td>将元素数量改为num</td></tr><tr><td>clear()</td><td>移除所有元素，清空容器</td></tr></tbody></table><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    coll.assign(<span class="number">4</span>,<span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    coll.push_back(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    coll.push_front(<span class="string">&quot;test front&quot;</span>);</span><br><span class="line"></span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    coll.pop_front();</span><br><span class="line">    coll.pop_back();</span><br><span class="line">    coll.emplace_front(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    coll.emplace_back(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    coll.emplace(++coll.begin(),<span class="string">&quot;test string&quot;</span>);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------for ------each---------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    for_each(coll.begin(),coll.end(),[&amp;](<span class="built_in">string</span>&amp; str)&#123;str += <span class="string">&quot; hello&quot;</span>;&#125;);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size : &quot;</span> &lt;&lt; coll.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max size : &quot;</span> &lt;&lt; coll.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    coll.resize(<span class="number">5</span>);</span><br><span class="line">    copy(coll.begin(),coll.end(),ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>,<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;std::deque位于头文件&lt;deque&gt;容器deque和vector类似，它也采用动态数组来管理元素.&lt;/deque&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之list</title>
    <link href="http://example.com/jsblog/5b2fd095.html"/>
    <id>http://example.com/jsblog/5b2fd095.html</id>
    <published>2020-12-23T12:42:49.000Z</published>
    <updated>2020-12-23T12:58:40.389Z</updated>
    
    <content type="html"><![CDATA[<p>std::list定义于头文件<list>,std::list是支持常数时间从容器任何位置插入和移除元素的容器。<a id="more"></a>它实现为双向链表，list不支持快速随机访问。与实现为单向链表的std::forward_list相比，std::list提供双向迭代但在空间上效率稍低。</list></p><p>其成员类型有：</p><table><thead><tr><th>成员类型</th><th>定义</th></tr></thead><tbody><tr><td>value_type</td><td>T</td></tr><tr><td>allocator_type</td><td>Allocator</td></tr><tr><td>size_type</td><td>无符号整数类型（通常是 std::size_t ）</td></tr><tr><td>difference_type</td><td>有符号整数类型（通常是 std::ptrdiff_t ）</td></tr><tr><td>reference</td><td>Allocator::reference   (C++11 前)     value_type&amp;   (C++11 起)</td></tr><tr><td>const_reference</td><td>Allocator::const_reference   (C++11 前)     const value_type&amp;   (C++11 起)</td></tr><tr><td>pointer</td><td>Allocator::pointer   (C++11 前)     std::allocator_traits<Allocator>::pointer   (C++11 起)</Allocator></td></tr><tr><td>const_pointer</td><td>Allocator::const_pointer   (C++11 前)     std::allocator_traits<Allocator>::const_pointer   (C++11 起)</Allocator></td></tr><tr><td>iterator</td><td>遗留双向迭代器 (LegacyBidirectionalIterator)</td></tr><tr><td>const_iterator</td><td>常双向迭代器</td></tr><tr><td>reverse_iterator</td><td>std::reverse_iterator<iterator></iterator></td></tr><tr><td>const_reverse_iterator</td><td>std::reverse_iterator<const_iterator></const_iterator></td></tr></tbody></table><p>成员函数</p><p>构造函数：有默认构造函数，支持copy constructor, move constructor 和 列表初始化构造</p><p>析构函数：默认析构函数</p><p>迭代器相关的函数：(c 指const )</p><table><thead><tr><th>begin() cbegin()</th><th>指向起始的迭代器</th></tr></thead><tbody><tr><td>end() cend()</td><td>指向末尾的迭代器</td></tr><tr><td>rbegin() crbegin()</td><td>指向起始的逆向迭代器</td></tr><tr><td>rend() crend()</td><td>指向末尾的逆向迭代器</td></tr></tbody></table><p>容量大小相关的函数</p><table><thead><tr><th>empty()</th><th>容器是否为空即（begin() == end() ?）</th></tr></thead><tbody><tr><td>size()</td><td>返回元素的数量</td></tr><tr><td>max_size()</td><td>返回可容纳的最大元素数量</td></tr><tr><td>resize()</td><td>改变容器可容纳元素的数量</td></tr></tbody></table><p>元素访问</p><table><thead><tr><th>front()</th><th>访问第一个元素</th></tr></thead><tbody><tr><td>back()</td><td>访问最后一个元素</td></tr></tbody></table><p>容器操作：</p><table><thead><tr><th>push_front()</th><th>将元素添加到容器头部</th></tr></thead><tbody><tr><td>emplace_front()</td><td>在容器头部构造元素</td></tr><tr><td>pop_front()</td><td>删除第一个元素</td></tr><tr><td>push_back()</td><td>将元素添加到容器末尾</td></tr><tr><td>emplace_back()</td><td>在容器尾部构造元素</td></tr><tr><td>pop_back()</td><td>删除最后一个元素</td></tr><tr><td>emplace()</td><td>原位构造元素</td></tr><tr><td>insert()</td><td>插入元素</td></tr><tr><td>earse()</td><td>擦除元素</td></tr><tr><td>swap()</td><td>与另外一个list交换内容</td></tr><tr><td>clear()</td><td>清空元素</td></tr></tbody></table><p>list操作：</p><table><thead><tr><th>splice()</th><th>从另外一个list中移动元素</th></tr></thead><tbody><tr><td>remove() remove_if()</td><td>删除满足条件的元素</td></tr><tr><td>unique()</td><td>删除连续重复的元素</td></tr><tr><td>merge()</td><td>合并排好序的两个链表</td></tr><tr><td>sort()</td><td>对链表排序</td></tr></tbody></table><p>非成员函数</p><table><thead><tr><th>operator== operator!= (C++20 中移除) operator&lt; (C++20 中移除) operator&lt;= (C++20 中移除) operator&gt; (C++20 中移除) operator&gt;= (C++20 中移除) operator&lt;=&gt;(C++20)</th><th>按照字典顺序比较 list 中的值 (函数模板)</th></tr></thead><tbody><tr><td>std::swap(std::list)</td><td>特化 std::swap 算法 (函数模板)</td></tr><tr><td>erase(std::list)erase_if(std::list) (C++20)</td><td>擦除所有满足特定判别标准的元素 (函数模板)</td></tr></tbody></table><p>作为链表的实现，list拥有自己的sort函数，而不能使用std::sort函数进行排序。std::sort使用的随机访问来进行排序，而list和forward_list都是不支持随机访问的。</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li&#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; li2.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    li.swap(li2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li2 size : &quot;</span> &lt;&lt; li2.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li size : &quot;</span> &lt;&lt; li.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li max_size: &quot;</span> &lt;&lt; li.max_size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(li2.begin(),li2.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    li2.sort();</span><br><span class="line">    <span class="built_in">std</span>::for_each(li2.begin(),li2.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    li.splice(li.begin(),li2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li size : &quot;</span> &lt;&lt; li.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li max_size: &quot;</span> &lt;&lt; li.max_size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li2 size : &quot;</span> &lt;&lt; li2.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    li.pop_back();</span><br><span class="line">    li.pop_front();</span><br><span class="line">    li.push_back(<span class="number">100</span>);</span><br><span class="line">    li.push_front(<span class="number">200</span>);</span><br><span class="line">    li.emplace_back(<span class="number">1000</span>);</span><br><span class="line">    li.emplace_front(<span class="number">20</span>);</span><br><span class="line">    li.emplace(++li.begin(),<span class="number">1050</span>);</span><br><span class="line">    <span class="built_in">std</span>::for_each(li.begin(),li.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front : &quot;</span> &lt;&lt; li.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back : &quot;</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    li.insert(++li.begin(),<span class="number">2</span>);</span><br><span class="line">    li.insert(++li.begin(),<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::for_each(li.begin(),li.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    li2.push_front(<span class="number">10</span>);</span><br><span class="line">    li2.push_front(<span class="number">63</span>);</span><br><span class="line">    li.merge(li2);</span><br><span class="line">    <span class="built_in">std</span>::for_each(li.begin(),li.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;li2 size : &quot;</span> &lt;&lt; li2.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    li.unique();</span><br><span class="line">    li.remove(<span class="number">63</span>);</span><br><span class="line">    <span class="built_in">std</span>::for_each(li.begin(),li.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//去除偶数</span></span><br><span class="line">    li.remove_if([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::for_each(li.begin(),li.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    li.clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;std::list定义于头文件&lt;list&gt;,std::list是支持常数时间从容器任何位置插入和移除元素的容器。&lt;/list&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之vector</title>
    <link href="http://example.com/jsblog/a0f61940.html"/>
    <id>http://example.com/jsblog/a0f61940.html</id>
    <published>2020-12-23T12:42:07.000Z</published>
    <updated>2020-12-23T12:58:40.395Z</updated>
    
    <content type="html"><![CDATA[<p>std::vector是最为常用的容器，其定义在<vector>文件中，std::vector是封装动态数组的顺序容器。<a id="more"></a>vector的存储是自动管理的，按需扩张和收缩。vector通常占用对于静态数组的空间，因为要分配更多内存以管理增长。vector在额外内存耗尽的时进行重新分配，分配之后的内存大小可以使用capacity()函数查询，多余的内存可以通过shrink_to_fit()的调用还给系统。</vector></p><p>重分配通常是性能上有开销的操作。若元素数量已知，则 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve()</a> 函数可用于消除重分配。</p><p>vector 上的常见操作复杂度（效率）如下：</p><p>§ 随机访问——常数 <em>O(1)</em></p><p>§ 在末尾插入或移除元素——均摊常数 <em>O(1)</em></p><p>§ 插入或移除元素——与到 vector 结尾的距离成线性 <em>O(n)</em></p><p>在删除元素或者增加元素的时候都有可能使vector的迭代器无效，下表表示示可能导致vector迭代器失效 的操作，以及这些操作在什么情况下会使迭代器无效</p><table><thead><tr><th>操作</th><th>迭代器无效化</th></tr></thead><tbody><tr><td>所有只读操作</td><td>决不</td></tr><tr><td>swap 、 std::swap</td><td>end()</td></tr><tr><td>clear 、 operator= 、 assign</td><td>始终</td></tr><tr><td>reserve 、 shrink_to_fit</td><td>若 vector 更改容量，则为其全部。否则为无。</td></tr><tr><td>erase</td><td>被擦除元素及之后的所有元素（包括 end() ）。</td></tr><tr><td>push_back 、 emplace_back</td><td>若 vector 更改容量，则为其全部。否则仅 end() 。</td></tr><tr><td>insert, emplace</td><td>若 vector 更改容量，则为其全部。否则仅为在或于插入点后者（包括 end() ）。</td></tr><tr><td>resize</td><td>若 vector 更改容量，则为其全部。否则仅 end() 与被擦除元素。</td></tr><tr><td>pop_back</td><td>被擦除元素及 end() 。</td></tr></tbody></table><p><strong>vector中的成员类型有：</strong></p><table><thead><tr><th>成员类型</th><th>定义</th></tr></thead><tbody><tr><td>value_type</td><td>T</td></tr><tr><td>allocator_type</td><td>Allocator</td></tr><tr><td>size_type</td><td>无符号整数类型（通常是 std::size_t ）</td></tr><tr><td>difference_type</td><td>有符号整数类型（通常是 std::ptrdiff_t ）</td></tr><tr><td>reference</td><td>Allocator::reference   (C++11 前)     value_type&amp;   (C++11 起)</td></tr><tr><td>const_reference</td><td>Allocator::const_reference   (C++11 前)     const value_type&amp;   (C++11 起)</td></tr><tr><td>pointer</td><td>Allocator::pointer   (C++11 前)     std::allocator_traits<Allocator>::pointer   (C++11 起)</Allocator></td></tr><tr><td>const_pointer</td><td>Allocator::const_pointer   (C++11 前)     std::allocator_traits<Allocator>::const_pointer   (C++11 起)</Allocator></td></tr><tr><td>iterator</td><td>遗留随机访问迭代器 (LegacyRandomAccessIterator)</td></tr><tr><td>const_iterator</td><td>常随机访问迭代器</td></tr><tr><td>reverse_iterator</td><td>std::reverse_iterator<iterator></iterator></td></tr><tr><td>const_reverse_iterator</td><td>std::reverse_iterator<const_iterator></const_iterator></td></tr></tbody></table><p><strong>vector的member function:</strong></p><table><thead><tr><th>(构造函数)</th><th>构造 vector (公开成员函数)</th></tr></thead><tbody><tr><td>(析构函数)</td><td>析构 vector (公开成员函数)</td></tr><tr><td>operator=</td><td>赋值给容器 (公开成员函数)</td></tr><tr><td>assign</td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td>get_allocator</td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td>at</td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>operator[]</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td>front</td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td>back</td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>data</td><td>返回指向内存中数组第一个元素的指针 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td>begincbegin (C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td>endcend (C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td>rbegincrbegin (C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td>rendcrend (C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td>empty</td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td>size</td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td>max_size</td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>reserve</td><td>预留存储空间 (公开成员函数)</td></tr><tr><td>capacity</td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td>shrink_to_fit (C++11)</td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td>clear</td><td>清除内容 (公开成员函数)</td></tr><tr><td>insert</td><td>插入元素 (公开成员函数)</td></tr><tr><td>emplace (C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td>erase</td><td>擦除元素 (公开成员函数)</td></tr><tr><td>push_back</td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td>emplace_back (C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td>pop_back</td><td>移除末元素 (公开成员函数)</td></tr><tr><td>resize</td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td>swap</td><td>交换内容 (公开成员函数)</td></tr></tbody></table><p><strong>Non-member function:</strong></p><table><thead><tr><th>operator== operator!= (C++20 中移除) operator&lt;(C++20 中移除) operator&lt;=(C++20 中移除) operator&gt;(C++20 中移除) operator&gt;=(C++20 中移除) operator&lt;=&gt;(C++20)</th><th>按照字典顺序比较 vector 中的值 (函数模板)</th></tr></thead><tbody><tr><td>std::swap(std::vector)</td><td>特化 std::swap 算法 (函数模板)</td></tr><tr><td>erase(std::vector)erase_if(std::vector) (C++20)</td><td>擦除所有满足特定判别标准的元素 (函数模板)</td></tr></tbody></table><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//列表初始化</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="comment">//自动推导，c++17</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span> <span class="title">v2</span><span class="params">(v1.begin(),v1.end())</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::for_each(v2.begin(),v2.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  v2.emplace_back(<span class="number">10</span>);</span><br><span class="line">  v2.emplace_back(<span class="number">6</span>);</span><br><span class="line">  v2.emplace_back(<span class="number">13</span>);</span><br><span class="line">  v2.emplace_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span> <span class="title">v3</span><span class="params">(v2)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::sort(v2.begin(),v2.end());</span><br><span class="line">  <span class="built_in">std</span>::for_each(v2.begin(),v2.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity is : &quot;</span> &lt;&lt;v2.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size is : &quot;</span> &lt;&lt; v2.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//交互</span></span><br><span class="line">  v3.swap(v2);</span><br><span class="line">  <span class="built_in">std</span>::for_each(v3.begin(),v3.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::for_each(v2.begin(),v2.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="comment">//清除内容</span></span><br><span class="line">  v2.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity is : &quot;</span> &lt;&lt;v2.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size is : &quot;</span> &lt;&lt; v2.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//归还内存</span></span><br><span class="line">  v2.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity is : &quot;</span> &lt;&lt;v2.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size is : &quot;</span> &lt;&lt; v2.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;std::vector是最为常用的容器，其定义在&lt;vector&gt;文件中，std::vector是封装动态数组的顺序容器。&lt;/vector&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之Array</title>
    <link href="http://example.com/jsblog/f3dbd906.html"/>
    <id>http://example.com/jsblog/f3dbd906.html</id>
    <published>2020-12-23T12:41:31.000Z</published>
    <updated>2020-12-23T12:58:40.383Z</updated>
    
    <content type="html"><![CDATA[<p>std::array 定义于头文件<array>之中，std::array是一个封装固定大小数组的容器。<a id="more"></a></array></p><p>此容器是一个聚合类型，其语义等同于一个C风格的数组T[N]作为其唯一非静态数据成员的结构体，不同于C风格的数组，它不可以利用 指针直接存取数据即不能转化为T*,但是像其他容器一样，可以通过迭代器进行遍历。该结构体结合了 C 风格数组的性能、可访问性与容器的优点，比如可获取大小、支持赋值、随机访问迭代器等。当其长度为零时 <code>array</code> （ <code>N == 0</code> ）有特殊情况。此时， array.begin() == array.end() ，并拥有某个唯一值。在零长 <code>array</code> 上调用 front() 或 back() 是未定义的。</p><p><strong>其成员类型有</strong>：</p><table><thead><tr><th>成员类型</th><th>定义</th></tr></thead><tbody><tr><td>value_type</td><td>T</td></tr><tr><td>size_type</td><td>std::size_t</td></tr><tr><td>difference_type</td><td>std::ptrdiff_t</td></tr><tr><td>reference</td><td>value_type&amp;</td></tr><tr><td>const_reference</td><td>const value_type&amp;</td></tr><tr><td>pointer</td><td>value_type*</td></tr><tr><td>const_pointer</td><td>const value_type*</td></tr><tr><td>iterator</td><td>遗留随机访问迭代器 (LegacyRandomAccessIterator) 兼常量表达式迭代器 (ConstexprIterator) (C++20 起)且为字面类型 (LiteralType) (C++17 起)</td></tr><tr><td>const_iterator</td><td>常随机访问迭代器兼常量表达式迭代器 (ConstexprIterator) (C++20 起)且为字面类型 (LiteralType) (C++17 起)</td></tr><tr><td>reverse_iterator</td><td>std::reverse_iterator<iterator></iterator></td></tr><tr><td>const_reverse_iterator</td><td>std::reverse_iterator<const_iterator></const_iterator></td></tr></tbody></table><p><strong>member function有</strong>：</p><table><thead><tr><th>隐式定义的成员函数</th><th></th></tr></thead><tbody><tr><td>(构造函数) (隐式声明)</td><td>遵循聚合初始化的规则初始化 array （注意默认初始化可以导致非类的 T 的不确定值） (公开成员函数)</td></tr><tr><td>(析构函数) (隐式声明)</td><td>销毁 array 的每个元素 (公开成员函数)</td></tr><tr><td>operator= (隐式声明)</td><td>以来自另一 array 的每个元素重写 array 的对应元素 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td>at</td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>operator[]</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td>front</td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td>back</td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>data</td><td>返回指向内存中数组第一个元素的指针 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td>begin cbegin</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td>end cend</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td>rbegin crbegin</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td>rend crend</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td>empty</td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td>size</td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td>max_size</td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>操作</td><td></td></tr><tr><td>fill</td><td>以指定值填充容器 (公开成员函数)</td></tr><tr><td>swap</td><td>交换内容 (公开成员函数)</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,2&gt; a1&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> test= &#123;<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">4</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="comment">//遍历输出</span></span><br><span class="line">  <span class="built_in">std</span>::for_each(test.begin(),test.end(),[](<span class="keyword">int</span> x)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-----------after sort--------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::sort(test.begin(),test.end());</span><br><span class="line">  <span class="comment">//逆序输出</span></span><br><span class="line">  <span class="built_in">std</span>::reverse_copy(test.begin(),test.end(),<span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(test.begin(),test.end(),<span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="comment">// form zero to seven</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the second elem is : &quot;</span> &lt;&lt; test[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the second elem is : &quot;</span> &lt;&lt; test.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the last elem is : &quot;</span> &lt;&lt; test.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;std::array 定义于头文件&lt;array&gt;之中，std::array是一个封装固定大小数组的容器。&lt;/array&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C之读写文件</title>
    <link href="http://example.com/jsblog/c3a9a9f.html"/>
    <id>http://example.com/jsblog/c3a9a9f.html</id>
    <published>2020-12-23T12:39:43.000Z</published>
    <updated>2020-12-23T12:58:40.402Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看FFmpeg的有关知识，由于经常遇到文件读写，但是对于C语言的文件读写又有些忘记，于是便好好的记录一下C语言的文件读写，<a id="more"></a>同时也让自己能够不再对C语言的文件读写感到陌生（其实就是重新复习一下C语言相关的文件读写的相关的API）.</p><p>常用的文件读写函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> filename,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* <span class="keyword">restrict</span> stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* <span class="keyword">restrict</span> stream)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> filename,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> mode,FILE *<span class="keyword">restrict</span> stream)</span></span>;</span><br></pre></td></tr></table></figure><p>fopen()函数需要一个文件路径，和文件打开模式，常用的打开模式如下：</p><p><img src="https://pic3.zhimg.com/80/v2-c4773117934a3d2d75abd7b6bbcd1a12_720w.jpg" alt="img"></p><p>如果发生错误，会将错误码设置在erron变量，并返回一个NULL。</p><p>fclose()是关闭打开的文件指针，包括清空内部缓存数据，在关闭错误时返回EOF,否则返回0.</p><p>fflush()函数是刷新文件指针，清空与输出或更新数据流参数相关的任何缓冲区。如果发生错误函数返回EOF，否则返回0</p><p>freopen()是重新打开数据流，就像先调用fclose关闭文件，然后调用fopen打开文件，成功时返回输入数据流与输入的数据流相关，失败返回NULL.</p><p>文件定向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *<span class="keyword">restrict</span> stream,<span class="keyword">long</span> <span class="keyword">int</span> offset,<span class="keyword">int</span> wherefrom)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *<span class="keyword">restrict</span> stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *<span class="keyword">restrict</span> stream)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEEK_SET 0</span></span><br><span class="line"><span class="meta">#defube SEEK_CUR 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEEK_END 2</span></span><br></pre></td></tr></table></figure><p>fseek随机访问打开的stream,第二个参数是打开位置，wherefrom是定位方式，表示从文件哪个点开始测量offset，如果定位成功返回0，负责返回下一个非0值。然后清除任何文件结尾指示符。其中wherefrom的值以及含义如下：</p><p>SEEK_SET或0 距离文件开头offset个字符</p><p>SEEK_CUR或1 距离文件当前位置offset个字符</p><p>SEEK_END或2 距离文件末尾offset个字符</p><p>ftell函数对于二进制返回当前文件位置之前的字节数，如果失败返回-1.对于文本文件，返回的值是由实现定义的。</p><p>rewind函数则是将数据流复位到文件开头。调用rewind（stream）等价于：</p><p>fseek(stream,0,SEEK_SET);</p><p>读取文本文件的函数有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> n,FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> stream,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format,…)</span></span></span><br></pre></td></tr></table></figure><p>写入文本文件的函数有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c,FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c,FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> stream,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format,…)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> s,<span class="keyword">size_t</span> n,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format,…)</span></span>;</span><br></pre></td></tr></table></figure><p>读写二进制的函数有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr,<span class="keyword">size_t</span> element_size,<span class="keyword">size_t</span> count,FILE *<span class="keyword">restrict</span> stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">restrict</span> ptr,<span class="keyword">size_t</span> element_size,<span class="keyword">size_t</span> count,FILE *<span class="keyword">restrict</span> strean)</span></span>;</span><br></pre></td></tr></table></figure><p>fread和fwrite分别是输入和输出到二进制文件。stream是输入输出流ptr是指向count元素数组的指针，每个元素是element_size 字符长。fread返回实际读取的项目数，如遇到末尾，则这个数小于count,遇到错误返回0，使用feof或ferror判断是文件末尾还是错误，如果element_size和count为0，不传输数据。</p><p>重命名及文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname,<span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;</span><br></pre></td></tr></table></figure><p>两个函数操作成功均返回0，否则返回非0值</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在看FFmpeg的有关知识，由于经常遇到文件读写，但是对于C语言的文件读写又有些忘记，于是便好好的记录一下C语言的文件读写，&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++之nullptr</title>
    <link href="http://example.com/jsblog/1b4f334c.html"/>
    <id>http://example.com/jsblog/1b4f334c.html</id>
    <published>2020-12-23T12:39:06.000Z</published>
    <updated>2020-12-23T12:58:40.391Z</updated>
    
    <content type="html"><![CDATA[<p>nullptr 的类型为 nullptr_t,nullptr 可以隐式的转换成任何类型的指针.<a id="more"></a> NULL 和 （void*）0 以及nullptr的定义都不相同，所以尽可能使用nullptr。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *ch)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo(char *) is called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="keyword">void</span> *)<span class="number">0</span>)&gt;::value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == (void*)0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;::value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  foo(<span class="number">0</span>);</span><br><span class="line">  foo(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="keyword">int</span>) is called</span><br><span class="line">foo(<span class="keyword">char</span> *) is called</span><br></pre></td></tr></table></figure><p>其中 关键字**<em>decltype**</em>是用来自动推导表达式的数据类型，而<strong>std::is_same</strong>能够判断两种类型是否相同</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nullptr 的类型为 nullptr_t,nullptr 可以隐式的转换成任何类型的指针.&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
</feed>
