<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林森</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-22T14:17:58.725Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python创建线程</title>
    <link href="http://example.com/jsblog/a1d230f8.html"/>
    <id>http://example.com/jsblog/a1d230f8.html</id>
    <published>2020-12-22T13:33:18.000Z</published>
    <updated>2020-12-22T14:17:58.725Z</updated>
    
    <content type="html"><![CDATA[<p>线程是操作系统直接支持的执行单元。<a id="more"></a>Python的标准库提供了两个模块：_thread和threading。 _thread是低级模块而threading是高级模块，是对 _thread进行了封装。在绝大多数情况下，只使用threading模块。</p><p>threading模块提供了一个Thread类来代表一个线程对象，语法如下：</p><p>Thread([group[,target[,name[,args[,kwagrs]]]]])</p><p>参数说明：</p><p>group : 值为None,为以后版本保留。</p><p>target : 表示一个可调用对象，线程启动时，run()函数将调用此对象，默认值为None,表示不调用任何对象</p><p>name:当前线程的名称，默认创建一个Thread-N格式的唯一名称</p><p>args : 表示传递给target函数的参数元组</p><p>kwargs : 表示传递给target函数的参数字典</p><p>可以直接使用函数创建线程，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">&quot;thread name is %s&quot;</span>%threading.current_thread().name)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    threads = [threading.Thread(target=process) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure><p>也可以使用Thread子类创建下线程。对于子类来说最好重写run函数。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">&quot;thread name is %s&quot;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    print(<span class="string">&quot;-----------主线程开始----------&quot;</span>)</span><br><span class="line">    t1 = subThread()</span><br><span class="line">    t2 = subThread()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(<span class="string">&quot;-----------主线程结束----------&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线程是操作系统直接支持的执行单元。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Numpy数组运算</title>
    <link href="http://example.com/jsblog/1682de28.html"/>
    <id>http://example.com/jsblog/1682de28.html</id>
    <published>2020-12-22T12:27:35.000Z</published>
    <updated>2020-12-22T13:22:34.419Z</updated>
    
    <content type="html"><![CDATA[<p>数组之所以重要是因为可以进行批量操作而不需要使用任何形式的for循环。<a id="more"></a>NumPy这种特性称为向量化，任何两个相等尺寸的数组中都是用到了逐元素操作的方式。</p><p>带有标量计算的算术操作，会把计算参数传递给数组的每一个元素。同尺寸之间的比较会产生一个布尔值的数组，不同尺寸的数组间的操作，将会使用到广播特性。所谓广播就是NumPy对于不同尺寸数组进行数值运算的方式。广播的规则是如果对于每个结尾维度（即从尾部开始的），轴长度都匹配或者长度都为1,两个二维数据就是可以兼容广播的，之后，广播会在丢失的或长度为1的轴上进行。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(arr*arr)</span><br><span class="line">print(<span class="number">1</span>/arr)</span><br><span class="line">print(arr**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#广播</span></span><br><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(arr+arr1)</span><br><span class="line">print(arr== arr)</span><br></pre></td></tr></table></figure><p>NumPy中数组也支持切片操作，相当于选择数组中的一部分，不过数组的切片是原数组的视图，这意味着修改数据不是被复制了，而是对与原数组的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">arr2[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line">print(arr2)</span><br></pre></td></tr></table></figure><p>不写切片值的[:]将会操作整个数组，如果相要数组切片的copy而不是一份视图，应该显式的调用copy函数，进行切片的复制。如果要访问某个位置的元素对于高维数组可以传递多个索引，也可以使用索引的逗号分隔列表选择单个元素。当然对于多维数组而言，可以省略后续索引值，返回的对象僵尸降低一个维度的数组。需要注意的时候，返回的数组都是视图。（可以将0轴作为行，1轴作为列）如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr2 = np.array([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">arr_slice = arr2[<span class="number">5</span>:<span class="number">8</span>].copy()</span><br><span class="line">print(arr2)</span><br><span class="line">print(arr_slice)</span><br><span class="line">arr2d = np.array([[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">print(arr2d[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">print(arr2d[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">print(arr2d[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>切片方式也可以使用索引的形式，在索引与切片混合，可以得到低纬度的切片。注意单独的一个冒号表示选择整个轴上的数组。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">print(arr2d[:<span class="number">2</span>,<span class="number">1</span>:])</span><br><span class="line">print(arr2d[:,:<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>bool索引，在索引数组时可以传入布尔值数组，布尔值数组的长度必须和数组轴索引长度一致。~符号表示对一个通用操作表示取反。bool索引数组中为true的那一行数据会被复制，但是注意当bool数组的长度与索引长度不一致时，可能会到处一些问题。但不会报错。还有一点就是 and or对bool数组没有效果，但是可以使用&amp; 和 | 代替。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&quot;bob&quot;</span>,<span class="string">&#x27;joe&#x27;</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;lll&#x27;</span>])</span><br><span class="line">data = np.random.randn(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">print(data)</span><br><span class="line">print(names == <span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">print(data[names == <span class="string">&#x27;bob&#x27;</span>])</span><br></pre></td></tr></table></figure><p>神奇索引是NumPy中的术语，用于描述使用整数数组进行数据索引。为了选出一个符合特定顺序的子集，可以通过传递一个包含指明所需顺序的列表或数组完成。传递多维数组，会根据每个索引元组对应的元素选出一个一维数组。它是将数据复制，而不是使用视图。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape(<span class="number">8</span>,<span class="number">4</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(arr[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>数组的转职使用transpose()函数，或者直接使用属性T,计算矩阵的内积使用np.dot()函数，使用ndarray的swapaxes方法，可以重组数据,swapaxes返回的视图而不是copy。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line">print(arr)</span><br><span class="line">print(arr.T)</span><br><span class="line">print(np.dot(arr.T,arr))</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print(arr.transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)))</span><br><span class="line">print(arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组之所以重要是因为可以进行批量操作而不需要使用任何形式的for循环。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/jsblog/0.html"/>
    <id>http://example.com/jsblog/0.html</id>
    <published>2020-12-22T11:12:29.000Z</published>
    <updated>2020-12-22T12:24:41.563Z</updated>
    
    <content type="html"><![CDATA[<p>Mutex全名mutual exclusio，用来协助采取独占排他方式控制对资源的并发访问。<a id="more"></a>这里的资源指的是计算机中的内存，硬件等。为了实现独占资源，必须对相应的线程锁定mutex,这样可以防止其他线程也锁定mutex,知道锁定mutex的线程对mutex解除锁定（unlock)</p><p>在使用mutex/lock的时候，应该使用RAII守则即资源获取即初始化，在构造函数中获取资源，而在析构函数中释放资源。C++提供了std::lock_guard来帮助完成对mutex的自动加锁，以及自动解锁。也就是在这一线程任务完成的时候实现自动解锁。不使用std::lock_guard的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    ++data;</span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opdata</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    func(data)</span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在func中发生异常，有可能导致无法unlock，从而导致死锁。而使用lock_guard则不会出现由于func发生异常而导致死锁。使用lock_guard因为异常而自动析构并解锁。使用std::lock_guard的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    ++data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opdata</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    func(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的lock应该限制在最短周期内，因为它们会阻塞其他代码的运行机会。</p><p><strong>递归的lock(Recursive lock)</strong></p><p>有的时候递归锁定也是必要的，最典型的就是monitor，它们在每个public函数内放一个mutex并取得其lock,以防止data race。但是如果使用mutex锁上之后，再次使用mutex如果使用的顺序不当有可能引发死锁，但是使用recursive_mutex，则可以避免一些问题。这个mutex允许同一线程多次锁定，并在最近一次相应的unlock中释放mutex。代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBaseAccess</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; <span class="title">lg</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Elem <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; <span class="title">lg</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex _mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>try_lock 和 timed_mutex</strong></p><p>当程序想要获得一个lock但是如果不可能成功的话它不想阻塞，针对 这种情况，mutex成员函数提供try_lock()函数，它试图获取一个lock，成功就返回true，否则返回false，为了能够使用lock_guard（使作用域的任何出口都可以自动解锁），可以额外提供一个自适应的锁给构造函数，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">done</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m.try_lock() == <span class="literal">false</span>)&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(m,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了等待特定长度的时间，可以使用timed_mutex。c++提供了std::timed_mutex和std::recursive_timed_mutex允许使用try_lock_for()或者try_lock_until()，用来等待某个时间段，或者到达某个时间点。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">done</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在3秒内试图去获取锁</span></span><br><span class="line">    <span class="keyword">while</span>(m.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>)))&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(m,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然对于某些情况可以获取多个锁i，主要是为了传送数据，从一个受保护资源到另外一个。可以直接使用是std::lock()函数进行锁定，但是有可能导致死锁，或者有可能只取到第一个lock而无法取到第二个lock。std::lock()函数会锁定它收到的所有的mutex,而且阻塞直到所有的mutex被锁或发生异常。成功锁定之后应该使用lock_guard并指定第二参数std::adopt_lock,保证在退出作用域时都能被解锁。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m1;</span><br><span class="line"><span class="built_in">std</span>::mutex m2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoThins</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock(m1,m2);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg1</span><span class="params">(m1,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg2</span><span class="params">(m2,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用try_lock()函数，尝试获取多个锁，如果能够取到所有lock的话，该函数会返回-1，否则返回第一个失败的lock索引（从0开始），如果全部成功的话，这些锁会被解锁。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m1;</span><br><span class="line"><span class="built_in">std</span>::mutex m2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoThins</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="built_in">std</span>::try_lock(m1,m2);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg1</span><span class="params">(m1, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg2</span><span class="params">(m2, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unique_lock</strong></p><p>unique_lock对于mutex更有弹性，接口与lock_guard的接口一样，但又允许明确写出何时以及如何锁定或解锁mutex,对于unique_lock可以调用owns_lock()或bool()来查询其mutex是否被锁定，如果析构时mutex被锁定，其析构函数会自动调用unlock(),如果mutex没有被锁定，则析构函数什么也不做。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试图获取锁，但不阻塞</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">ul</span><span class="params">(m,<span class="built_in">std</span>::try_to_lock)</span></span>;</span><br><span class="line"><span class="comment">//给定一个时间段或时间点，在这个时间周期内获取锁</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::timed_mutex&gt; <span class="title">ult</span><span class="params">(tm,<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>))</span></span>; </span><br><span class="line"><span class="comment">//使用 defer_lock表示初始化lock 但是不锁mutex</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">uld</span><span class="params">(m,<span class="built_in">std</span>::defer_lock)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mutex全名mutual exclusio，用来协助采取独占排他方式控制对资源的并发访问。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Numpy之dtype</title>
    <link href="http://example.com/jsblog/c2d79a1f.html"/>
    <id>http://example.com/jsblog/c2d79a1f.html</id>
    <published>2020-12-21T14:04:19.000Z</published>
    <updated>2020-12-21T14:24:38.381Z</updated>
    
    <content type="html"><![CDATA[<p>ndarray的数据类型即dtype是一个特殊的对象.<a id="more"></a>它包含了ndarray需要为某一种类型数据所声明的内存块信息(也就是元数据，表示数据的数据)。</p><p>dtype是NumPy能够与其它系统数据灵活交互的原因。通常，数据的dtype通常按照一个命名方式：类型名，比如float和int，后面再接上表面每个元素位数的数字，一个标准的双精度浮点数，使用8byte即64bit。因此在NumPy为float64.一般只有在内存或者磁盘上做更深入的存取操作时，才需要了解存储的数据类型。</p><p>NumPy的数据类型如下：</p><table><thead><tr><th>类型</th><th>类型代码</th><th>含义</th></tr></thead><tbody><tr><td>int8,uint8</td><td>i1,u1</td><td>有符号和无符号8bit整数</td></tr><tr><td>int16,uint16</td><td>i2,u2</td><td>有符号和无符号16bit整数</td></tr><tr><td>int32,uint32</td><td>i4,u4</td><td>有符号和无符号32bit整数</td></tr><tr><td>int64,uint64</td><td>i8,u8</td><td>有符号和无符号64bit整数</td></tr><tr><td>float16</td><td>f2</td><td>半精度浮点数</td></tr><tr><td>float32</td><td>f4或f</td><td>单精度浮点数，兼容C语言float类型</td></tr><tr><td>float64</td><td>f8或d</td><td>双精度浮点数兼容C语言float类型和Python double</td></tr><tr><td>float128</td><td>f16或g</td><td>拓展精度浮点数</td></tr><tr><td>complex64</td><td>c8</td><td>基于32bit浮点数的复数</td></tr><tr><td>comple128</td><td>c16</td><td>基于64bit浮点数的复数</td></tr><tr><td>complex256</td><td>c32</td><td>基于128bit浮点数的复数</td></tr><tr><td>bool</td><td>?</td><td>布尔值，True or False</td></tr><tr><td>object</td><td>o</td><td>Python object类型</td></tr><tr><td>string_</td><td>S</td><td>修正的ASCII字符串类型</td></tr><tr><td>unicode_</td><td>U</td><td>修正的Unicode类型，生成一个长度为10的unicode类型，使用 “U10”</td></tr></tbody></table><p>可以使用astype方法显示的转换数组的数据类型。如果数组 中的元素都是表达数字含义的字符串，也可以使用astype将字符串转换为数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">print(arr.dtype)</span><br><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">print(float_arr.dtype)</span><br><span class="line">num_strs = np.array([<span class="string">&#x27;1.2&#x27;</span>,<span class="string">&quot;3.2&quot;</span>,<span class="string">&#x27;4.5&#x27;</span>,<span class="string">&#x27;6.8&#x27;</span>,<span class="string">&#x27;42&#x27;</span>],dtype=np.string_)</span><br><span class="line">print(num_strs.astype(np.float64))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;ndarray的数据类型即dtype是一个特殊的对象.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之Pool</title>
    <link href="http://example.com/jsblog/5796cb01.html"/>
    <id>http://example.com/jsblog/5796cb01.html</id>
    <published>2020-12-21T12:46:06.000Z</published>
    <updated>2020-12-21T14:24:38.382Z</updated>
    
    <content type="html"><![CDATA[<p>上一次学到了如何使用multithreading中的Process创建多个进程，<a id="more"></a>现在来看一下如何使用multithreading模块中的Pool类即Pool进程池创建进程。</p><p>首先来看一下Pool类的常用方法：</p><p>apply_async(func[,args[,kwds]]):使用非阻塞方式调用func，并行执行，args为传递给func的函数，kwds表示传递给func的关键字参数列表。</p><p>apply(func[,args[,kwds]]) : 使用阻塞方式调用func</p><p>close() : 关闭Pool，使其不再接受新的任务</p><p>terminate() : 不管任务是否完成，立即终止</p><p>join() : 主进程阻塞，等待子进程的推出，必须在close()或者terminate之后使用</p><p>所谓的阻塞就是指必须在某一任务完成之后才能继续执行这一任务，也就是I/O事件导致线程挂起，需要等待I/O事件完成之后才能进行任务调度来执行这个任务。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;子进程 %s 执行 %s&quot;</span>%(os.getpid(),name))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    print(<span class="string">&quot;父进程：%s&quot;</span>%os.getppid())</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):          <span class="comment">#创建子进程</span></span><br><span class="line">        p.apply_async(task,args=(i,))</span><br><span class="line">    print(<span class="string">&quot;等待子进程结束...&quot;</span>)</span><br><span class="line">    p.close() <span class="comment">#关闭进程池</span></span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">&quot;所有子进程结束&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在某些程序中需要进程之间的相互通信，那么如何才能实现进程间的相互通信呢？</p><p>Python中multiprocessing模块包装了底层的机制，提供了Queue、Pipes管道等多种方式来交换数据。队列是一种数据结构，先进先出的数据结构。进程之间有时需要通信，操作系统提供了很多机制实现进程间的通信，可以使用multiprocessing模块的Queue实现多进程之间的数据结构。</p><p>Queue对象常用的函数如下：</p><p>Queue.qsize() :返回当前队列包含的消息数量</p><p>Queue.empty() : 如果队列为空，返回True，反之返回False</p><p>Queue.full() :如果队列满了True否则返回False</p><p>Queue.get([block[,timeout]]): 获取队列中的消息，然后将其从队列中移除，block默认值为True.如果block使用默认值，且没有设置timeout,消息队列为空则会被阻塞，直到从消息队列中读到消息位置，如果设置了timeout，就会等待timeout秒，若还为空则会抛出Queue.Empty异常;如果block为False,消息队列为空则立刻抛出Queue.Empty</p><p>Queue.get_nowait() :相当于Queue.get(False)</p><p>Queue.put(item,[block[,timeout]]):将item消息写入队列，block默认为True;如果block使用默认值，且没有设置timeout,消息无法写入则会被阻塞，直到从消息队列中有空间写入，如果设置了timeout，就会等待timeout秒，若还没有空间则会抛出Queue.Full异常;如果block为False,消息队列为空则立刻抛出Queue.Full异常</p><p>Queue.put_nowait(item) : 相当于Queue.put(item,False)</p><p>下面是一个利用multiprocessing.Process可以创建多进程，使用multiprocessing.Queue可以实现队列的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#向队列中写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_task</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q.full():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            message = <span class="string">&quot;message : &quot;</span> + str(i)</span><br><span class="line">            q.put(message)</span><br><span class="line">            print(<span class="string">&quot;写入：%s&quot;</span>%message)</span><br><span class="line"><span class="comment">#读取队列中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_task</span>(<span class="params">q</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        print(<span class="string">&quot;读取： %s&quot;</span>%q.get(<span class="literal">True</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    q = Queue() <span class="comment">#创建队列</span></span><br><span class="line">    pw = Process(target=write_task,args=(q,)) <span class="comment">#写入数据进程</span></span><br><span class="line">    pr = Process(target=read_task,args=(q,)) <span class="comment">#读取数据进程</span></span><br><span class="line">    pw.start()  <span class="comment">#启动写入进程</span></span><br><span class="line">    pr.start() <span class="comment">#启动读取进程</span></span><br><span class="line">    pw.join() <span class="comment">#等待pw结束</span></span><br><span class="line">    pr.join() <span class="comment">#等pr结束</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一次学到了如何使用multithreading中的Process创建多个进程，&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>并发问题</title>
    <link href="http://example.com/jsblog/84c7d6fb.html"/>
    <id>http://example.com/jsblog/84c7d6fb.html</id>
    <published>2020-12-21T11:38:24.000Z</published>
    <updated>2020-12-21T12:33:14.958Z</updated>
    
    <content type="html"><![CDATA[<p>使用多线程总会伴随 数据的并发访问。<a id="more"></a>多个线程彼此毫无关系地运行几乎是很罕见的。线程可能提供数据给其他线程处理，或是准备好必要的先决条件用以启动其他线程。当多个线程同时运行的时候一定要注意当多个线程并发处理相同的数据而不同步化，那么唯一安全的情况就是所有线程只读取数据而不修改数据。</p><p>所谓相同的数据是使用相同的内存区，如果在不同的内存区那么就不会引发数据竞争的问题，读写也就不会出问题。在C++11中定义的数据竞争是指不同线程中的两个互相冲突的动作，其中至少一个动作不是atomic，而且无一个动作发生在另外一个动作之前。Data race会导致程序不可预期的行为。使用多线程的时候要特别注意平台相关性。</p><p>在什么情况下会出现问题呢？</p><p>1.未同步化的数据访问 ：并行运行的两个线程渡河写同一个数据，不知道哪条语句先执行</p><p>2.写一半的数据：某个线程正在读数据，另一个线程改动它，于是读取数据的线程可能只读一半</p><p>3.重新安装的语句： 语句和操作可能被重新安排次序，也许对每个单一线程正确，但是多线程的组合就破坏了预期的行为。</p><p><strong>Unsynchronized data Access(未同步化的数据访问)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!v.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>如果此段代码被多个线程共享，那么有可能在调用if非空后成功，而其他线程操作之后将v中元素清空，那么此段函数导致不可预期的行为。</p><p>注意：C++标准库提供的函数不支持“写或读”动作与另外一个”写“动作（同一个数据）并发执行。但是并发处理同意容器内的不同元素是可以的（除vector<bool>外）不同的线程可以并发读写同一容器内的元素。并发处理string stream,file stream,或stream buffer会导致不可预期的行为。</bool></p><p><strong>Half-Written Data(写到一半的数据)</strong></p><p>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>某个线程写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>某个线程读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br></pre></td></tr></table></figure><p>程序的输出可能有以下情况：</p><p>x = 0 ： 如果在第一线程执行之前</p><p>x=-1 ： 如果写入线程已完成</p><p>任何其他值： 如果 读取线程在写入线程中进行读取。</p><p><strong>Reordered Statement(重排语句)</strong></p><p>假设有两个变量，一个是bool readyFlag,另外一个是int data。在一个线程中表示提供数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">bool</span> readFlag = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p> 在生成者线程中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">100</span>;</span><br><span class="line">readFlag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>消费者线程中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!readFlag)&#123;&#125;</span><br><span class="line">foo(data);</span><br></pre></td></tr></table></figure><p>一般而言是先执行生成者线程产生数据，然后执行消费者线程处理数据。但是编译器或者硬件可能重排语句指令,从而在生成者为完成数据产生之前调用foo(data)语句，而不是执行while循环，对于单一线程则不会出席这种问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(data);</span><br><span class="line"><span class="keyword">while</span>(!readFlag)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这就有可能造成不可预期的行为。</p><p><strong>如何解决？</strong></p><p>首先要保证代码的原子性（atomicity），即不可分割性，同时也要保证具体指定语句的次序(Order)。</p><p>1.使用future和promise，它们都保证atomicity和order,这就意味着不会同时发生读和写</p><p>2.使用mutex和lock来处理critical section和protected zone。获得锁即保证只有一方可以读或者写。但是如果锁使用的不当，会造成死锁。</p><p>3.可以使用condition_variable，有效的令某线程等待若干“被另外一个线程控制的判断式”为true。有利于处理多线程直接的次序关系。</p><p>4.可以使用atomic data type确保每次对便利或对象的访问操作都是不可分割的。</p><p>5.可以使用atomic data type的底层接口，允许放宽atomic语句的次序或针对内存访问使用manual barrier或fence.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用多线程总会伴随 数据的并发访问。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程</title>
    <link href="http://example.com/jsblog/f4423a86.html"/>
    <id>http://example.com/jsblog/f4423a86.html</id>
    <published>2020-12-20T11:38:33.000Z</published>
    <updated>2020-12-20T13:31:43.015Z</updated>
    
    <content type="html"><![CDATA[<p>进程：计算机中已运行程序的实体，进程是一个动态的概念，同时进程还是计算机中资源分配的最小单位。<a id="more"></a></p><p>线程：线程是cpu调度的基本单位，一个进程可以拥有多个线程。一个线程只属于一个进程。</p><p>在Python中有多个模块可以创建进程，比较常用的有os.fork(),multiprocessing模块和Pool进程池。os.fork()只适用于Unix/linux/MacOs中，在windows不能使用。</p><p>使用multiprocessing模块创建进程需要使用到Process类来生成一个进程对象。Process的构造函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process([group[,target[,name[,args[,kwargs]]]]])</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group : 参数未使用，始终未<span class="literal">None</span></span><br><span class="line">target : 可调用对象，表示要执行的任务</span><br><span class="line">name: 当前进程的别名</span><br><span class="line">args: 表示传递给target的参数</span><br><span class="line">kwargs:表示传递给target函数的参数字典</span><br></pre></td></tr></table></figure><p>Process类常用的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is_alive() : 判断进程实例是否还在执行</span><br><span class="line">join([timeout]) : 是否等待进程实例结束，或等待多少秒</span><br><span class="line">start() : 启动进程(创建子进程)</span><br><span class="line">run()： 如果没有给定target参数，调用start函数时，就执行对象的run函数</span><br><span class="line">terminate(): 立即终止任务，不管任务是否完成</span><br></pre></td></tr></table></figure><p>Process常用属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: 当前进程的别名</span><br><span class="line">pid ：进程实例的ID</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_process</span>(<span class="params">interval</span>):</span></span><br><span class="line">    print(<span class="string">&quot;子进程 %s 开始执行，父进程为 %s&quot;</span>%(os.getpid(),os.getppid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;子进程 %s 执行时间为 %s&quot;</span>%(os.getpid(),(end-start)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p1 = Process(target=child_process,args=(<span class="number">2</span>,))</span><br><span class="line">    p2 = Process(target=child_process,name=<span class="string">&quot;ss&quot;</span>,args=(<span class="number">3</span>,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">&quot;p1 is alive = %s&quot;</span>%p1.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p2 is alive = %s&quot;</span> % p2.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p1 name is %s&quot;</span> % p1.name)</span><br><span class="line">    print(<span class="string">&quot;p1 pid is %s&quot;</span> % p1.pid)</span><br><span class="line">    print(<span class="string">&quot;p2 name is  %s&quot;</span> % p2.name)</span><br><span class="line">    print(<span class="string">&quot;p2 pid is %s&quot;</span> % p2.pid)</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(<span class="string">&quot;父进程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>也可以使用Process子类创建进程，不过要注意的是最好重写一下run函数，可以完成不同的任务，不重写run函数则会调用Process中的默认的run函数。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">rom multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,interval,name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        super(SubProcess,self).__init__() <span class="comment">#不调用父类的构造函数数，process的构造函数会被覆盖出现问题</span></span><br><span class="line">        self.interval = interval</span><br><span class="line">        <span class="keyword">if</span> name:</span><br><span class="line">            self.name = name</span><br><span class="line">    <span class="comment">#override the run function</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;子进程 %s 开始执行，父进程为 %s&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&quot;子进程 %s 执行时间为 %s&quot;</span> % (os.getpid(), (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p1 = SubProcess(<span class="number">2</span>,<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    p2 = SubProcess(<span class="number">3</span>,<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">    <span class="comment">#默认执行run 函数</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">&quot;p1 is alive = %s&quot;</span> % p1.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p2 is alive = %s&quot;</span> % p2.is_alive())</span><br><span class="line">    print(<span class="string">&quot;p1 name is %s&quot;</span> % p1.name)</span><br><span class="line">    print(<span class="string">&quot;p1 pid is %s&quot;</span> % p1.pid)</span><br><span class="line">    print(<span class="string">&quot;p2 name is  %s&quot;</span> % p2.name)</span><br><span class="line">    print(<span class="string">&quot;p2 pid is %s&quot;</span> % p2.pid)</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(<span class="string">&quot;父进程执行结束&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure><p>因为没有指定target参数，所以start函数默认会执行run函数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程：计算机中已运行程序的实体，进程是一个动态的概念，同时进程还是计算机中资源分配的最小单位。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式标志</title>
    <link href="http://example.com/jsblog/cf32e656.html"/>
    <id>http://example.com/jsblog/cf32e656.html</id>
    <published>2020-12-20T11:13:30.000Z</published>
    <updated>2020-12-20T11:14:22.337Z</updated>
    
    <content type="html"><![CDATA[<p>regex flag位于regex_constants内<a id="more"></a>，原则上他们总是可以被传入regex构造函数或regex的各个函数中，作为可有可无的最后一个实参。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> data = <span class="string">&quot;Google@gmail.com,Llll@qq.com,other@sina.com&quot;</span>;</span><br><span class="line">  <span class="comment">//匹配邮箱</span></span><br><span class="line">  <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">&quot;([a-z0-9]*@[a-z]*\\.[a-z]&#123;2,3&#125;)+&quot;</span>,regex_constants::icase)</span></span>;</span><br><span class="line">  <span class="function">sregex_iterator <span class="title">pos</span><span class="params">(data.begin(),data.end(),re)</span></span>;</span><br><span class="line">  sregex_iterator end;</span><br><span class="line">  <span class="keyword">for</span>(; pos != end;++pos)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下表是flag及其含义：</p><table><thead><tr><th>Regex_constants</th><th>意义</th></tr></thead><tbody><tr><td>ECMAScript</td><td>使用ecmascript文法，默认</td></tr><tr><td>basic</td><td>使用posix的basic regular expression 文法</td></tr><tr><td>extended</td><td>使用posix的extended regular expression文法</td></tr><tr><td>awk</td><td>使用unix工具awk的文法</td></tr><tr><td>grep</td><td>使用unix工具grep的文法</td></tr><tr><td>egrep</td><td>使用unix工具egrep的文法</td></tr><tr><td>icase</td><td>忽略大小写</td></tr><tr><td>nosubs</td><td>不将子序列存储于匹配结果内</td></tr><tr><td>optimize</td><td>优化matching速度，然后才考虑regex的创建速度</td></tr><tr><td>collate</td><td>形式[a-b]的字符区间会受locale影响</td></tr><tr><td>match_not_null</td><td>不匹配空序列</td></tr><tr><td>match_not_bol</td><td>第一位置不匹配</td></tr><tr><td>match_not_eol</td><td>最末字符不匹配</td></tr><tr><td>match_not_bow</td><td>第一字符不匹配</td></tr><tr><td>match_not_eow</td><td>最末字符不匹配</td></tr><tr><td>match_continuous</td><td>只试图匹配“从第一字符开始”的子序列</td></tr><tr><td>match_any</td><td>如果多于一个匹配，任何匹配都可以接受</td></tr><tr><td>match_prev_avail</td><td>第一个字符的前一位置是个有效位置</td></tr><tr><td>format_default</td><td>使用默认的ECMAScript替换语法</td></tr><tr><td>format_sed</td><td>使用Unix工具sed的替换语法</td></tr><tr><td>format_first_only</td><td>只替换第一个匹配</td></tr><tr><td>format_no_copy</td><td>对于未获匹配的字符不复制</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;regex flag位于regex_constants内&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式替换</title>
    <link href="http://example.com/jsblog/95d99184.html"/>
    <id>http://example.com/jsblog/95d99184.html</id>
    <published>2020-12-20T11:11:55.000Z</published>
    <updated>2020-12-20T11:14:22.336Z</updated>
    
    <content type="html"><![CDATA[<p>许多文本编辑器都提供了查找和替换功能，同时也支持正则表达式的替换。<a id="more"></a>首先是找到匹配的正则表达式，然后将符合正则表达式的字符序列替换为另一个字符序列。来看一下下面的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> data = <span class="string">&quot;&lt;person&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&lt;first&gt;Nano&lt;/first&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&lt;second&gt;Nike&lt;/second&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&lt;/person&gt;\n&quot;</span>;</span><br><span class="line">  <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; regex_replace(data,re,<span class="string">&quot;&lt;$1 value=\&quot;$2\&quot;/&gt;&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; regex_replace(data,re,<span class="string">&quot;&lt;\\1 value= \&quot;\\2\&quot;/&gt;&quot;</span>,regex_constants::format_sed) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> res2;</span><br><span class="line">  regex_replace(back_inserter(res2),data.begin(),data.end(),re,<span class="string">&quot;&lt;$&#x27; value=\&quot;$2\&quot;/&gt;&quot;</span>,regex_constants::format_no_copy | regex_constants::format_first_only);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配一个XML-tagged value,将其中的值添加到标签中的属性，从而实现替换效果。为了达到替换效果需要指定替换的位置，本例子中使用$1和$2代替替换过程中找的到的tag和value。下表是一个替换的说明：</p><table><thead><tr><th>默认的pattern</th><th>Unix Sed pattern</th><th>意义</th></tr></thead><tbody><tr><td>$&amp;</td><td>&amp;</td><td>Matched pattern</td></tr><tr><td>$n</td><td>\n</td><td>第n个matched capture group</td></tr><tr><td>$`</td><td></td><td>Matched pattern 的前缀</td></tr><tr><td>$’</td><td></td><td>Matched pattern 的后缀</td></tr><tr><td>$$</td><td></td><td>字符$</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;许多文本编辑器都提供了查找和替换功能，同时也支持正则表达式的替换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式词法迭代器</title>
    <link href="http://example.com/jsblog/4f8ac9ef.html"/>
    <id>http://example.com/jsblog/4f8ac9ef.html</id>
    <published>2020-12-20T11:11:05.000Z</published>
    <updated>2020-12-20T11:14:22.338Z</updated>
    
    <content type="html"><![CDATA[<p>regex iterator有助于迭代“匹配合格”之子序列，当你打算将string拆分为一个个语法单元（token）或以某种内容分割string，分隔符甚至可能被指定为一个正则表达式。<a id="more"></a>regex_token_iterator就提供了这样的功能。将它初始化，需要把字符序列的起点和终点，以及一个正则表达式传递给这个迭代器，同时还要指定整数表示语法化过程中的元素：</p><p>-1 ： 表示对分隔符之间的子序列感兴趣</p><p>0 ： 表示你对每一个正则表达式或分隔符感兴趣</p><p>其他表示你对正则表达式中第n个匹配次表达式感兴趣。</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> data = <span class="string">&quot;&lt;person&gt;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;&lt;first&gt;Nano&lt;/first&gt;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;&lt;second&gt;Nike&lt;/second&gt;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;&lt;/person&gt;\n&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">sregex_token_iterator <span class="title">spos</span><span class="params">(data.begin(),data.end(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                        reg,     <span class="comment">// regex</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            &#123;<span class="number">0</span>,<span class="number">2</span>&#125;)</span></span>; <span class="comment">// 0: full match 2:second substring</span></span><br><span class="line">    sregex_token_iterator end;</span><br><span class="line">    <span class="keyword">for</span>(;spos != end;++spos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;match: &quot;</span> &lt;&lt; spos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> names = <span class="string">&quot;nico,jim,helmut,paul,tim,john,paul,rita&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">sep</span><span class="params">(<span class="string">&quot;[ \t\n]*[,;:][ \t\n]*&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">sregex_token_iterator <span class="title">stpos</span><span class="params">(names.begin(),names.end(),sep,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    sregex_token_iterator e;</span><br><span class="line">    <span class="keyword">for</span>(;stpos!=e;++stpos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;names : &quot;</span> &lt;&lt; stpos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;regex iterator有助于迭代“匹配合格”之子序列，当你打算将string拆分为一个个语法单元（token）或以某种内容分割string，分隔符甚至可能被指定为一个正则表达式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式迭代器</title>
    <link href="http://example.com/jsblog/c72502a3.html"/>
    <id>http://example.com/jsblog/c72502a3.html</id>
    <published>2020-12-20T11:10:13.000Z</published>
    <updated>2020-12-20T11:14:22.339Z</updated>
    
    <content type="html"><![CDATA[<p>为了访问正则表达式的匹配结果，使用regex iterator。<a id="more"></a>这些iterator的类型是regex_iterator&lt;&gt;,有针对string和字符序列而预先定义的实例化实现，分别有sregex_iterator,wsregex_iterator,cregex_iterator和wcregex_itreator。如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>  data = <span class="string">&quot;&lt;person&gt;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;first&gt;Nano&lt;/first&gt;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;second&gt;Nike&lt;/second&gt;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;&lt;/person&gt;\n&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate over all matches</span></span><br><span class="line">    <span class="function">sregex_iterator <span class="title">pos</span><span class="params">(data.begin(),data.end(),reg)</span></span>;</span><br><span class="line">    sregex_iterator  end;</span><br><span class="line">    <span class="keyword">auto</span> func = [](<span class="keyword">const</span> sregex_iterator&amp; pos)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; match: &quot;</span> &lt;&lt; pos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tag: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;pos != end;++pos)&#123;</span><br><span class="line">        func(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use a regex_iterator to process each matched substring</span></span><br><span class="line">    <span class="function">sregex_iterator <span class="title">beg</span><span class="params">(data.begin(),data.end(),reg)</span></span>;</span><br><span class="line">    for_each(beg,end,[](<span class="keyword">const</span> smatch&amp; pos)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; match: &quot;</span> &lt;&lt; pos.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tag: &quot;</span> &lt;&lt; pos.str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; pos.str(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了访问正则表达式的匹配结果，使用regex iterator。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式文法</title>
    <link href="http://example.com/jsblog/a1ae3b09.html"/>
    <id>http://example.com/jsblog/a1ae3b09.html</id>
    <published>2020-12-20T11:07:04.000Z</published>
    <updated>2020-12-20T11:14:22.334Z</updated>
    
    <content type="html"><![CDATA[<p>好久之前就想学一下正则表达式，<a id="more"></a>虽然之前有过使用python写爬虫使用正则表达式的经历，但工作中不是使用的python,所以就忘记了好多正则表达式，现在回想起来还是需要看一下的毕竟正则表达式是那么的强大，那么的好用。首先来看一些特殊的表达式以及它们的意义：</p><table><thead><tr><th>表达式</th><th>意义</th></tr></thead><tbody><tr><td>.</td><td>‘\n’以外所有的字符</td></tr><tr><td>[…]</td><td>…字符中任何一个</td></tr><tr><td>[^…]</td><td>非…字符中的任意一个</td></tr><tr><td>[[:charclass:]]</td><td>指定字符类charclass中的一个（见下表）</td></tr><tr><td>\n,\t,\f,\r,\v</td><td>一个newline,tabulator,form feed,carriage return或vertical tab</td></tr><tr><td>\xhh,\uhhh</td><td>一个十六进制字符或Unicode字符</td></tr><tr><td>\d,\D,\s,\S,\w,\W</td><td>某字符类内的一个字符shortcut（见下表）</td></tr><tr><td>*</td><td>前一个字符或者group，任意次数</td></tr><tr><td>?</td><td>前一个字符或者group，可有可无</td></tr><tr><td>+</td><td>前一个字符或者group,至少一次</td></tr><tr><td>{n}</td><td>前一个字符或者group, n次</td></tr><tr><td>{m,n}</td><td>前一个字符或者group,至少m次,最多n次</td></tr><tr><td>…|…</td><td>在 | 之前或者之后的pattern</td></tr><tr><td>(…)</td><td>设定分组</td></tr><tr><td>\1,\2,\3,…</td><td>第n个 group</td></tr><tr><td>\b</td><td>一个正字词的边界</td></tr><tr><td>\B</td><td>一个负字词的边界</td></tr><tr><td>^</td><td>一行的起点</td></tr><tr><td>$</td><td>一行的终点</td></tr></tbody></table><p>下表是正则表达式中的字符类：</p><table><thead><tr><th>字符类</th><th>缩写</th><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>[[:alnum:]]</td><td></td><td></td><td>一个字母或者数字</td></tr><tr><td>[[:alpha:]]</td><td></td><td></td><td>一个字母</td></tr><tr><td>[[:blank:]]</td><td></td><td></td><td>一个space或tab</td></tr><tr><td>[[:cntrl:]]</td><td></td><td></td><td>一个控制字符</td></tr><tr><td>[[:digit:]]</td><td>[[:d:]]</td><td>\d</td><td>一个数字</td></tr><tr><td></td><td></td><td>\D</td><td>一个非数字</td></tr><tr><td>[[:graph:]]</td><td></td><td></td><td>可打印非空白字符</td></tr><tr><td>[[:lower:]]</td><td></td><td></td><td>小写数字</td></tr><tr><td>[[:print:]]</td><td></td><td></td><td>可打印字符包括空白字符</td></tr><tr><td>[[:punct:]]</td><td></td><td></td><td>一个标点符合字符</td></tr><tr><td>[[:space:]]</td><td>[[:s:]]</td><td>\s</td><td>一个空白字符</td></tr><tr><td></td><td></td><td>\S</td><td>一个非空白字符</td></tr><tr><td>[[:upper:]]</td><td></td><td></td><td>一个大写字母</td></tr><tr><td>[[:xdigit:]]</td><td></td><td></td><td>一个十六进制数字</td></tr><tr><td></td><td>[[:w:]]</td><td>\w</td><td>一个字母、数字或者下划线</td></tr><tr><td></td><td></td><td>\W</td><td>非字母、数字或下划线</td></tr></tbody></table><p>使用正则表达式主要用来查找和替换string中的字符。使用正则表达式可以完成以下工作：</p><p>Match : 用输入来对比某个正则表达式</p><p>Search : 查找与patter匹配的正则表达式</p><p>Tokenize : 将语法切分，取得词汇单元</p><p>Replace : 替换第一个或者所有与pattern匹配的。</p><p>现在就看看正则表达式匹配和查找接口。</p><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">bool</span>)&gt; out = [](<span class="keyword">bool</span> b)&#123;<span class="built_in">cout</span> &lt;&lt; (b? <span class="string">&quot;found&quot;</span> : <span class="string">&quot;not found&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="comment">//match</span></span><br><span class="line">    <span class="built_in">string</span> text = <span class="string">&quot;&lt;tag&gt;value&lt;/tag&gt;&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;.*&gt;.*&lt;/.*&gt;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> found = regex_match(text,reg);</span><br><span class="line">    out(found);</span><br><span class="line">    <span class="comment">//match</span></span><br><span class="line">    <span class="function">regex <span class="title">reg1</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>)</span></span>;</span><br><span class="line">    found =  regex_match(text,reg1);</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use grep</span></span><br><span class="line">    <span class="function">regex <span class="title">reg2</span><span class="params">(<span class="string">R&quot;(&lt;\(.*\)&gt;.*&lt;/\1&gt;)&quot;</span>,regex_constants::grep)</span></span>;</span><br><span class="line">    found = regex_match(text,reg2);</span><br><span class="line">    out(found);</span><br><span class="line">    <span class="comment">//use c-style</span></span><br><span class="line">    found = regex_match(<span class="string">&quot;&lt;tag&gt;value&lt;/tag&gt;&quot;</span>,regex(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fail to match but can search</span></span><br><span class="line">    text = <span class="string">&quot;XML tag: &lt;tag&gt;value&lt;/tag&gt;&quot;</span>;</span><br><span class="line">    found = regex_match(text,regex(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    found = regex_match(text,regex(<span class="string">&quot;.*&lt;(.*)&gt;.*&lt;/\\1&gt;.*&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    found = regex_search(text,regex(<span class="string">&quot;&lt;(.*)&gt;.*&lt;/\\1&gt;&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line"></span><br><span class="line">    found = regex_search(text,regex(<span class="string">&quot;.*&lt;(.*)&gt;.*&lt;/\\1&gt;.*&quot;</span>));</span><br><span class="line">    out(found);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久之前就想学一下正则表达式，&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Numpy之ndarray</title>
    <link href="http://example.com/jsblog/8d30cb7a.html"/>
    <id>http://example.com/jsblog/8d30cb7a.html</id>
    <published>2020-12-20T10:18:00.000Z</published>
    <updated>2020-12-20T11:08:57.668Z</updated>
    
    <content type="html"><![CDATA[<p>ndarray 是多维数组对象，NumPy的核心特征之一就是N-维数组对象–ndarray。<a id="more"></a>ndarray是Python中一个快速、灵活的大型数据容器。允许使用类似标量的操作语法在整块数据上进行科学计算。</p><p>一个ndarray是一个通用的多维同类型数据容器，它包含的每一个元素都是相同的类型。每一个数组都有一个shape属性，用来表征数组每一维度的数量，每一个数组都有一个dtype属性表示数组中的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(data.shape)</span><br><span class="line">print(data.dtype)</span><br></pre></td></tr></table></figure><p>也可以使用list生成一个ndarray不过要使用numpy中的array函数，array函数接收任意的序列型对象，生成一个新的包含传递数据的NumPy数组。如果不显式指定，否则array函数会自动推断数组的数据类型，数据类型被存储在一个特殊的元数据dtype中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r1 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">data2 = np.array(arr1)</span><br><span class="line">print(data2.ndim)</span><br><span class="line">print(data2.shape)</span><br></pre></td></tr></table></figure><p>除了以上的方法用来创建ndarray还有其他函数用来创建数组。zeros函数创建全0的ndarray，ones创建元素值全为1的ndarray。使用empty函数则是创建一个没有初始化数值的数组。如果需要创建高维数组需要为shape传递一个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.zeros(<span class="number">10</span>))</span><br><span class="line">print(np.ones((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>)))</span><br></pre></td></tr></table></figure><p>arange是Python内建函数range的数组版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>下表示用来创建数组的函数，如果没有指明数据类型，则生成元素的默认数据类型为dtype.</p><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>array</td><td>将输入数据转换为ndarray，若不显示指定类型，则自动推断，默认复制所有输入数据</td></tr><tr><td>asarray</td><td>将输入转换为ndarray,但输入时ndarray时则不再复制</td></tr><tr><td>arange</td><td>arange是Python内建函数range的数组版本。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;ndarray 是多维数组对象，NumPy的核心特征之一就是N-维数组对象–ndarray。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程promise</title>
    <link href="http://example.com/jsblog/68f0c029.html"/>
    <id>http://example.com/jsblog/68f0c029.html</id>
    <published>2020-12-20T07:09:10.000Z</published>
    <updated>2020-12-20T11:02:55.255Z</updated>
    
    <content type="html"><![CDATA[<p>如何在线程之间传递参数和处理异常（也就是线程的高级接口如何实现这一技术）。 <a id="more"></a>如果要传递参数给线程，可以把它当做参数来传递，如果想要线程的运行结果可以通过by reference的方式传递参数。</p><p>另外一个用来传递运行结果和异常的机制是使用std::promise,promise对象是future对象配对兄弟，二者都能暂时拥有一个shared state (用来表现一个结果或者异常值)，但是future object允许你取回数据，promise是让你提供数据。其中promise的声明位于头文件<future>中。</future></p><p>在创建promise对象之后，这个对象内部会建立一个shared state用来存放结果值或者异常，并可以被future对象取走并当做线程结果。在传递的时候为了使用by reference，我们可以使用函数std::ref,这样就可以在线程中改变promise对象的shared state。如果promise对象的shared state存有一个结果或者一个异常，其状态还会变成ready。如果想在线程结束时将shared state设置为ready需要用到set_value_at_thread_exit()函数或者set_exception_at_thread_exit()函数，不应使用set_value()或set_exception()函数。</p><p>对于promise函数来说，调用get_future()函数仅仅只能够调用一次，调用多次的话会抛出std::future_error。</p><p>使用promise的实例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doThings</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//read a char</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;read a char : &quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">//if &#x27;x&#x27; throw runtime_error</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot; char &quot;</span>) + c +<span class="string">&quot; read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s= <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot; char &quot;</span>) + c +<span class="string">&quot; processed&quot;</span>;</span><br><span class="line">        p.set_value(<span class="built_in">std</span>::<span class="built_in">move</span>(s));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        p.set_exception(<span class="built_in">std</span>::current_exception()); <span class="comment">//some exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(doThings,<span class="built_in">std</span>::ref(p))</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">        <span class="comment">//get future</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fs = p.get_future();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is : &quot;</span> &lt;&lt;fs.<span class="built_in">get</span>() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is : &quot;</span> &lt;&lt;fs.<span class="built_in">get</span>() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::exception <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Exception : &quot;</span> &lt;&lt;e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Exception &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何在线程之间传递参数和处理异常（也就是线程的高级接口如何实现这一技术）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程packaged_task</title>
    <link href="http://example.com/jsblog/dd61c093.html"/>
    <id>http://example.com/jsblog/dd61c093.html</id>
    <published>2020-12-20T07:08:27.000Z</published>
    <updated>2020-12-20T13:38:41.006Z</updated>
    
    <content type="html"><![CDATA[<p>类模板声明如下：<a id="more"></a></p><p>template <class> class packaged_task;</class></p><p>template&lt;class R,class …Args&gt;</p><p>class packaged_task&lt;R(Args…)&gt;;</p><p>类模板std::package_task 包含所有可调用对象（function,lambda expression,bind expression or another function object，所以它能够异步执行。它返回一个包含处理后的结果或者是异常的状态的std::future对象。std::packaged_task是一个多态，支持分配器的容器，它所包含的可调用目标可能被分配在堆中或者提供的分配器中。</p><p>std::packaged_task构造函数：</p><p><img src="https://pic4.zhimg.com/80/v2-f595c1e6e7373bc48c17f4f03aa9caef_720w.jpg" alt="img"></p><p>构造一个续保的packaged_task对象，其中copy constructor已经被禁用，看一下说明：</p><p>\1. 默认无参构造函数</p><p>\2. 显示构造一个packaged_task对象，其任务由参数f指定。</p><p>\3. 显示构造函数，使用提供的分配器用来保存任务</p><p>\4. copy constructor被禁用</p><p>\5. move constructo</p><p>std::packaged_task 将copy assignment 也给禁用了，只能同过移动语义为将一个packaged_task对象的资源移动给另外一个packaged_task对象。如果直接使用 “=”会编译出错。即如下代码所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">bar</span><span class="params">([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x*<span class="number">10</span>;&#125;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> barx = <span class="built_in">std</span>::move(bar);</span><br></pre></td></tr></table></figure><p>std::packaged_task中的valid函数用来检查对象是否含有可共享的状态。</p><p>std::packaged_task中的swap函数用来交换当前对象与另外一个对象的状态</p><p>std::packaged_task的get_future()返回一个future对象</p><p>**std::packaged_task::operator()(Args… args)**的功能是调用packaged_task对象所包装的可调用对象并将参数args传入到其所包装的可调用对象中。调用成功，返回值保存在packaged_task的共享状态中，调用失败，异常会被保存在共享状态中，但是两者都会是共享状态变为ready. 因此其他等待该共享状态的线程可以获取共享状态的值或者异常并继续执行下去.</p><p><strong>std::packaged_task::make_ready_at_thread_exit(ArgTypes…args);</strong> 的功能是调用packaged_task对象所包装的可调用对象并将参数args传入到其所包装的可调用对象中。与**std::packaged_task::operator()(Args… args)**类似，但是只有在线程退出的时候，才将共享状态设置为ready.</p><p>*<em>std:;packaged_task::reset()**重置 packaged</em>task 的共享状态，但是保留之前的被包装的任务。注意：在使用reset的时候，不能使用get_future两次，会出问题。*</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::microseconds(<span class="built_in">std</span>::<span class="built_in">abs</span>(b-a)));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="string">&quot; sleep for &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b-a) &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(b-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//construct a packaged_task</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">fo</span><span class="params">(foo)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if fo is valid and exchange foox with fo</span></span><br><span class="line">  <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; foox;</span><br><span class="line">  <span class="keyword">if</span> (fo.valid())&#123;</span><br><span class="line">    fo.swap(foox);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//get future</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f = foox.get_future();</span><br><span class="line">  <span class="comment">//create a thread</span></span><br><span class="line">  <span class="built_in">std</span>::thread(<span class="built_in">std</span>::move(foox),<span class="number">20</span>,<span class="number">30</span>).detach();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> val = f.get();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//move</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">bar</span><span class="params">([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x*<span class="number">10</span>;&#125;)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> barx = <span class="built_in">std</span>::move(bar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f2 = barx.get_future();</span><br><span class="line">  barx(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f2.get()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//reset</span></span><br><span class="line">  barx.reset();</span><br><span class="line">  f2 = barx.get_future();</span><br><span class="line">  <span class="built_in">std</span>::thread(<span class="built_in">std</span>::move(barx),<span class="number">10</span>).join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;f2.get()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;类模板声明如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程之std::async</title>
    <link href="http://example.com/jsblog/110f3198.html"/>
    <id>http://example.com/jsblog/110f3198.html</id>
    <published>2020-12-20T07:06:39.000Z</published>
    <updated>2020-12-20T13:39:01.435Z</updated>
    
    <content type="html"><![CDATA[<p>不知道好久之前写过了thread入门这篇文章了，<a id="more"></a>突然发现好多东西都是写了简单的入门并没有怎么深入的去写过了。就连socket编程也只是写到poll模型还没有学到epoll模型。现在又要重新把这些没有学的知识好好的补一下了。现在是继续学习多线程编程，虽然工作中没有用到，但我相信始终会用到的，可能理解的不会很深入吧，但是也还是要好好的学习一下。在那个thread入门那篇文章中，我好像没有说明线程与进程的关系，以及进程的几种状态。当然也没有说明线程的几种模型。当然这些知识可能在网上一搜就都能搜到，如果想要深入的了解学习，我还是比较建议去学习一下有关操作系统的知识。</p><p>不说废话了，还是来看一下c++11中的有关线程的一些操作吧，当然一天一个知识点我就觉得非常不错了。但是每天还是要看看新的知识，不要让自己与外界隔离。这样才能紧跟时代的变化，做一个弄潮儿，虽然我不是。</p><p>现在要学习的是std::async()和std::future()两个接口。首先去<a href="https://link.zhihu.com/?target=http://cppreference.com">http://cppreference.com</a>上看一下这个函数的介绍吧</p><p>std::async 定位于头文件<future>其函数原型如下：</future></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="keyword">result_of_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Function&gt;(<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">async(Function&amp;&amp; f, Args&amp;&amp;... args); <span class="comment">//c++11 和c++17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Function&gt;, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Args&gt;...&gt;&gt;</span><br><span class="line">async(Function&amp;&amp; f, Args&amp;&amp;... args); <span class="comment">//c++17 和c++20</span></span><br></pre></td></tr></table></figure><p>函数模板 <code>async</code> 异步地运行函数 <code>f</code> （潜在地在可能是线程池一部分的分离线程中），并返回最终将保有该函数调用结果的<a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/thread/future">std::future</a>。</p><p>其参数说明：</p><p>f : 要调用的可调用对象，可以使lambda对象</p><p>args…:传递给f的参数</p><p>policy : 发射的策略，是一个枚举，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">launch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  async = <span class="number">1</span>, <span class="comment">//异步求值</span></span><br><span class="line">  deferred = <span class="number">2</span> <span class="comment">//返回的future对象调用get时求值，非异步求值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值为 std::future对象，返回的future有三种状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Status code for futures</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ready,<span class="comment">//异步操作已经完成</span></span><br><span class="line">  timeout,<span class="comment">// 异步操作已经完成</span></span><br><span class="line">  deferred,<span class="comment">//异步操作还没开始</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若运行策略等于 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/thread/launch">std::launch::async</a> 且实现无法开始新线程（该情况下，若运行策略为 async|deferred 或设置了额外位，则它将回退到 deferred 或实现定义的策略），则抛出以 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/error/errc">std::errc::resource_unavailable_try_again</a> 为错误条件的 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/error/system_error">std::system_error</a> ，或者若无法分配内部数据结构所用的内存，则为 <a href="https://link.zhihu.com/?target=https://zh.cppreference.com/w/cpp/memory/new/bad_alloc">std::bad_alloc</a> 。</p><p>看过了async,来看一下future</p><p>类模板 std::future 提供访问异步操作结果的机制：</p><p>（通过 std::async 、 std::packaged_task 或 std::promise 创建的）异步操作能提供一个 std::future 对象给该异步操作的创建者。<br>然后，异步操作的创建者能用各种方法查询、等待或从 std::future 提取值。若异步操作仍未提供值，则这些方法可能阻塞。<br>异步操作准备好发送结果给创建者时，它能通过修改链接到创建者的 std::future 的共享状态（例如 std::promise::set_value ）进行。<br>注意， std::future 所引用的共享状态不与另一异步返回对象共享（与 std::shared_future 相反）。</p><p>从官方介绍上复制了一些东西，还是来看一下实际的例子吧，毕竟实践出真知。</p><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoSomethin</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::default_random_engine  <span class="title">dre</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">uid</span><span class="params">(<span class="number">10</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::microseconds(uid(dre)));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DoSomethin(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DoSomethin(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用get或者wait时打印 .</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,func1);</span><br><span class="line">    <span class="comment">//调用get或者wait时打印+号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred,func2);</span><br><span class="line">    <span class="comment">//result2.wait();</span></span><br><span class="line">    <span class="keyword">int</span> res = result1.get() + result2.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道好久之前写过了thread入门这篇文章了，&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>epoll</title>
    <link href="http://example.com/jsblog/32082a79.html"/>
    <id>http://example.com/jsblog/32082a79.html</id>
    <published>2020-12-20T06:49:37.000Z</published>
    <updated>2020-12-20T07:03:49.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是epoll"><a href="#什么是epoll" class="headerlink" title="什么是epoll"></a>什么是epoll</h2><p>epoll是linux内核的可扩展I/O事件通知机制，在linux2.5首次登场，它的目标是取代既有的posix select与poll系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能，epoll实现的功能与poll类似，都是监听多个文件描述符上的事件。<a id="more"></a>epoll通过使用红黑树搜索被监控的文件描述符。</p><h2 id="为什么会出现epoll"><a href="#为什么会出现epoll" class="headerlink" title="为什么会出现epoll"></a>为什么会出现epoll</h2><p>出现epoll是因为现有的select以及poll不能够满足系统的需求，并且两者的开销在进行大量IO操作的时候都很大。首先看一下select的问题：</p><p>每次调用select都要将fd_set集合从用户态拷贝到内核态，当fd_set集合很大时，开销很大，每次调用select都需要在内核遍历传递来的所有的fd_set，如果fd_set很大，开销会很大，fd_set的大小由限制，系统中通过宏来控制而且不可改变（限制为1024）。Poll机制和select机制差不多，但是poll机制解决了文件描述符数量的限制但是没有解决当文件描述符过多的时候开销过大的问题。epoll是基于事件驱动的IO方式，epoll没有描述符个数限制。</p><h2 id="epoll触发模式"><a href="#epoll触发模式" class="headerlink" title="epoll触发模式"></a>epoll触发模式</h2><p>epoll提供了边缘触发和水平触发模式。在ET（边缘）模式中，epoll检测到有IO事件时，通过epoll_wait调用会得到有事件通知的文件描述符，如果不处理这个文件模式符，那么下次调用epoll_wait的时候就不会再次通知此事件（直到有某些操作将就绪变成未就绪状态，也就是说边缘模式只通知一次）；而LT（水平触发）模式时默认的工作模式，即当epoll_wait检查到文件描述符事件时会立即通知应用程序，如果应用程序不处理，下次调用epoll_wait的时候还会再次通知。</p><h2 id="epoll的系统调用（要包含sys-epoll-h头文件）"><a href="#epoll的系统调用（要包含sys-epoll-h头文件）" class="headerlink" title="epoll的系统调用（要包含sys/epoll.h头文件）"></a>epoll的系统调用（要包含sys/epoll.h头文件）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>\1. epoll_create函数创建一个epoll句柄，参数size表明内核要监听的描述符数量，调用成功返回一个epoll句柄描述符。epoll_create已经被弃用，更多推荐使用epoll_create1函数来代替，</p><p>\2. epoll_ctl函数用来注册要监听的事件类型，参数解释如下：</p><p>epfd ：表示epoll句柄</p><p>op : 表示fd的操作类型，有一下三种</p><ul><li>EPOLL_CTL_ADD 注册新的fd到epfd中</li><li>EPOLL_CTL_MOD 修改已注册的fd的监听事件</li><li>EPOLL_CTL_DEL 从epfd中删除一个fd</li></ul><p>fd: 要监听的描述符</p><p>event 表示要监听的事件。epoll_event的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"> <span class="keyword">void</span> *ptr;</span><br><span class="line"> <span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">uint32_t</span> u32;</span><br><span class="line"> <span class="keyword">uint64_t</span> u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>其中epoll_event中的events成员由以下可用事件类型的零个或多个组合在一起形成的掩码：</p><ul><li>EPOLLIN ： 关联的文件描述符可以读,</li><li>EPOLLOUT : 关联的文件描述符可以写；</li><li>EPOLLPRI : 关联的文件描述符由紧急的数据可以读</li><li>EPOLLERR: 关联的文件描述符发生错误</li><li>EPOLLHUP : 关联的文件描述符被挂断</li><li>EPOLLRDHUP : 流套接字对等关闭连接，或半关闭写</li><li>EPOLLET： 设置为边缘触发模式</li><li>EPOLLONESHOT : 只监听一次事件，如果要继续监听这个事件，那么需要再次把这个fd加入到epoll队列中。</li></ul><p>\3. epoll_wait函数等待事件的就绪，成功时返回就绪事件数目，调用失败时返回-1，等待超时返回0.其中参数含义如下：</p><ul><li>epfd : epoll句柄</li><li>events :表示从内核的多的就绪事件集合</li><li>maxevents : 告诉内核events的大小</li><li>timeout : 表示等待的时间</li></ul><p>它会阻塞到一个文件描述符有事件发生；信号中断处理或者超时。</p><h2 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h2><p>支持一个进程打开大数目的文件描述符，select对于文件描述符的大小由一定的限制，epoll则没有这个限制；IO效率不会随着文件描述符数目的增加而线性下降，select/poll都会随着文件描述符的数量增加而性能降低，因为在有事件发生的时候select和poll都要遍历所有的文件描述符才能确定是哪一个文件描述符由事件，而epoll则只会对活跃的文件描述符进行操作。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符。epoll使用mmap进行内核与用户空间消息传递。</p><h2 id="epoll实例"><a href="#epoll实例" class="headerlink" title="epoll实例"></a>epoll实例</h2><p>下面学习了这些理论的基础，还是要实践一下的。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFF 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 9873</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSockfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_IP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">    bzero(&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(port);</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd,(struct sockaddr*)&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to bind\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd,<span class="number">1024</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to listen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNoBlockfd</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(sockfd,F_SETFL,fcntl(sockfd,F_GETFD,<span class="number">0</span>) |O_NONBLOCK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to set nonblock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> listen_fd,conn_fd,nfds,epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">inAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> in_len = <span class="keyword">sizeof</span>(inAddr);</span><br><span class="line">    bzero(&amp;inAddr,in_len);</span><br><span class="line">    <span class="comment">//create listen fd</span></span><br><span class="line">    listen_fd = createSockfd(PORT);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to create sockfd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set no block</span></span><br><span class="line">    <span class="keyword">if</span> (setNoBlockfd(listen_fd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//create epollfd</span></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create1(<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to create epollfd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register the listen fd</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd,EPOLL_CTL_ADD,listen_fd,&amp;ev) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to add listen fd\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buff[MAX_BUFF];</span><br><span class="line">    bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = epoll_wait(epollfd,events,MAX_EVENTS,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, (struct sockaddr *) &amp;inAddr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                setNoBlockfd(conn_fd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connect form: %s\n&quot;</span>, inet_ntoa(inAddr.sin_addr));</span><br><span class="line">                <span class="comment">//register conn_fd</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> nread = read(events[i].data.fd,buff,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">                <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                    epoll_ctl( epollfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buff);</span><br><span class="line">                <span class="keyword">if</span> (write(events[i].data.fd,buff,nread) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是epoll&quot;&gt;&lt;a href=&quot;#什么是epoll&quot; class=&quot;headerlink&quot; title=&quot;什么是epoll&quot;&gt;&lt;/a&gt;什么是epoll&lt;/h2&gt;&lt;p&gt;epoll是linux内核的可扩展I/O事件通知机制，在linux2.5首次登场，它的目标是取代既有的posix select与poll系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能，epoll实现的功能与poll类似，都是监听多个文件描述符上的事件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="http://example.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>FFMPEG之libavfilter</title>
    <link href="http://example.com/jsblog/17b182ff.html"/>
    <id>http://example.com/jsblog/17b182ff.html</id>
    <published>2020-12-20T06:28:40.000Z</published>
    <updated>2020-12-20T06:49:05.517Z</updated>
    
    <content type="html"><![CDATA[<p>FFMPEG除了具有编解码的能力之外，还包含一个强大的功能组件—滤镜avfilter。<a id="more"></a>avfilter经常用于多媒体的处理与编辑。在使用滤镜处理音视频的特效之前，首先需要了解一下Filter的基本格式。</p><p>FFMPEG中的滤镜参数的排列方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[输入流或者标记名]滤镜参数[临时变量名]；[输入流或者标记名]滤镜参数[临时变量名]...</span><br></pre></td></tr></table></figure><p>在设置一些滤镜的时候经常会使用到根据时间轴进行的操作，也就不可避免的要使用到FFMPEG中的Filter的时间内置变量。接下来看一下Filter内置的时间变量，下表是Filter内置的时间变量：</p><table><thead><tr><th>说明</th><th>变量</th></tr></thead><tbody><tr><td>t</td><td>时间戳以秒表示，如果输入的时间位置，则是NAN</td></tr><tr><td>n</td><td>输入帧的顺序编号，从0开始</td></tr><tr><td>pos</td><td>输入帧的位置，如果未知就是NAN</td></tr><tr><td>w</td><td>视频帧的宽度</td></tr><tr><td>h</td><td>视频帧的高度</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;FFMPEG除了具有编解码的能力之外，还包含一个强大的功能组件—滤镜avfilter。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFMPEG" scheme="http://example.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>Python之tuple</title>
    <link href="http://example.com/jsblog/84150675.html"/>
    <id>http://example.com/jsblog/84150675.html</id>
    <published>2020-12-20T06:06:55.000Z</published>
    <updated>2020-12-20T06:07:44.332Z</updated>
    
    <content type="html"><![CDATA[<p>以前就学过Python,因为许久不用导致Python中的好多知识都忘记了。<a id="more"></a>现在想要重新拿起来。主要就是为了学习Python的爬虫技术以及如何使用Python的django库。同时对于OpenCV也比较感兴趣，而Python又是那么的方便，人生苦短，我用python。</p><p>首先看一下Python的数据结构：</p><p><strong>tuple 元组：元组是一种固定长度、不可变的Python对象序列.</strong></p><p>最简单的创建方法就是使用逗号分隔序列值，通过复杂的表达式来定义元组时，通常需用括号将值包起来。可以使用tuple函数将任意序列或迭代器转换为元组。元组的元素可以通过operator[]操作符来获取，但是不能修改，也就是说元组一旦创建，各个位置上的对象时无法修改的。如果元组中的对象时可变的，如果元组中有列表对象，那么可以对这个列表对象进行操作，但是不能修改元组的对象。</p><p>看一下如何创建元组以及获取元组某索引的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple1 &#x3D; 1,2,3,4,5,6,7,[]</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [])</span><br><span class="line">&gt;&gt;&gt; tuple2 &#x3D; tuple([8,9,5])</span><br><span class="line">&gt;&gt;&gt; tuple2</span><br><span class="line">(8, 9, 5)</span><br><span class="line">&gt;&gt;&gt; tuple1[2]</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; tuple1[7].append(1)</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [1])</span><br></pre></td></tr></table></figure><p><strong>使用 + 号连接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple1 + tuple2</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, [1], 8, 9, 5)</span><br></pre></td></tr></table></figure><p>将元组乘以整数，生成含有多份拷贝的元组，对象自身并没有复制，只是指向它们的引用复制了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple2 * 2</span><br><span class="line">(8, 9, 5, 8, 9, 5)</span><br></pre></td></tr></table></figure><p><strong>元组解包：将元组类型的表达式赋值给变量，Python会对等号右边的值进行拆包。也可以嵌套拆包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t3 &#x3D; (&quot;a&quot;,&quot;b&quot;,(12,&quot;d&quot;))</span><br><span class="line">&gt;&gt;&gt; a,b,(c,d) &#x3D; t3</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#39;d&#39;</span><br></pre></td></tr></table></figure><p>交换两个值的变量，在Python中很方便即如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; a,b &#x3D; b,a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#39;a&#39;</span><br></pre></td></tr></table></figure><p>python有一种更高级的拆包功能，用于帮助从元组的起始位置采集一些元素，特殊语法是 *variable，用于函数调用时获取任意长度的位置参数列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; values &#x3D; 1,2,3,4,5</span><br><span class="line">&gt;&gt;&gt; a,b,*_ &#x3D; values</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; _</span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure><p>用于元组的其他操作：</p><p>tuple.count(val) ：用于计量某个数值在元组中出现的次数</p><p>comp(tuple1,tuple2) : 比较两个元组</p><p>len(tuple) : 计算元组中元素个数</p><p>max(tuple) : 返回元组中最大值</p><p>min(tuple) : 返回元组中最小值</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前就学过Python,因为许久不用导致Python中的好多知识都忘记了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之list</title>
    <link href="http://example.com/jsblog/1cfd35a1.html"/>
    <id>http://example.com/jsblog/1cfd35a1.html</id>
    <published>2020-12-20T06:05:59.000Z</published>
    <updated>2020-12-20T06:07:44.331Z</updated>
    
    <content type="html"><![CDATA[<p>列表的长度是可变的。<a id="more"></a>其元素也是可以修改的、可以使用[]或者list类型函数来定义列表。</p><p>列表定义操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [1,2,3,4,5,8]</span><br><span class="line">list2 &#x3D; list((1,2,3,4,5))</span><br><span class="line">print(list1)</span><br><span class="line">print(list2)</span><br></pre></td></tr></table></figure><p>list函数在数据处理中常用于将迭代器或生成器转化为列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen &#x3D; range(10)</span><br><span class="line">print(list(gen))</span><br><span class="line">print(gen)</span><br></pre></td></tr></table></figure><p>添加或删除元素；</p><p>list.append(): 添加到尾部</p><p>list.insert(pos，val) : 将val添加到指定位置</p><p>list.pop(pos): 将pos位置的元素移除</p><p>list.remove(val) : 将定义第一个符合要求的值移除</p><p>使用 in 或 not in 判断值是否在list中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list3 &#x3D; list(range(10))</span><br><span class="line">list3.append(&quot;foo&quot;)</span><br><span class="line">list3.insert(1,&quot;lll&quot;)</span><br><span class="line">print(list3)</span><br><span class="line">list3.pop(0)</span><br><span class="line">list3.remove(&quot;foo&quot;)</span><br><span class="line">print(list3)</span><br><span class="line">print( 5 in list3)</span><br><span class="line">print( 10 not in list3)</span><br><span class="line">使用 + 号连接两个list，也可以使用extend方法向列表添加多个元素</span><br><span class="line">list4 &#x3D; [&quot;122&quot;,(1,2)]</span><br><span class="line">print(list4 + list3)</span><br><span class="line">list3.extend(list4)</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure><p>如果通过添加内容连接列表是一种相对代价较高的操作，连接过程中需要创建新表，并且要复制对象。使用extend方法扩展列表是比较好的方式。</p><p>使用sort排序，sort的一些选项可能用的上，其中一个是传递一个二级排序key 用于生成排序值的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [10,5,20,33,12,4,7]</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line">b &#x3D; [&quot;small&quot;,&quot;key&quot;,&quot;values&quot;,&quot;who are you&quot;]</span><br><span class="line">b.sort(key&#x3D;len)</span><br><span class="line">print(b)</span><br><span class="line">b.reverse()</span><br><span class="line">print(b)</span><br><span class="line">print(sorted(b,key&#x3D;len))</span><br></pre></td></tr></table></figure><p>二分查找和已排序列表的维护（必须排好序，否则会出错）</p><p>内建的bisect实现了二分搜索和排序列表的维护，bisect.bisect会找到元素应当插入的位置，而bisect.insort将元素插入相应位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line">a &#x3D; [10,5,20,33,12,4,7]</span><br><span class="line">a.sort()</span><br><span class="line">print(bisect.bisect(a,11))</span><br><span class="line">bisect.insort(a,6)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>切片它的基本形式是将start:stop传入到索引符合[]中，由于不包含stop所以其元素数量为stop-start,如果省略start或者stop则表示从默认传入序列的起始位值或者结束位置。负索引可以从序列的尾部进行索引.也可以指定步进值step，需要在第二个冒号后面使用，表示每隔几个值取一个，当需要对列表或者元组进行翻转时，将step设置为-1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq &#x3D; [7,2,3,7,5,6,0,1,4]</span><br><span class="line">seq[3:4] &#x3D; [8,9]</span><br><span class="line">print(seq)</span><br><span class="line">print(seq[:4])</span><br><span class="line">print(seq[5:])</span><br><span class="line">print(seq[-4:])</span><br><span class="line">print(seq[-6:-2])</span><br><span class="line">print(seq)</span><br><span class="line">print(seq[::2])</span><br><span class="line">print(seq[::-1])</span><br></pre></td></tr></table></figure><p>一些内建函数</p><p>enumerate : 返回(I,value)元组的序列，其中value时元素的值，i表示索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str_list &#x3D; [&quot;foo&quot;,&quot;bar&quot;,&quot;et&quot;]</span><br><span class="line">mapping &#x3D; &#123;&#125;</span><br><span class="line">for i,val in enumerate(str_list):</span><br><span class="line"> mapping[val] &#x3D; i</span><br><span class="line">print(mapping)</span><br></pre></td></tr></table></figure><p>sorted函数，返回一个根据任意序列中的新建的已排序列表</p><p>zip ：将列表、元组或其他序列的元素配对，新建一个元组构成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str_list1 &#x3D; [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</span><br><span class="line">str_list2 &#x3D; [&quot;one&quot;,&#39;two&#39;,&#39;three&#39;]</span><br><span class="line">zipped &#x3D; zip(str_list1,str_list2)</span><br><span class="line">print(list(zipped))</span><br><span class="line">l1,l2&#x3D; zip(*zip(str_list1,str_list2))</span><br><span class="line">print(list(l1))</span><br><span class="line">print(list(l2))</span><br></pre></td></tr></table></figure><p>reversed : 将序列的元素带线排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(reversed(range(10))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;列表的长度是可变的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
</feed>
