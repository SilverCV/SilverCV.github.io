<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-05T22:39:04.981Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JSL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>像素操作</title>
    <link href="http://example.com/jsblog/561fe8cb.html"/>
    <id>http://example.com/jsblog/561fe8cb.html</id>
    <published>2020-09-05T22:38:19.000Z</published>
    <updated>2020-09-05T22:39:04.981Z</updated>
    
    <content type="html"><![CDATA[<p>我们首先了解一下什么是像素，计算机中是如何存储图像，以及opencv是如何表示图像的。</p><p><strong>像素</strong>：</p><p>像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。可以将像素视为整个图像中不可分割的单位或者是元素，不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小</p><p><strong>计算机存储图像：</strong></p><p>图像文件存储的都是每一个像素对应的颜色值。</p><p>1、<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d-ryfLmhcLmyPWuHIBnAu90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1bdP1cvnH0d">位图文件</a>有两种存储像素数据的格式。16777216色（真彩色）的图像，一个像素的颜色可以用24位数据表示。256色的图像可以用调色板对颜色的信息进行编码，一个像素的值对应的是调色板的索引，而不是直接对应一个像素的颜色，调色板的索引映射为像素的颜色。</p><p>2、以一百万个像素，256种颜色的BMP文件在电脑上的存储为例。这个文件包括一个十四字节的文件首部，一个四十字节的信息首部，一个1024字节的颜色表，一兆字节的位图数据。文件首部的前两个字节由字符BM组成，还包括了文件长度和位图数据在文件中的起始位置。</p><p>3、文件的信息首部包含了图像的高、宽、颜色数等非图形数据。</p><p>这个图像共有一百万个像素，一个像素需要八位的颜色信息，文件的这一部分的长度是一百万个字节，字节排放的顺序是自左到右从图像的最下面那行开始，这个文件的总大小是1001078字节。</p><p><strong>opencv表示图像：</strong></p><p>opencv中很多<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/datastructure">数据结构</a>为了达到內存使用的最优化，通常都会用它最小上限的空间来分配变量，有的数据结构也会因为图像文件格式的关系而给予适当的变量，因此需要知道它们声明的空间大小来配置适当的变量。一</p><p>般标准的图片，为RGB格式它们的大小为8bits格式，范围为0~255,对一个int空间的类型来说实在是太小，整整浪费了24bits的空间,假设有个640<em>480的BMP文件空间存储內存,那整整浪费了640</em>480<em>3</em>(32-8)bits的內存空间,总共浪费了2.6MB!，也就是那<br>2.6MB内什么东西都没存储，如果今天以8bits的格式来存储则只使用到0.6MB的內存而已(640<em>480</em>3*(8)+54<br>bits)，因此，对于文件格式的对应是一件很重要的事.。</p><p>访问像素的三种方法：</p><ol><li>指针访问</li><li>迭代器iterator</li><li>动态地址计算</li></ol><p>首先我们来看一段代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">//指针操作访问像素</span><br><span class="line">void colorReduce(Mat&amp; img,int div=64)</span><br><span class="line">&#123;</span><br><span class="line">    int nl = img.rows;</span><br><span class="line">    int nc = img.cols*img.channels();</span><br><span class="line">    for(int i = 0;i &lt; nl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* data = img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for(int j = 0 ; j &lt; nc;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j]/div*div + div/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//迭代器模式</span><br><span class="line">void ColorReduce(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator it = img.begin&lt;Vec3b&gt;();</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator itend = img.end&lt;Vec3b&gt;();</span><br><span class="line">for (; it != itend; it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)[0] = (*it)[0] / div * div + div / 2;</span><br><span class="line">(*it)[1] = (*it)[1] / div * div + div / 2;</span><br><span class="line">(*it)[2] = (*it)[2] / div * div + div / 2;</span><br><span class="line">&#125;</span><br><span class="line">namedWindow(&quot;dst&quot;);</span><br><span class="line">imshow(&quot;dst&quot;, img);</span><br><span class="line">&#125;</span><br><span class="line">//动态地址计算</span><br><span class="line">void colorReduce2(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">    int cols = img.cols;</span><br><span class="line">    int rows = img.rows;</span><br><span class="line">    for(int i= 0;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[0] = img.at&lt;Vec3b&gt;(i,j)[0] / div * div +div /2;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[1] = img.at&lt;Vec3b&gt;(i,j)[1] / div * div +div /2;</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[2] = img.at&lt;Vec3b&gt;(i,j)[2] / div * div +div /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    Mat image = imread(argv[1]);</span><br><span class="line">    imshow(&quot;input&quot;,image);</span><br><span class="line">    colorReduce2(image,64);</span><br><span class="line">    imshow(&quot;dst&quot;,image);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    destroyAllWindows();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针操作：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//指针操作访问像素</span><br><span class="line">void colorReduce(Mat&amp; img,int div=64)</span><br><span class="line">&#123;</span><br><span class="line">    int nl = img.rows;　// 行数</span><br><span class="line">    int nc = img.cols*img.channels();//列数ｘ通道数　＝　每一行像素的个数</span><br><span class="line">    for(int i = 0;i &lt; nl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">　　　　　//Mat类提供了ｐｔｒ函数可以得到任意行的首地址，ｐｔｒ是一个模板函数</span><br><span class="line">        uchar* data = img.ptr&lt;uchar&gt;(i);　//获取第ｉ行的首地址</span><br><span class="line">        for(int j = 0 ; j &lt; nc;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j]/div*div + div/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器操作：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//迭代器模式</span><br><span class="line">void ColorReduce(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator it = img.begin&lt;Vec3b&gt;();</span><br><span class="line">Mat_&lt;Vec3b&gt;::iterator itend = img.end&lt;Vec3b&gt;();</span><br><span class="line">for (; it != itend; it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)[0] = (*it)[0] / div * div + div / 2;</span><br><span class="line">(*it)[1] = (*it)[1] / div * div + div / 2;</span><br><span class="line">(*it)[2] = (*it)[2] / div * div + div / 2;</span><br><span class="line">&#125;</span><br><span class="line">namedWindow(&quot;dst&quot;);</span><br><span class="line">imshow(&quot;dst&quot;, img);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不熟悉迭代器模式，可以阅读与ＳＴＬ中迭代器相关的资料。</p><p><strong>动态地址计算：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//动态地址计算</span><br><span class="line">void colorReduce2(Mat&amp; img,int div = 64)</span><br><span class="line">&#123;</span><br><span class="line">    int cols = img.cols;　//列数</span><br><span class="line">    int rows = img.rows;　//行数</span><br><span class="line">    for(int i= 0;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j &lt; cols;j++)</span><br><span class="line">        &#123;　　//处理Ｂ蓝色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[0] = img.at&lt;Vec3b&gt;(i,j)[0] / div * div +div /2;</span><br><span class="line">　　　　　　　//处理Ｇ绿色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[1] = img.at&lt;Vec3b&gt;(i,j)[1] / div * div +div /2;</span><br><span class="line">　　　　　　　//处理Ｒ红色通道</span><br><span class="line">            img.at&lt;Vec3b&gt;(i,j)[2] = img.at&lt;Vec3b&gt;(i,j)[2] / div * div +div /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于彩色图像，每个像素由三个部分：蓝色通道，绿色通道，红色通道（ＢＧＲ）。因此对于一个包含彩色图像的Ｍａｔ，会返回一个８位数组组成的向量。ＯｐｅｎＣＶ将此向量定义为Vec3b，即由usigned char 组成的向量。其访问像素通用表达式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.at&lt;Vec3b&gt;(row,col)[channel] = value;</span><br></pre></td></tr></table></figure><p>其中索引值表示通道。</p><p>这就是访问像素的三种方法，我们看一下效果：</p><p><img src="https://pic3.zhimg.com/80/v2-e27989af32f67f200762d904263dec3a_720w.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们首先了解一下什么是像素，计算机中是如何存储图像，以及opencv是如何表示图像的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;像素&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>图像腐蚀</title>
    <link href="http://example.com/jsblog/7525f478.html"/>
    <id>http://example.com/jsblog/7525f478.html</id>
    <published>2020-09-05T12:59:10.000Z</published>
    <updated>2020-09-05T22:31:46.698Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来了解一下什么是腐蚀，为什么要进行图像的腐蚀。</p><p>在了解腐蚀之前我们先来了解一下结构元素</p><p>结构元素的定义如下：</p><p><strong>设有两幅图象B，X。若X是被处理的对象，而B是用来处理X的，则称B为结构元素(structure element)，又被形象地称做刷子。结构元素通常都是一些比较小的图象。</strong></p><p>接下来我们看一下腐蚀的定义：</p><p><strong>在图像的形态学操作中腐蚀就是删除对象边界的某些点的像素</strong></p><p>腐蚀的作用：</p><ul><li>边缘检测</li><li>噪声过滤</li><li>形态骨架提取</li></ul><p>其 数学表达式为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst(x,y) = min src( x + x`,y+y`) 其中 （x`,y`）: element(x`,y`) != 0</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>对Z中的集合A和B，B对A进行腐蚀的整个过程如下：</p><p>⑴ 用结构元素B，扫描图像A的每一个像素</p><p>⑵ 用结构元素与其覆盖的二值图像做“与”操作</p><p>⑶ 如果都为1，结果图像的该像素为1。否则为0</p><p>腐蚀处理的结果是使原来的二值图像减小一圈</p><p><strong>代码：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat srcImage = cv::imread(&quot;32.jpg&quot;);//read the file</span><br><span class="line">if (srcImage.empty())</span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; &quot;the file does not exits!&quot; &lt;&lt; std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">//get the structure element</span><br><span class="line">cv::Mat StructElement = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));</span><br><span class="line">//defination the result</span><br><span class="line">cv::Mat result;</span><br><span class="line">//erode the image</span><br><span class="line">cv::erode(srcImage, result, StructElement);</span><br><span class="line">//show the image</span><br><span class="line">cv::namedWindow(&quot;input&quot;,cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::namedWindow(&quot;output&quot;,cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::imshow(&quot;input&quot;,srcImage);</span><br><span class="line">cv::imshow(&quot;output&quot;,result);</span><br><span class="line">cv::waitKey(0);</span><br><span class="line">cv::destroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-530ca54b72ac02361e5075f4115f75df_720w.jpg" alt="img">input</p><p><img src="https://pic3.zhimg.com/80/v2-4c349f4595afb42a203213fab02c2e54_720w.jpg" alt="img">output</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先我们来了解一下什么是腐蚀，为什么要进行图像的腐蚀。&lt;/p&gt;
&lt;p&gt;在了解腐蚀之前我们先来了解一下结构元素&lt;/p&gt;
&lt;p&gt;结构元素的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设有两幅图象B，X。若X是被处理的对象，而B是用来处理X的，则称B为结构元素(structure </summary>
      
    
    
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
